/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./lib/pillar lazy recursive":
/*!**************************************************!*\
  !*** ./lib/pillar/ lazy strict namespace object ***!
  \**************************************************/
/***/ ((module) => {

eval("function webpackEmptyAsyncContext(req) {\n\t// Here Promise.resolve().then() is used instead of new Promise() to prevent\n\t// uncaught exception popping up in devtools\n\treturn Promise.resolve().then(() => {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t});\n}\nwebpackEmptyAsyncContext.keys = () => ([]);\nwebpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;\nwebpackEmptyAsyncContext.id = \"./lib/pillar lazy recursive\";\nmodule.exports = webpackEmptyAsyncContext;\n\n//# sourceURL=webpack://anzii/./lib/pillar/_lazy_strict_namespace_object?");

/***/ }),

/***/ "async":
/*!************************!*\
  !*** external "async" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("async");

/***/ }),

/***/ "body-parser":
/*!******************************!*\
  !*** external "body-parser" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("body-parser");

/***/ }),

/***/ "config":
/*!*************************!*\
  !*** external "config" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("config");

/***/ }),

/***/ "cors":
/*!***********************!*\
  !*** external "cors" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("cors");

/***/ }),

/***/ "debug":
/*!************************!*\
  !*** external "debug" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("debug");

/***/ }),

/***/ "detect-port":
/*!******************************!*\
  !*** external "detect-port" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("detect-port");

/***/ }),

/***/ "express":
/*!**************************!*\
  !*** external "express" ***!
  \**************************/
/***/ ((module) => {

"use strict";
module.exports = require("express");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ "jsonfile":
/*!***************************!*\
  !*** external "jsonfile" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = require("jsonfile");

/***/ }),

/***/ "mysql2":
/*!*************************!*\
  !*** external "mysql2" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("mysql2");

/***/ }),

/***/ "open":
/*!***********************!*\
  !*** external "open" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("open");

/***/ }),

/***/ "passport":
/*!***************************!*\
  !*** external "passport" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = require("passport");

/***/ }),

/***/ "portfinder":
/*!*****************************!*\
  !*** external "portfinder" ***!
  \*****************************/
/***/ ((module) => {

"use strict";
module.exports = require("portfinder");

/***/ }),

/***/ "supports-color":
/*!*********************************!*\
  !*** external "supports-color" ***!
  \*********************************/
/***/ ((module) => {

"use strict";
module.exports = require("supports-color");

/***/ }),

/***/ "uuid":
/*!***********************!*\
  !*** external "uuid" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("uuid");

/***/ }),

/***/ "winston":
/*!**************************!*\
  !*** external "winston" ***!
  \**************************/
/***/ ((module) => {

"use strict";
module.exports = require("winston");

/***/ }),

/***/ "cluster":
/*!**************************!*\
  !*** external "cluster" ***!
  \**************************/
/***/ ((module) => {

"use strict";
module.exports = require("cluster");

/***/ }),

/***/ "node:module":
/*!******************************!*\
  !*** external "node:module" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:module");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ "./lib/anzii.js":
/*!**********************!*\
  !*** ./lib/anzii.js ***!
  \**********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"./lib/base.js\");\n/* harmony import */ var _esm_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./esm/esm.js */ \"./lib/esm/esm.js\");\n/* harmony import */ var _base_activate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base/activate.js */ \"./lib/base/activate.js\");\n\n\n\nclass Anzii {\n  constructor() {\n    // console.log(Activator.Activate)\n\n    this.ANZII = _base_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n    this.ESM = _esm_esm_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"];\n    this.Activate = _base_activate_js__WEBPACK_IMPORTED_MODULE_2__.Activate;\n    // this.DomLoaded = Base.SUKU.domLoaded.bind(this.SANA.SUKU)\n    // this.Html = Base.SUKUS.html.bind(this.SANA.SUKUS)\n  }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new Anzii());\n\n//# sourceURL=webpack://anzii/./lib/anzii.js?");

/***/ }),

/***/ "./lib/base.js":
/*!*********************!*\
  !*** ./lib/base.js ***!
  \*********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _pillar_pillar_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pillar/pillar.js */ \"./lib/pillar/pillar.js\");\n/* harmony import */ var _base_core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base/core.js */ \"./lib/base/core.js\");\n/* harmony import */ var _base_pao_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base/pao.js */ \"./lib/base/pao.js\");\n\n\n\nclass Base {\n  constructor() {\n    this.CORE = _base_core_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"], this.PAO = _base_pao_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"], this.PILLAR = _pillar_pillar_js__WEBPACK_IMPORTED_MODULE_0__;\n  }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new Base());\n\n//# sourceURL=webpack://anzii/./lib/base.js?");

/***/ }),

/***/ "./lib/base/activate.js":
/*!******************************!*\
  !*** ./lib/base/activate.js ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Activate: () => (/* binding */ Activate)\n/* harmony export */ });\n/* harmony import */ var _activiator_logs_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./activiator_logs.js */ \"./lib/base/activiator_logs.js\");\n\nconst Activate = function (libs = []) {\n  (0,_activiator_logs_js__WEBPACK_IMPORTED_MODULE_0__.logInitializations)(\"The Server\");\n  (0,_activiator_logs_js__WEBPACK_IMPORTED_MODULE_0__.logInitializations)(\"THE LIBS\");\n  (0,_activiator_logs_js__WEBPACK_IMPORTED_MODULE_0__.logInitializations)(libs);\n  (0,_activiator_logs_js__WEBPACK_IMPORTED_MODULE_0__.logInitializations)(this.ESM.Esm);\n  const core = new this.ANZII.CORE(this.ANZII.PILLAR);\n  const pao = new this.ANZII.PAO(core);\n  const isAppCli = pao.PROMPT.indexOf(\"cli\") >= 0 ? true : false;\n  const anziiCliWithServer = process.env?.ANZII_CLI_WITH_SERVER || null;\n  const isAnziiCliWithServer = anziiCliWithServer && anziiCliWithServer === \"true\" ? true : false;\n  (0,_activiator_logs_js__WEBPACK_IMPORTED_MODULE_0__.logInitializations)(`isAppCLi\", ${isAppCli}`);\n  (0,_activiator_logs_js__WEBPACK_IMPORTED_MODULE_0__.logInitializations)(`isAnziiCliWithServer\", ${isAnziiCliWithServer}`);\n  (0,_activiator_logs_js__WEBPACK_IMPORTED_MODULE_0__.logInitializations)(`isInitiliazeCliWithServer check\",\n\t\t${isAppCli && isAnziiCliWithServer}`);\n  const initializeCliWithServer = isAppCli && isAnziiCliWithServer;\n  let anziiloger = {\n    Anziiloger: this.ESM.Esm.Anziiloger\n  };\n  let hitList = !initializeCliWithServer ? [\"System\", \"Middleware\", \"Router\", \"Request\", \"Server\", \"Parsers\"] : [];\n  let IO = this.ESM.Esm.IO ? {\n    IO: this.ESM.Esm.IO\n  } : null;\n  let isPush = true;\n  // logInitializations('ANZII PILLAR PROMPT')\n  // logInitializations(pao.PROMPT)\n  (0,_activiator_logs_js__WEBPACK_IMPORTED_MODULE_0__.logInitializations)(`ANZII CLI WITH SERVER\", ${anziiCliWithServer}`);\n  (0,_activiator_logs_js__WEBPACK_IMPORTED_MODULE_0__.logInitializations)(`IS ANZII CLI WITH SERVER\", ${isAnziiCliWithServer}`);\n  (0,_activiator_logs_js__WEBPACK_IMPORTED_MODULE_0__.logInitializations)(`Initialize CLI WITH SERVER\", ${initializeCliWithServer}`);\n  if (isAppCli) {\n    // logInitializations('This should be a cli app')\n    //  process.env.SUPPRESS_NO_CONFIG_WARNING = true\n\n    if (IO) delete this.ESM.Esm.IO;\n    if (!initializeCliWithServer) {\n      for (let plugin in this.ESM.Esm) {\n        if (hitList.indexOf(plugin) >= 0) {\n          //logInitializations('Deleteing modules not needed for cli operations')\n          delete this.ESM.Esm[plugin];\n        }\n      }\n    }\n  } else {\n    isPush = false;\n    if (IO) delete this.ESM.Esm.IO;\n    delete IO.IO;\n    IO = null;\n  }\n  delete this.ESM.Esm.Anziiloger;\n  (0,_activiator_logs_js__WEBPACK_IMPORTED_MODULE_0__.logInitializations)(anziiloger);\n  (0,_activiator_logs_js__WEBPACK_IMPORTED_MODULE_0__.logInitializations)(this.ESM.Esm);\n  // let global = pao.pa_clone(this.ESM.Esm.Global)\n  // delete this.ESM.Esm.Global\n  libs.unshift(anziiloger);\n  (0,_activiator_logs_js__WEBPACK_IMPORTED_MODULE_0__.logInitializations)(\"THE CORE\");\n  (0,_activiator_logs_js__WEBPACK_IMPORTED_MODULE_0__.logInitializations)(libs);\n  libs.push(this.ESM.Esm);\n  isPush ? libs.push(IO) : \"\";\n  // libs.push(global)\n  libs.forEach(lib => {\n    for (let moco in lib) {\n      (0,_activiator_logs_js__WEBPACK_IMPORTED_MODULE_0__.logInitializations)(\"Inside activate\");\n      (0,_activiator_logs_js__WEBPACK_IMPORTED_MODULE_0__.logInitializations)(moco);\n      (0,_activiator_logs_js__WEBPACK_IMPORTED_MODULE_0__.logInitializations)(\"THE LIB MOCO\");\n      (0,_activiator_logs_js__WEBPACK_IMPORTED_MODULE_0__.logInitializations)(typeof lib[moco]);\n      (0,_activiator_logs_js__WEBPACK_IMPORTED_MODULE_0__.logInitializations)(lib[moco]);\n      let moduId = moco.toLowerCase();\n      (0,_activiator_logs_js__WEBPACK_IMPORTED_MODULE_0__.logInitializations)(\"THE V\");\n      (0,_activiator_logs_js__WEBPACK_IMPORTED_MODULE_0__.logInitializations)(`Currently executing module: ${moco}`);\n      let modInstId = moduId;\n      //logInitializations('Executing module without view')\n      core.createModule(new lib[moco](pao.create(moduId, null, moco)), moduId, modInstId, moco);\n      //logInitializations(`Currently starting module: ${moco}`)\n      core.startModule(moduId, modInstId);\n      //logInitializations('Dependicies')\n      //logInitializations(typeof this.ANDZIIY.core)\n      // let moduId = mod.name.toLowerCase();\n    }\n  });\n};\n\n//# sourceURL=webpack://anzii/./lib/base/activate.js?");

/***/ }),

/***/ "./lib/base/activiator_logs.js":
/*!*************************************!*\
  !*** ./lib/base/activiator_logs.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   logInitializations: () => (/* binding */ logInitializations)\n/* harmony export */ });\nconst logInitializations = function (message = \"\") {\n  let initializationLogging = process.env.ANZII_SHOW_INITIALIZATIONS || \"false\";\n  let shouldLog = initializationLogging && initializationLogging === \"true\" ? true : false;\n  if (!shouldLog) return;\n  console.log(`Initializing Anzii: ${message}`);\n};\n\n//# sourceURL=webpack://anzii/./lib/base/activiator_logs.js?");

/***/ }),

/***/ "./lib/base/core.js":
/*!**************************!*\
  !*** ./lib/base/core.js ***!
  \**************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction CORE(lib) {\n  this.PILLAR = lib;\n  this.modules = {};\n  this.globalModules = [];\n  this.PROMPT = this.PILLAR.PROMPT;\n  // this.parent = this\n} // End of the CORE class\nCORE.prototype.createModule = function (module, moduleId, modInstId, className) {\n  var modules = this.modules;\n  this.sanna().runForModules(module, className);\n  // this.PILLAR.p_wiLog('THe modules Object')\n  // this.PILLAR.p_wiLog(modules)\n  if (Object.keys(modules).length > 0) {\n    for (let mod in modules) {\n      //this.PILLAR.p_wiLog(modules[mod]);\n      if (mod === moduleId) {\n        this.modules[moduleId][modInstId] = module;\n      } else {\n        this.modules[moduleId] = {};\n        this.modules[moduleId][modInstId] = module;\n      }\n    } // End of for loop\n  } else {\n    this.modules[moduleId] = {};\n    this.modules[moduleId][modInstId] = module;\n  } // End of ifesleif test\n}; // End of store modules method\n// CORE.prototype.PROMPT = this.PILLAR.PROMPT\nCORE.prototype.events = function () {\n  const PILLAR = this.PILLAR;\n  //  const parent = this.parent\n  return {\n    addEventHandler: function (el, ev, handler) {\n      if (typeof window === \"undefined\") {\n        return PILLAR.ev_addHandler(el, ev, handler);\n      } else {\n        PILLAR.ev_addHandler(el, ev, handler);\n      }\n    },\n    removeEventHandler: function (el, ev, handler) {\n      PILLAR.ev_removeHandler(el, ev, handler);\n    },\n    getEvent: function (ev) {\n      return PILLAR.getEvent(ev);\n    },\n    getTarget: function (ev) {\n      return PILLAR.getTarget(ev);\n    },\n    preventNormal: function (ev) {\n      PILLAR.preventDefault(ev);\n    },\n    stopEventBubble: function (ev) {\n      PILLAR.stopPropagation(ev);\n    } // End of addEventHandler() method\n  };\n}; // End of CORE EVENTS manipulation object\nCORE.prototype.ajax = function () {\n  const PILLAR = this.PILLAR;\n  return {\n    get: function (url, data, success, failure, type) {\n      PILLAR.ajax_get(url, data, success, failure, type);\n    },\n    post: function (url, data, success, failure, type) {\n      PILLAR.ajax_post(url, data, success, failure, type);\n    } // End of ajax post() method\n  };\n}; // End of CORE AJAX manipulation object\nCORE.prototype.validators = function () {\n  const PILLAR = this.PILLAR;\n  return {\n    isFunction: function (x) {\n      return PILLAR.is_function(x);\n    },\n    isArray: function (x) {\n      return PILLAR.is_array(x);\n    },\n    isDate: function (x) {\n      return PILLAR.is_date(x);\n    },\n    isObject: function (x) {\n      return PILLAR.is_object(x);\n    },\n    isString: function (x) {\n      return PILLAR.is_string(x);\n    },\n    isValue: function (x) {\n      return PILLAR.is_value(x);\n    },\n    isNotFalsey: function (x) {\n      return PILLAR.is_not_falsey(x);\n    },\n    trimSpaces: function (x) {\n      return PILLAR.trim_spaces(x);\n    },\n    isEqualab: function (a, b, f = null) {\n      return PILLAR.is_equal_ab(a, b, f);\n    },\n    isSameValue: function (x, y) {\n      return PILLAR.is_same_value(x, y);\n    },\n    isValidEmail: function (e) {\n      return PILLAR.is_valid_email(e);\n    },\n    isValidPassword: function (p) {\n      return PILLAR.is_valid_password(p);\n    },\n    unlikeProps: function (a, b) {\n      return PILLAR.unlike_props(a, b);\n    },\n    contains: function (o, v) {\n      return PILLAR.contains(o, v);\n    },\n    forOf: function (o, action, no) {\n      return PILLAR.for_of(o, action, no);\n    },\n    addValuesTo: function (o, k, v) {\n      return PILLAR.add_values_to(o, k, v);\n    },\n    findIn: function (x, i, f) {\n      return PILLAR.find_in(x, i, f);\n    }\n  };\n};\nCORE.prototype.util = function () {\n  const PILLAR = this.PILLAR;\n  return {\n    makeDirs: function (p, isFileName, callback) {\n      return PILLAR.p_mkdirs(p, isFileName, callback);\n    },\n    mkdirsSync: function (abs, isFileName, callback) {\n      return PILLAR.p_mkdirs(abs, isFileName, callback);\n    },\n    getFiles: function (p, opts, callback) {\n      return PILLAR.p_getFiles(p, opts, callback);\n    },\n    getFile: function (f) {\n      return PILLAR.p_getFile(f);\n    },\n    getDirectories: function (p) {\n      return PILLAR.p_getDirectories(p);\n    },\n    getExtension: function (f, callback) {\n      return PILLAR.p_getExtension(f, callback);\n    },\n    generateUniqueID: function () {\n      return PILLAR.p_generateUniqueID();\n    },\n    unikify: function (a) {\n      return PILLAR.p_unikify(a);\n    },\n    capitalizeFirstLetter: function (text) {\n      return PILLAR.p_capitalizeFirstLetter(text);\n    },\n    capitalizeLastLetter: function (text) {\n      return PILLAR.p_capitalizeLastLetter(text);\n    },\n    camelCase: function (text) {\n      return PILLAR.p_camelCase(text);\n    },\n    getWorkingFolder: function () {\n      return PILLAR.p_getWorkingFolder();\n    },\n    makeFolderSync: function (absPath) {\n      return PILLAR.p_makeFolderSync(absPath);\n    },\n    createFolderContent: function (source, target, ignore = null) {\n      return PILLAR.p_createFolderContent(source, target, ignore);\n    },\n    loadFile: function (filepath) {\n      return PILLAR.p_loadFile(filepath);\n    },\n    loadFileSync: function (filepath) {\n      return PILLAR.p_loadFileSync(filepath);\n    },\n    readFileSync: function (filepath) {\n      return PILLAR.p_readFileSync(filepath);\n    },\n    saveToFile: function (saveTo, contents) {\n      return PILLAR.p_saveToFile(saveTo, contents);\n    },\n    getMainFileName: function () {\n      return PILLAR.p_getMainFileName();\n    },\n    getRootDir: function () {\n      return PILLAR.p_getRootDir();\n    },\n    isExistingDir: function (filepath) {\n      return PILLAR.p_isExistingDir(filepath);\n    },\n    wiLog: function (message = \"\") {\n      return PILLAR.p_wiLog(message);\n    }\n  };\n};\n/*\n\n    The methods immediately after this method will be used for module inter communication, which is\n    a way that modules communicate with each other indirectly.\n    \n\n*/\nCORE.prototype.registerEvents = function (evts = {}, module_id = \"\", mod_inst_id = \"\") {\n  // this.PILLAR.p_wiLog('THE REGISTER MODULES METHOD')\n  // this.PILLAR.p_wiLog(evts)\n  // this.PILLAR.p_wiLog(module_id,mod_inst_id)\n  if (evts && module_id && mod_inst_id) {\n    if (this.modules[module_id][mod_inst_id]) {\n      this.modules[module_id][mod_inst_id].events = evts;\n    }\n  }\n}; // End of registerEvents method\nCORE.prototype.triggerEvent = function (evt) {\n  if (evt) {\n    // this.PILLAR.p_wiLog('Event contains data')\n    for (let moduId in this.modules) {\n      // this.PILLAR.p_wiLog('Modules contains modules')\n      if (this.modules.hasOwnProperty(moduId)) {\n        // this.PILLAR.p_wiLog('given module belongs to modules object')\n        moduId = this.modules[moduId];\n        for (let modInst in moduId) {\n          // this.PILLAR.p_wiLog('Instances of a given moduleS')\n          // this.PILLAR.p_wiLog(moduId[modInst].events.type)\n          // this.PILLAR.p_wiLog(evt.type)\n          if (moduId[modInst].events && moduId[modInst].events[evt.type]) {\n            moduId[modInst].events[evt.type](evt.data);\n          } // End of inner if statement\n        }\n      }\n    } // End of for in statement\n  } // End of outer evt object check\n}; // End of triggerEvent method\nCORE.prototype.startModule = function (moduleId, modInstId) {\n  var moduleID = moduleId;\n  // this.PILLAR.p_wiLog('THE START MODULE')\n  // this.PILLAR.p_wiLog(moduleId)\n  if (this.modules[moduleID][modInstId]) {\n    if (moduleID !== \"anziiloger\") {\n      // this.PILLAR.p_wiLog('not A LOGGER MODULE')\n      // this.PILLAR.p_wiLog(this.modules[moduleID][modInstId].getClassName)\n      // this.PILLAR.p_wiLog(this.modules[moduleID][modInstId].getClassName())\n      //  this.modules['anziiloger']['anziiloger'].setDebugger(this.modules[moduleID][modInstId].constructor.name)\n      this.modules[\"anziiloger\"][\"anziiloger\"].setDebugger(this.modules[moduleID][modInstId].getClassName());\n      // this.modules['anziiloger']['anziiloger'].setDebugger(moduleID)\n    }\n    this.modules[moduleID][modInstId].init();\n    if (moduleID === \"global\") {\n      // this.PILLAR.p_wiLog('THE GLOBAL MODULES IS ABOUT TO RECEIVE MODULES')\n      // this.PILLAR.p_wiLog(Object.keys(this.modules))\n      this.modules[moduleID][modInstId].globals = Object.keys(this.modules);\n    }\n  }\n}; // End of startModule() core method\nCORE.prototype.startAllModules = function () {\n  for (let mod in this.modules) {\n    var modSuper = this.modules[mod];\n    for (let modInstId in modSuper) {\n      try {\n        this.modules[modSuper][modInstId].init();\n      } catch (e) {\n        // this.PILLAR.p_wiLog(e);\n      } // End of try catch\n    }\n  }\n}; // End of startAllModules() core method\nCORE.prototype.stopModule = function (moduleId, modInstId) {\n  var moduleID = moduleId;\n  if (this.modules[moduleID][modInstId]) {\n    this.modules[moduleID][modInstId].destroy();\n  }\n}; // End of stopModule() core method\nCORE.prototype.stopAllModules = function () {\n  for (let mod in this.modules) {\n    var modSuper = this.modules[mod];\n    for (let modInstId in modSuper) {\n      try {\n        this.modules[modSuper][modInstId].destroy();\n      } catch (e) {\n        // this.PILLAR.p_wiLog(e);\n      } // End of try catch\n    }\n  }\n}; // End of stopAllModules() core method\nCORE.prototype.converts = function () {\n  const PILLAR = this.PILLAR;\n  return {\n    jsToJson: function (jsObject) {\n      return PILLAR.js_to_json(jsObject);\n    },\n    jsonToJs: function (json) {\n      return PILLAR.json_to_js(json);\n    },\n    clone: function (c) {\n      return PILLAR.clone(c);\n    },\n    objectToArray: function (o = {}, key = false) {\n      return PILLAR.object_to_array(o, key);\n    },\n    stringToArray: function (str, sep) {\n      return PILLAR.string_to_array(str, sep);\n    }\n  };\n};\nCORE.prototype.sanna = function () {\n  const self = this;\n  return {\n    modules: {\n      validators: {\n        emit: function (comp) {\n          if (!comp.hasOwnProperty(\"emit\")) {\n            // this.PILLAR.p_wiLog(self.sanna().modules)\n            comp.emit = self.sanna().modules.addiks.emit.bind(comp);\n          } else if (typeof comp.emit !== \"function\") {\n            throw new Error(\"Emit is a reserved Akii method\");\n          }\n        },\n        listens: function (comp) {\n          // this.PILLAR.p_wiLog('THE COMPONENT RUNS')\n          if (!comp.hasOwnProperty(\"listens\")) {\n            // this.PILLAR.p_wiLog('THE LISTENS COMP PROP')\n            comp.listens = self.sanna().modules.addiks.listens.bind(comp);\n            // this.PILLAR.p_wiLog(comp)\n          } else if (typeof comp.listens !== \"function\") {\n            throw new Error(\"Listens is a reserved ANZii method\");\n          }\n        },\n        log: function (comp) {\n          comp.log = self.sanna().modules.addiks.log.bind(comp);\n        },\n        logSync: function (comp) {\n          comp.logSync = self.sanna().modules.addiks.logSync.bind(comp);\n        },\n        info: function (comp, name = \"\") {\n          if (name && name.toLowerCase() === \"anziiloger\") return;\n          comp.info = self.sanna().modules.addiks.info.bind(comp);\n        },\n        infoSync: function (comp) {\n          comp.infoSync = self.sanna().modules.addiks.infoSync.bind(comp);\n        },\n        debug: function (comp, name = \"\") {\n          if (name && name.toLowerCase() === \"anziiloger\") return;\n          comp.debug = self.sanna().modules.addiks.debug.bind(comp);\n        },\n        warn: function (comp, name = \"\") {\n          if (name && name.toLowerCase() === \"anziiloger\") return;\n          comp.warn = self.sanna().modules.addiks.warn.bind(comp);\n        },\n        error: function (comp, name = \"\") {\n          if (name && name.toLowerCase() === \"anziiloger\") return;\n          comp.error = self.sanna().modules.addiks.error.bind(comp);\n        },\n        adLog: function (comp) {\n          comp.adLog = self.sanna().modules.addiks.adLog.bind(comp);\n        },\n        wiLog: function (comp) {\n          comp.wiLog = self.sanna().modules.addiks.wiLog.bind(comp);\n        },\n        getClassName: function (comp) {\n          comp.getClassName = self.sanna().modules.addiks.getClassName.bind(comp);\n        },\n        query: function (comp) {\n          comp.query = self.sanna().modules.addiks.query.bind(comp);\n        }\n      },\n      addiks: {\n        emit: function (data) {\n          const pao = this.pao;\n          // self.log(self.constructor.name,'is emitting event:',data.type,'with data: ')\n          pao.pa_notifyEvent({\n            type: data.type,\n            data: data.data\n          });\n        },\n        listens: function (evehandles) {\n          const pao = this.pao;\n          // this.PILLAR.p_wiLog('THE VALUE OF SELF')\n          // this.PILLAR.p_wiLog(self)\n          // self.log('MODULE',self.getClassName(), 'listens to event(s):',evehandles)\n          // const mId = self.constructor.name.toLowerCase()\n          // const mInsId = self.constructor.name.toLowerCase()\n          const mId = pao.moduleMeta.moduleId;\n          const mInsId = pao.moduleMeta.modInstId;\n          // this.PILLAR.p_wiLog('LISTENS METHOD RECEIVED A CALL')\n          // this.PILLAR.p_wiLog(pao.moduleMeta)\n          // this.PILLAR.p_wiLog(pao.moduleMeta.modInstId)\n          // this.PILLAR.p_wiLog(mInsId)\n          pao.pa_notifyListen(evehandles, mId, mInsId);\n        },\n        log: function (message = \"No message provided\", type = \"console\") {\n          const self = this;\n          let data = {\n            message: message,\n            type: type\n          };\n          data.source = self.getClassName();\n          self.emit({\n            type: \"anziiloger-log\",\n            data: data\n          });\n        },\n        logSync: function (message = \"No message provided\", type = \"console\") {\n          const self = this;\n          let data = {\n            message: message,\n            type: type\n          };\n          data.source = self.getClassName();\n          data.sync = true;\n          self.emit({\n            type: \"anziiloger-log\",\n            data: data\n          });\n        },\n        info: function (message = \"No message provided\") {\n          const self = this;\n          let data = {\n            message: message,\n            type: \"info\"\n          };\n          data.source = self.getClassName();\n          self.emit({\n            type: \"anziiloger-log\",\n            data: data\n          });\n        },\n        infoSync: function (message = \"No message provided\") {\n          const self = this;\n          let data = {\n            message: message,\n            type: \"info\"\n          };\n          data.source = self.getClassName();\n          data.sync = true;\n          self.emit({\n            type: \"anziiloger-log\",\n            data: data\n          });\n        },\n        debug: function (message = \"No message provided\") {\n          const self = this;\n          let data = {\n            message: message,\n            type: \"debug\"\n          };\n          data.source = self.getClassName();\n          self.emit({\n            type: \"anziiloger-log\",\n            data: data\n          });\n        },\n        warn: function (message = \"No message provided\") {\n          const self = this;\n          let data = {\n            message: message,\n            type: \"warn\"\n          };\n          data.source = self.getClassName();\n          self.emit({\n            type: \"anziiloger-log\",\n            data: data\n          });\n        },\n        error: function (message = \"No message provided\") {\n          const self = this;\n          let data = {\n            message: message,\n            type: \"error\"\n          };\n          data.source = self.getClassName();\n          self.emit({\n            type: \"anziiloger-log\",\n            data: data\n          });\n        },\n        adLog: function (message = \"No message provided\") {\n          const self = this;\n          let data = {\n            message: message,\n            type: \"adLog\"\n          };\n          data.source = self.getClassName();\n          self.emit({\n            type: \"anziiloger-log\",\n            data: data\n          });\n        },\n        wiLog: function (message = \"No message provided\") {\n          const self = this;\n          let data = {\n            message: message,\n            type: \"wiLog\"\n          };\n          data.source = self.getClassName();\n          self.emit({\n            type: \"anziiloger-log\",\n            data: data\n          });\n        },\n        getClassName: function () {\n          const pao = this.pao;\n          // this.PILLAR.p_wiLog('GET CLASSNAME')\n          // this.PILLAR.p_wiLog(pao)\n          return pao.moduleMeta.className;\n        },\n        query: function (model = null, document = null, handler = null) {\n          const self = this;\n          const pao = self.pao;\n          if (!model || !document) {\n            throw new Error(\"Query method missing required parameters\");\n          } else {\n            let modelFrags = pao.pa_isString(model) ? pao.pa_stringToArray(model, \".\") : model;\n            // this.PILLAR.p_wiLog(pao.pa_stringToArray)\n            // this.PILLAR.p_wiLog(modelFrags)\n            if (modelFrags.length === 3) {\n              let mo = {\n                vendor: modelFrags[0],\n                table: modelFrags[1],\n                operation: modelFrags[2]\n              };\n              self.emit({\n                type: \"data-hive-request\",\n                data: {\n                  model: mo,\n                  document,\n                  handler\n                }\n              });\n            } else if (\n            // eslint-disable-next-line no-constant-condition\n            model[1].trim() === \"PROCEDURE\" || \"JOIN\" || 0 || 0 || 0 || 0 || 0 || 0) {\n              let mo = {\n                vendor: modelFrags[0],\n                table: modelFrags[1].toLowerCase(),\n                operation: modelFrags[1].toLowerCase()\n              };\n              self.emit({\n                type: \"data-hive-request\",\n                data: {\n                  model: mo,\n                  document,\n                  handler\n                }\n              });\n            } else {}\n          }\n        }\n      }\n    },\n    runForModules: function (comp, clname) {\n      let validators = this.modules.validators;\n      for (let v in validators) {\n        validators[v](comp, clname);\n      }\n    }\n  };\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CORE);\n\n//# sourceURL=webpack://anzii/./lib/base/core.js?");

/***/ }),

/***/ "./lib/base/pao.js":
/*!*************************!*\
  !*** ./lib/base/pao.js ***!
  \*************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction PAO(appPillar) {\n  this.core = appPillar;\n  this.PROMPT = appPillar.PROMPT;\n} // End of PAO\nPAO.prototype.create = function (moduleID, modInstId, className) {\n  const pa_core = this.core;\n  const PROMPT = this.PROMPT;\n  // const util = pa_core.util\n  // var events = pa_core.events()\n  // var ajax = pa_core.ajax()\n  // const validators = pa_core.validators()\n  const util = pa_core.validators().forOf(pa_core.util(), (p, a) => {\n    return {\n      p: [`pa_${p}`],\n      v: a\n    };\n  });\n  const converts = pa_core.validators().forOf(pa_core.converts(), (p, a) => {\n    return {\n      p: [`pa_${p}`],\n      v: a\n    };\n  });\n  const validators = pa_core.validators().forOf(pa_core.validators(), (p, a) => {\n    return {\n      p: [`pa_${p}`],\n      v: a\n    };\n  });\n  // util.pa_wiLog('THE VALIDATORS')\n  // util.pa_wiLog(validators)\n  // util.pa_wiLog('The value of Instance Id')\n  // util.pa_wiLog(modInstId)\n  if (modInstId) {\n    // util.pa_wiLog('The module has a view')\n    // var CONTAINER = dom.queryCont('data-'+moduleID, modInstId);\n    var meta = {\n      moduleId: moduleID,\n      modInstId: modInstId,\n      className: className\n    };\n  } else {\n    // util.pa_wiLog('The module has no view')\n    var meta = {\n      moduleId: moduleID,\n      modInstId: moduleID,\n      className: className\n    };\n  }\n  return {\n    // DOM manipulations\n    // view: CONTAINER,\n    moduleMeta: meta,\n    PROMPT: PROMPT,\n    ...util,\n    ...validators,\n    ...converts,\n    pa_notifyListen: function (evts = {}, moduleID = '', modInstId = '') {\n      // util.pa_wiLog('The notifyListen event has been successfuly invoked') \n      // util.pa_wiLog(evts) \n      // util.pa_wiLog(moduleID)\n      // util.pa_wiLog(modInstId)\n      pa_core.registerEvents(evts, moduleID, modInstId);\n    },\n    pa_notifyEvent: function (evt = {}) {\n      // util.pa_wiLog('The notify event has been successfuly invoked')\n      pa_core.triggerEvent(evt);\n    } // end of notifyEvent() occurence\n  }; // End OF return\n}; // End of PAO create() method\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PAO);\n\n//# sourceURL=webpack://anzii/./lib/base/pao.js?");

/***/ }),

/***/ "./lib/esm/anziiloger/anziiloger.js":
/*!******************************************!*\
  !*** ./lib/esm/anziiloger/anziiloger.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("var winston__WEBPACK_IMPORTED_MODULE_1___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ \"debug\");\n/* harmony import */ var winston__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! winston */ \"winston\");\n/* harmony import */ var _methods_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./methods.js */ \"./lib/esm/anziiloger/methods.js\");\n\n\n\nclass Anziiloger {\n  constructor(pao) {\n    this.pao = pao;\n    this.winlo = /*#__PURE__*/ (winston__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (winston__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(winston__WEBPACK_IMPORTED_MODULE_1__, 2)));\n    this.debugr = debug__WEBPACK_IMPORTED_MODULE_0__;\n    this.logger = {\n      true: true\n    };\n    this.debugas = {};\n    this.defaultTransports = [{\n      trans: \"File\",\n      level: \"info\",\n      handleExceptions: true,\n      json: true,\n      label: \"Anzilloger\",\n      maxsize: 5242880,\n      maxFiles: 5,\n      timestamp: true,\n      colorize: false\n    }, {\n      trans: \"Console\",\n      level: \"debug\",\n      handleExceptions: true,\n      json: false,\n      timestamp: true,\n      colorize: true\n    }];\n    this.init = _methods_js__WEBPACK_IMPORTED_MODULE_2__.init;\n    this.handleLogRequest = _methods_js__WEBPACK_IMPORTED_MODULE_2__.handleLogRequest;\n    this.handleAnziilogerConfig = _methods_js__WEBPACK_IMPORTED_MODULE_2__.handleAnziilogerConfig;\n    this.info = _methods_js__WEBPACK_IMPORTED_MODULE_2__.info;\n    this.warn = _methods_js__WEBPACK_IMPORTED_MODULE_2__.warn;\n    this.error = _methods_js__WEBPACK_IMPORTED_MODULE_2__.error;\n    this.debug = _methods_js__WEBPACK_IMPORTED_MODULE_2__.debug;\n    this.aLog = _methods_js__WEBPACK_IMPORTED_MODULE_2__.aLog;\n    this.iLog = _methods_js__WEBPACK_IMPORTED_MODULE_2__.iLog;\n    this.setDebugger = _methods_js__WEBPACK_IMPORTED_MODULE_2__.setDebugger;\n  }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Anziiloger);\n\n//# sourceURL=webpack://anzii/./lib/esm/anziiloger/anziiloger.js?");

/***/ }),

/***/ "./lib/esm/anziiloger/index.js":
/*!*************************************!*\
  !*** ./lib/esm/anziiloger/index.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _anziiloger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./anziiloger.js */ \"./lib/esm/anziiloger/anziiloger.js\");\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_anziiloger_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n//# sourceURL=webpack://anzii/./lib/esm/anziiloger/index.js?");

/***/ }),

/***/ "./lib/esm/anziiloger/methods.js":
/*!***************************************!*\
  !*** ./lib/esm/anziiloger/methods.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   aLog: () => (/* binding */ aLog),\n/* harmony export */   debug: () => (/* binding */ debug),\n/* harmony export */   error: () => (/* binding */ error),\n/* harmony export */   handleAnziilogerConfig: () => (/* binding */ handleAnziilogerConfig),\n/* harmony export */   handleLogRequest: () => (/* binding */ handleLogRequest),\n/* harmony export */   iLog: () => (/* binding */ iLog),\n/* harmony export */   info: () => (/* binding */ info),\n/* harmony export */   init: () => (/* binding */ init),\n/* harmony export */   setDebugger: () => (/* binding */ setDebugger),\n/* harmony export */   warn: () => (/* binding */ warn)\n/* harmony export */ });\n/* eslint-disable no-unused-vars */\nconst init = function () {\n  this.setDebugger(this.constructor.name);\n  //   this.handleAnziilogerConfig()\n  //this.aLog({message: 'Anziilger has been initialised'})\n  this.listens({\n    \"config-anziiloger\": this.handleAnziilogerConfig.bind(this),\n    \"anziiloger-log\": this.handleLogRequest.bind(this)\n  });\n};\nconst handleLogRequest = function (data) {\n  const self = this;\n  const pao = self.pao;\n  const cliLogsSet = process.env.ANZII_SHOW_CLI_LOGS || \"false\";\n  const shouldShowCliLogs = cliLogsSet === \"true\" ? true : false;\n  // self.pao.pa_wiLog('HANDLELOGREQUEST')\n  // self.pao.pa_wiLog(data)\n  // self.pao.pa_wiLog(data.source)\n  if (pao.PROMPT.indexOf(\"cli\") >= 0 && shouldShowCliLogs === false) return;\n  if (self.logger) {\n    switch (data.type) {\n      case \"info\":\n        self.info(data);\n        break;\n      case \"warn\":\n        self.warn(data);\n        break;\n      case \"error\":\n        self.error(data);\n        break;\n      case \"adLog\":\n        self.aLog(data);\n        break;\n      case \"wiLog\":\n        self.iLog(data);\n        break;\n      default:\n        self.debug(data);\n    }\n  } else {\n    console.log(data.source, \"logged message: \", data.message, \" of type \", data.type);\n  }\n};\nconst handleAnziilogerConfig = function (data) {\n  const self = this;\n  // self.pao.pa_wiLog('THE DEUGAS')\n  // self.pao.pa_wiLog(self.debugas)\n  const pao = self.pao;\n  // self.logger = data\n  // self.info({message: \"Anzii is configuring logger\",sync: true,source: 'Anziiloger'})\n  // self.pao.pa_wiLog('ANZII LOGGER IS CATCHING AN EVENT FROM CONFIG')\n  // self.pao.pa_wiLog(data)\n  // data.hasOwnProperty('transports')\n  //   ? pao.pa_isArray(data.transports)\n  // \t ? self.defaultTransports.concat(data.transports)\n  // \t : console.log('Config: invalid def..  ')\n  //   :''\n  let now = new Date();\n  self.logger = new self.winlo.createLogger({\n    transports: [\n    // new  self.winlo.transports.File(\n    // \t{\n    // \tname: 'production',\n    // \tlevel: 'info',\n    // \tfilename: './logs/production.log',\n    // \thandleExceptions: true,\n    // \tjson: true,\n    // \tlabel: 'Anzilloger',\n    // \tmaxsize: 5242880,\n    // \tmaxFiles: 5,\n    // \ttimestamp: now,\n    // \tcolorize: false}\n    // ),\n    // new  self.winlo.transports.File(\n    // \t{\n    // \tname: 'errors',\n    // \tlevel: 'error',\n    // \tfilename: './logs/errors.log',\n    // \thandleExceptions: true,\n    // \tjson: true,\n    // \tlabel: 'Anzilloger',\n    // \tmaxsize: 5242880,\n    // \tmaxFiles: 5,\n    // \ttimestamp: true,\n    // \tcolorize: false}\n    // ),\n    new self.winlo.transports.Console({\n      level: \"debug\",\n      label: \"Anzilloger\",\n      timestamp: true,\n      colorize: true\n    }), new self.winlo.transports.Console({\n      level: \"info\",\n      label: \"Anzilloger\",\n      timestamp: true,\n      colorize: true\n    }), new self.winlo.transports.Console({\n      level: \"warn\",\n      label: \"Anzilloger\",\n      timestamp: true,\n      colorize: true\n    }), new self.winlo.transports.Console({\n      level: \"error\",\n      label: \"Anzilloger\",\n      timestamp: true,\n      colorize: true\n    })]\n  });\n};\nconst info = async function (log) {\n  const self = this;\n  const pao = self.pao;\n  const contains = pao.pa_contains;\n  // if(contains(log,'sync')){\n  // \tawait self.logger.info(`${log.source}: ${log.message}`)\n  // }else{\n  // \tself.logger.info(`${log.source}: ${log.message}`)\n  // }\n  if (contains(log, \"sync\")) {\n    if (self.debugas.hasOwnProperty(log.source.toLowerCase())) {\n      // self.pao.pa_wiLog('THE DEBUG MODULE IS USED')\n      // self.pao.pa_wiLog(self.debugas)\n      self.iLog({\n        message: \"Logging info sync with debugas\"\n      });\n      self.iLog({\n        message: log.message\n      });\n      self.iLog({\n        message: self.debugas[log.source.toLowerCase()]\n      });\n      !self.debugas[log.source.toLowerCase()].useColors ? self.debugas[log.source.toLowerCase()].useColors = true : \"\";\n      !self.debugas[log.source.toLowerCase()].enabled && \"development\"?.toLowerCase() === \"production\" ? self.debugas[log.source.toLowerCase()].enabled = true : \"\";\n      await self.debugas[log.source.toLowerCase()](log.message);\n    } else {\n      try {\n        self.iLog({\n          message: \"Logging info sync\"\n        });\n        self.iLog({\n          message: log.source\n        });\n        self.iLog({\n          message: log.message\n        });\n        await self.logger.debug(`${log.source}: ${log.message}`);\n      } catch (e) {\n        self.iLog({\n          message: \"Logging info::WITH ERROR\"\n        });\n        // self.iLog(e)\n        console.log(e);\n      }\n    }\n  } else {\n    if (self.debugas.hasOwnProperty(log.source.toLowerCase())) {\n      // self.pao.pa_wiLog('THE DEBUG MODULE IS USED')\n      // self.pao.pa_wiLog(self.debugas)\n      // console.log('debugs has property',log.source)\n      self.iLog({\n        message: \"Logging info sync with debugas::NONESYNC\"\n      });\n      self.iLog({\n        message: self.debugas[log.source.toLowerCase()]\n      });\n      !self.debugas[log.source.toLowerCase()].useColors ? self.debugas[log.source.toLowerCase()].useColors = true : \"\";\n      self.debugas[log.source.toLowerCase()](log.message);\n    } else {\n      try {\n        self.iLog({\n          message: \"Logging info sync::noneSync\"\n        });\n        self.iLog({\n          message: log.source\n        });\n        self.logger.debug(`${log.source}: ${log.message}`);\n      } catch (e) {\n        self.iLog({\n          message: \"Logging infoNONESYNC::WITH ERROR\"\n        });\n        console.log(e);\n      }\n      // self.logger.debug(`${log.source}: ${log.message}`)\n    }\n  }\n  // if(self.debugas.hasOwnProperty(log.source.toLowerCase())){\n  // \t// self.pao.pa_wiLog('THE DEBUG MODULE IS USED')\n  // \t// self.pao.pa_wiLog(self.debugas)\n  // \tawait self.debugas[log.source.toLowerCase()](log.message)\n  // }else{\n  // \tawait self.logger.info(`${log.source}: ${log.message}`)\n  // }\n  // self.log('THE INFO METHOD RECEIVES A CALL')\n  // self.log(log)\n};\nconst debug = async function (log) {\n  const self = this;\n  const pao = self.pao;\n  const contains = pao.pa_contains;\n  if (contains(log, \"sync\")) {\n    if (self.debugas.hasOwnProperty(log.source.toLowerCase())) {\n      // self.pao.pa_wiLog('THE DEBUG MODULE IS USED')\n      // self.pao.pa_wiLog(self.debugas)\n      !self.debugas[log.source.toLowerCase()].useColors ? self.debugas[log.source.toLowerCase()].useColors = true : \"\";\n      await self.debugas[log.source.toLowerCase()](log.message);\n    } else {\n      await self.logger.debug(`${log.source}: ${log.message}`);\n    }\n  } else {\n    if (self.debugas.hasOwnProperty(log.source.toLowerCase())) {\n      // self.pao.pa_wiLog('THE DEBUG MODULE IS USED')\n      // self.pao.pa_wiLog(self.debugas)\n      !self.debugas[log.source.toLowerCase()].useColors ? self.debugas[log.source.toLowerCase()].useColors = true : \"\";\n      self.debugas[log.source.toLowerCase()](log.message);\n    } else {\n      self.logger.debug(`${log.source}: ${log.message}`);\n    }\n  }\n};\nconst warn = async function (log) {\n  //const self = this\n  //self.logger.warn(`${log.source}: ${log.message}`)\n  const self = this;\n  const pao = self.pao;\n  const contains = pao.pa_contains;\n  // if(contains(log,'sync')){\n  // \tawait self.logger.warn(`${log.source}: ${log.message}`)\n  // }else{\n  // \tself.logger.warn(`${log.source}: ${log.message}`)\n  // }\n  if (contains(log, \"sync\")) {\n    if (self.debugas.hasOwnProperty(log.source.toLowerCase())) {\n      // self.pao.pa_wiLog('THE DEBUG MODULE IS USED')\n      // self.pao.pa_wiLog(self.debugas)\n      self.iLog({\n        message: \"Logging warn sync with debugas\"\n      });\n      self.iLog(self.debugas[log.source.toLowerCase()]);\n      !self.debugas[log.source.toLowerCase()].useColors ? self.debugas[log.source.toLowerCase()].useColors = true : \"\";\n      await self.debugas[log.source.toLowerCase()](log.message);\n    } else {\n      self.iLog({\n        message: \"Logging warn sync\"\n      });\n      self.iLog({\n        message: log.source\n      });\n      await self.logger.warn(`${log.source}: ${log.message}`);\n    }\n  } else {\n    if (self.debugas.hasOwnProperty(log.source.toLowerCase())) {\n      // self.pao.pa_wiLog('THE DEBUG MODULE IS USED'})\n      // self.pao.pa_wiLog(self.debugas)\n      self.iLog({\n        message: \"Logging warn sync with debugas:NONESYNC\"\n      });\n      self.iLog({\n        message: self.debugas[log.source.toLowerCase()]\n      });\n      !self.debugas[log.source.toLowerCase()].useColors ? self.debugas[log.source.toLowerCase()].useColors = true : \"\";\n      self.debugas[log.source.toLowerCase()](log.message);\n    } else {\n      self.iLog({\n        message: \"Logging warn NONESYNC\"\n      });\n      self.iLog({\n        message: log.source\n      });\n      self.logger.warn(`${log.source}: ${log.message}`);\n    }\n  }\n};\nconst error = async function (log) {\n  //const self = this\n  //self.logger.error(`${log.source}: ${log.message}`)\n  const self = this;\n  const pao = self.pao;\n  const contains = pao.pa_contains;\n  if (contains(log, \"sync\")) {\n    await self.logger.error(`${log.source}: ${log.message}`);\n  } else {\n    self.logger.error(`${log.source}: ${log.message}`);\n  }\n};\nconst aLog = async function (log) {\n  const self = this;\n  //self.logger.error(`${log.source}: ${log.message}`)\n  // self.pao.pa_wiLog(process.env)\n  // if(process.env.ANZII_SHOW_DEBUG_LOGS && process.env.ANZII_SHOW_DEBUG_LOGS.trim().toLowerCase() === 'true') console.log(log.message)\n  if (!process.env.ANZII_SHOW_DEBUG_LOGS) return;\n  if (process.env.ANZII_SHOW_DEBUG_LOGS.trim().toLowerCase() !== \"true\") return;\n  self.pao.pa_wiLog(\"aLog:ANZIILOGER\");\n  self.pao.pa_wiLog(process.env.ANZII_SHOW_DEBUG_LOGS);\n  console.log(log.message);\n  // const self = this\n  // const pao = self.pao\n  // const contains = pao.pa_contains\n};\nconst iLog = async function (log) {\n  const self = this;\n  //self.logger.error(`${log.source}: ${log.message}`)\n  // self.pao.pa_wiLog(process.env)\n  // if(process.env.ANZII_SHOW_DEBUG_LOGS && process.env.ANZII_SHOW_DEBUG_LOGS.trim().toLowerCase() === 'true') console.log(log.message)\n  if (!process.env.SHOW_ANZII_WI_LOGS) return;\n  if (process.env.SHOW_ANZII_WI_LOGS.trim().toLowerCase() !== \"true\") return;\n  self.pao.pa_wiLog(\"iLog:ANZIILOGER\");\n  self.pao.pa_wiLog(process.env.SHOW_ANZII_WI_LOGS);\n  console.log(log.message);\n  // const self = this\n  // const pao = self.pao\n  // const contains = pao.pa_contains\n};\nconst setDebugger = async function (mod) {\n  const self = this;\n  let name = mod.toLowerCase();\n  //console.log(\"THE DEBUGR\",name)\n  // process.exit(1)\n  // self.pao.pa_wiLog('THE CURRETN MODULE IN ANZILOGGER')\n  // self.pao.pa_wiLog(mod)\n  self.debugas[name] = self.debugr(`anzii:${name}`);\n};\n\n//# sourceURL=webpack://anzii/./lib/esm/anziiloger/methods.js?");

/***/ }),

/***/ "./lib/esm/config/config.js":
/*!**********************************!*\
  !*** ./lib/esm/config/config.js ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! config */ \"config\");\n/* harmony import */ var supports_color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! supports-color */ \"supports-color\");\n/* harmony import */ var _methods_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./methods.js */ \"./lib/esm/config/methods.js\");\n\n\n\n// const path = require('path') \n// const fs = require('fs')\nlet config = null;\n// try {\n//   // const conif = fs.readFileSync(`${process.cwd()}${path.sep}.config.js`,'utf-8') \n//   const filename = `${process.cwd()}${path.sep}.config.js`\n//   // config = conif.default\n//   // console.log('Config file has been successfully required')\n//   // console.log(conif.replace(/^uFEFF/,''))\n//   const jsO = require('/.config.js') \n//   // console.log(jsO)\n//   // console.log('Config file has been successfully required')\n// } catch (error) {\n//   // console.log('No configuration file has been configured') \n//   // console.log(error)\n//   config = null\n// }\n// const config = require('/confy').default\n// import config from '/confy'\n// console.log('THE CONFIG IN CONFIG')\n// console.log(config)\n// Dependecies \nif (!process.env.SUPPRESS_NO_CONFIG_WARNING) process.env.SUPPRESS_NO_CONFIG_WARNING = \"false\";\nclass Config {\n  constructor(pao) {\n    this.pao = pao;\n    this.config = config;\n    this.envObserver = config__WEBPACK_IMPORTED_MODULE_0__;\n    this.supportsColor = supports_color__WEBPACK_IMPORTED_MODULE_1__;\n    this.env = 'development';\n    this.aliases = {\n      development: 'dev',\n      production: 'prod',\n      staging: 'stage'\n    };\n    this.init = _methods_js__WEBPACK_IMPORTED_MODULE_2__.init;\n    this.setLogNamespaces = _methods_js__WEBPACK_IMPORTED_MODULE_2__.setLogNamespaces;\n    this.getConfigFile = _methods_js__WEBPACK_IMPORTED_MODULE_2__.getConfigFile;\n    this.configure = _methods_js__WEBPACK_IMPORTED_MODULE_2__.configure;\n    this.enviroment = _methods_js__WEBPACK_IMPORTED_MODULE_2__.enviroment;\n    this.handleManualConfig = _methods_js__WEBPACK_IMPORTED_MODULE_2__.handleManualConfig;\n    this.runAppConfig = _methods_js__WEBPACK_IMPORTED_MODULE_2__.runAppConfig;\n    this.configLogger = _methods_js__WEBPACK_IMPORTED_MODULE_2__.configLogger;\n    this.doBefore = _methods_js__WEBPACK_IMPORTED_MODULE_2__.doBefore;\n    this.mergeConfigs = _methods_js__WEBPACK_IMPORTED_MODULE_2__.mergeConfigs;\n  }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Config);\n\n//# sourceURL=webpack://anzii/./lib/esm/config/config.js?");

/***/ }),

/***/ "./lib/esm/config/index.js":
/*!*********************************!*\
  !*** ./lib/esm/config/index.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config.js */ \"./lib/esm/config/config.js\");\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_config_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n//# sourceURL=webpack://anzii/./lib/esm/config/index.js?");

/***/ }),

/***/ "./lib/esm/config/methods.js":
/*!***********************************!*\
  !*** ./lib/esm/config/methods.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   configLogger: () => (/* binding */ configLogger),\n/* harmony export */   configure: () => (/* binding */ configure),\n/* harmony export */   doBefore: () => (/* binding */ doBefore),\n/* harmony export */   enviroment: () => (/* binding */ enviroment),\n/* harmony export */   getConfigFile: () => (/* binding */ getConfigFile),\n/* harmony export */   handleManualConfig: () => (/* binding */ handleManualConfig),\n/* harmony export */   init: () => (/* binding */ init),\n/* harmony export */   mergeConfigs: () => (/* binding */ mergeConfigs),\n/* harmony export */   runAppConfig: () => (/* binding */ runAppConfig),\n/* harmony export */   setLogNamespaces: () => (/* binding */ setLogNamespaces)\n/* harmony export */ });\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ \"path\");\n/* eslint-disable no-mixed-spaces-and-tabs */\n\nconst init = function () {\n  this.adLog(\"Config has been initialised\");\n  this.setLogNamespaces();\n  this.getConfigFile().then(resolvedValue => {\n    this.adLog(`THE resolved ${resolvedValue}`);\n    this.doBefore();\n  });\n  this.listens({\n    \"config-manual\": this.handleManualConfig.bind(this)\n  });\n};\nconst setLogNamespaces = function () {\n  let defaultDebugNamespaces = \"anzii:system,anzii:server, anzii:request,anzii:router,anzii:server \";\n  if (!process.env.Debug) return process.env.Debug = defaultDebugNamespaces;\n};\nconst getConfigFile = function () {\n  const self = this;\n  const pao = self.pao;\n  const loadFile = pao.pa_loadFile;\n\n  //const testFile = require(\"/Users/surprisemashele/Documents/Development/frameworks/test.jsx\")\n  //const testFile = require(\"../../../../test.jsx\")\n  // const testFile = require(\"./test.jsx\")\n  //console.log(\"Got file\", testFile)\n\n  return new Promise(resolve => {\n    loadFile(path__WEBPACK_IMPORTED_MODULE_0__.resolve(\"./\", \".config.js\")).then(foundFile => {\n      self.pao.pa_wiLog(`Console.log fOUNDfiLE, ${JSON.stringify(foundFile)}`);\n      self.config = foundFile;\n      resolve(true);\n    }).catch(err => {\n      self.pao.pa_wiLog(`The Call Is NOT FOUND\", ${JSON.stringify(err)}`);\n      self.config = null;\n      resolve(true);\n    });\n  });\n\n  // try {\n  // \tconsole.log(\"FileToLoad\",await loadFile(path.resolve('./',\".config.js\")))\n  //     self.config = await loadFile(path.resolve('./',\".config.js\")).default\n  // \tconsole.log(\"readFile\",self.config)\n  //     // console.log(self.config)\n  // }\n  // catch (error) {\n  //      console.log('THE .CONFIG ERROR')\n  //     console.log(error)\n  //     self.warn('THE .config.js CONFIGURATION_FILE_WAS_NOT_FOUND_IN_THE_ROOT');\n  //     self.warn('Anzii will use defaults');\n  //     self.config = null;\n  // }\n};\nconst configure = function () {\n  const self = this;\n  const pao = self.pao;\n  // console.log(\".ENV\",process.env)\n  // let config = self.config\n  const isAppCli = pao.PROMPT.indexOf(\"cli\") >= 0 ? true : false;\n  const anziiCliWithServer = process.env?.ANZII_CLI_WITH_SERVER || null;\n  const isAnziiCliWithServer = anziiCliWithServer && anziiCliWithServer === \"true\" ? true : false;\n  const initializeCliWithServer = isAppCli && isAnziiCliWithServer;\n  self.pao.pa_wiLog(`THE CONFIG IS APP CLI: ${isAppCli}`);\n  self.pao.pa_wiLog(`THE CONFIG initi ${initializeCliWithServer}`);\n  if (initializeCliWithServer) return self.configLogger();\n  self.configLogger();\n  self.runAppConfig();\n};\nconst enviroment = function () {\n  const self = this;\n  let envObserver = self.envObserver;\n  // let supportsColor = self.supportsColor\n  // self.pao.pa_wiLog('THE CURRENT ENVIROMENT')\n  // self.pao.pa_wiLog(envObserver)\n  // if (supportsColor.stdout) {\n  // \tself.pao.pa_wiLog('Terminal stdout supports color');\n  // }\n  // if (supportsColor.stdout.has256) {\n  // \tself.pao.pa_wiLog('Terminal stdout supports 256 colors');\n  // }\n  // if (supportsColor.stderr.has16m) {\n  // \tself.pao.pa_wiLog('Terminal stderr supports 16 million colors (truecolor)')\n  // }\n  if (self.envObserver.has(\"enviroment\")) {\n    if (self.aliases[envObserver?.enviroment]) {\n      self.env = self.aliases[envObserver.enviroment];\n      let envCofig = envObserver.get(self.env);\n      if (envCofig?.database) {\n        let clients = [];\n        let db = envCofig.database;\n        // self.pao.pa_wiLog('THE DB')\n        // self.pao.pa_wiLog(db)\n        for (let c in db) {\n          // self.pao.pa_wiLog('THE VALUE Of C')\n          // self.pao.pa_wiLog(c)\n          // self.pao.pa_wiLog(db[c])\n          clients.push({\n            name: c,\n            connect: db[c].connect\n          });\n        }\n        // self.pao.pa_wiLog('THE DATABASE CLIENTS')\n        // self.pao.pa_wiLog(clients)\n        self.emit({\n          type: `config-dman`,\n          data: {\n            clients: clients\n          }\n        });\n        self.emit({\n          type: `config-backupr`,\n          data: {\n            clients: clients\n          }\n        });\n      }\n      if (envObserver.has(\"appOrphic\")) {\n        // self.pao.pa_wiLog('THE JWT appOrphic')\n        // self.pao.pa_wiLog(envObserver)\n        // self.pao.pa_wiLog(envObserver.appOrphic)\n        // self.pao.pa_wiLog(envObserver.appOrphic.flaDev)\n        self.emit({\n          type: \"save-jwt-key\",\n          data: {\n            key: envObserver.appOrphic[\"flaDev\"]\n          }\n        });\n      } else {\n        self.emit({\n          type: \"save-jwt-key\",\n          data: {\n            key: \"f124sfet48tq3dfmlvoszx1\"\n          }\n        });\n      }\n    } else {\n      self.log(\"Enviroment config invalid, resorting to default\", \"warn\");\n    }\n  }\n  // let db = self.envObserver.get('dev')\n  // self.pao.pa_wiLog(db)\n  // self.pao.pa_wiLog(db.database.mysql.connect.user)\n};\nconst handleManualConfig = function (data = null) {\n  const self = this;\n  self.pao.pa_wiLog.log(`MANUAL SERVER TRIGGER ACTIVATED,\n\t\t${data?.payload?.configs}`);\n  // if()\n  self.runAppConfig(data);\n};\nconst runAppConfig = function (manualConfig = null) {\n  const self = this;\n  let config = null;\n  let isServerConfig = false;\n  if (!manualConfig) {\n    config = self.config;\n  } else {\n    config = manualConfig?.payload?.configs ? self.mergeConfigs(manualConfig?.payload?.configs) : self.config;\n    let {\n      payload\n    } = manualConfig;\n    let {\n      compiler,\n      wepackMiddlewares,\n      webpackConfig\n    } = payload;\n    const {\n      webpackDevMiddleware,\n      webpackHotMiddleware\n    } = wepackMiddlewares;\n    self.pao.pa_wiLog(\"THE CONFIG\");\n    self.pao.pa_wiLog(JSON.stringify(config));\n    self.pao.pa_wiLog(`runAPPcoNFIG\", ${JSON.stringify(manualConfig)}`);\n    self.pao.pa_wiLog(`THE APP CONFIG\", ${JSON.stringify(self.config)}`);\n    self.pao.pa_wiLog(`THE COMPILEr\", ${manualConfig?.payload?.webpackConfig}`);\n\n    /* The code immediately after this comment should be re-organized \n        it's just using a quick dirty approach to test some logic\n      */\n\n    self.config[\"middleware\"] = {\n      ppublic: {\n        addMiddleware: [{\n          type: \"function\",\n          value: webpackDevMiddleware(compiler, {\n            publicPath: webpackConfig.output.path,\n            writeToDisk: true,\n            serverSideRender: true\n          })\n        }\n        // {\n        //     type:\"function\",\n        //     value: webpackHotMiddleware(compiler,{\n        //         log: true,\n        //         path: \"/__kotii\",\n        //         heartbeat: 2000\n        //     })\n\n        // }\n        ]\n      },\n      all: {\n        addMiddleware: [{\n          type: \"function\",\n          value: webpackHotMiddleware(compiler, {\n            log: console.log,\n            path: \"/__kotii\",\n            heartbeat: 2000\n          }),\n          extra: \"hotModule\"\n        }]\n      }\n    };\n  }\n\n  //if (dumain.name === \"webpackDevMiddleware\")\n  //     return data.app.use(dumain.use(data.custom.compiler, {\n  //         publicPath: data.custom.webpackConfig.output.path,\n  //         writeToDisk: true\n  //     }));\n  // if (dumain.name === \"webpackHotMiddleware\")\n  //     return data.app.use(dumain.use(data.custom.compiler));\n\n  // self.pao.pa_wiLog('THE VALUE OF CONFIG SELF.CONFIG')\n  // self.pao.pa_wiLog(self.config)\n  if (!self.config) {\n    self.emit({\n      type: \"config-system\",\n      data: {\n        workers: 1,\n        spawn: true\n      }\n    });\n    // if (manualConfig)\n    //     self.emit({ type: 'config-domain-resources', data: manualConfig });// To be re-organized\n    if (manualConfig) self.emit({\n      type: \"config-domain-resources\",\n      data: null\n    });\n    self.emit({\n      type: `config-server`,\n      data: `server`\n    });\n    return;\n  }\n  if (self.config) {\n    self.enviroment();\n    self.config?.cluster ? self.emit({\n      type: \"config-system\",\n      data: self.config.cluster\n    }) : self.emit({\n      type: \"config-system\",\n      data: {\n        workers: 1,\n        spawn: true\n      }\n    });\n    for (let c in config) {\n      self.pao.pa_wiLog(`THE C IN CONFIG\", ${c}`);\n      self.pao.pa_wiLog(\"The module in Config\");\n      self.pao.pa_wiLog(c);\n      if (c === \"server\") isServerConfig = true;\n      c === \"router\" ? config.views ? (self.emit({\n        type: \"config-request\",\n        data: config[c]\n      }), self.emit({\n        type: \"config-view\",\n        data: {\n          routes: config[c],\n          handlers: config.views\n        }\n      })) : (self.emit({\n        type: \"config-request\",\n        data: config[c]\n      }), self.emit({\n        type: \"config-view\",\n        data: config[c]\n      })) : \"\";\n      if (c !== \"logger\" || c !== \"views\") {\n        self.emit({\n          type: `config-${c}`,\n          data: config[c]\n        });\n        // c === 'domain'\n        //     ? (self.emit({ type: 'config-domain-resources', data: manualConfig ? manualConfig : null }))\n        //     : '';\n      }\n    }\n    self.emit({\n      type: \"config-domain-resources\",\n      data: null\n    }); // to be re-organized\n    self.pao.pa_wiLog(`isServer Value\", ${isServerConfig}`);\n    // if (!isServerConfig) {\n\n    // \tself.emit({\n    // \t\ttype: `config-server`,\n    // \t\tdata: `server`,\n    // \t}); // TO be re-organized\n    // }\n  }\n\n  // const theWatcher = manualConfig?.payload?.compiler.watch(\n  //  {\n  //     // Example\n  //     aggregateTimeout: 300,\n  //     poll: undefined,\n  //   },\n  //   (err, stats)=>{\n\n  //     console.log(\"THE WEBPACK HAS BEEN MANUALLY TRIGGERED\",err)\n  //     console.log(\"THE STATS\",stats.asserts)\n  // })\n  // process.on(\"beforeExit\",()=>{\n  //     theWatcher.close((rr)=>{\n  //         console.log(\"THE WEBPACK WATCHER HAS BEEN CLOSES\",rr)\n  //     })\n  // })\n};\nconst configLogger = function () {\n  const self = this;\n  if (self.config?.logger) {\n    // self.pao.pa_wiLog('THE LOGGER IS THE FIRST MODULE TO GET CONFIG')\n    self.emit({\n      type: `config-anziiloger`,\n      data: self.config.logger\n    });\n  } else {\n    self.emit({\n      type: `config-anziiloger`,\n      data: {\n        level: \"info\"\n      }\n    });\n  }\n};\nconst doBefore = function () {\n  const self = this;\n  const pao = self.pao;\n  const loadFile = pao.pa_loadFile;\n  loadFile(path__WEBPACK_IMPORTED_MODULE_0__.resolve(\"./\", \"package.json\")).then(foundFile => {\n    let packageJSON = foundFile;\n    self.pao.pa_wiLog(`THE package.json\", ${JSON.stringify(packageJSON)}`);\n    self.configure();\n  }).catch(err => {\n    self.pao.pa_wiLog(`No pACKAGE.JSON WAS FOUND\", ${JSON.stringify(err)}`);\n    self.configure();\n  });\n  // console.log(\"DoBefore in action\")\n  // const packageJSON =  fs.readFileSync('./package.json');\n  // console.log(\"The package.json\",packageJSON)\n  // self.configure()\n};\nconst mergeConfigs = function (configToMerge) {\n  const self = this;\n  let config = self.config ? self.config : null;\n  if (!config) return self.config = configToMerge;\n  for (let confiItem in configToMerge) {\n    if (self.config[confiItem]) {\n      if (self.config[confiItem] instanceof Array) {\n        self.config[confiItem] = [...self.config[confiItem], ...configToMerge[confiItem]];\n      } else {\n        self.config[confiItem] = {\n          ...self.config[confiItem],\n          ...configToMerge[confiItem]\n        };\n      }\n    }\n  }\n};\n\n//# sourceURL=webpack://anzii/./lib/esm/config/methods.js?");

/***/ }),

/***/ "./lib/esm/dao/dao.js":
/*!****************************!*\
  !*** ./lib/esm/dao/dao.js ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _methods_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./methods.js */ \"./lib/esm/dao/methods.js\");\n\nclass Dao {\n  constructor(pao) {\n    this.pao = pao;\n    this.DBS = null;\n    this.connectors = null;\n    this.init = _methods_js__WEBPACK_IMPORTED_MODULE_0__.init;\n    this.handleDataHiveRequest = _methods_js__WEBPACK_IMPORTED_MODULE_0__.handleDataHiveRequest;\n    this.handleDaoTakeDbs = _methods_js__WEBPACK_IMPORTED_MODULE_0__.handleDaoTakeDbs;\n  }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Dao);\n\n//# sourceURL=webpack://anzii/./lib/esm/dao/dao.js?");

/***/ }),

/***/ "./lib/esm/dao/index.js":
/*!******************************!*\
  !*** ./lib/esm/dao/index.js ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _dao_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dao.js */ \"./lib/esm/dao/dao.js\");\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_dao_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n//# sourceURL=webpack://anzii/./lib/esm/dao/index.js?");

/***/ }),

/***/ "./lib/esm/dao/methods.js":
/*!********************************!*\
  !*** ./lib/esm/dao/methods.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   handleDaoTakeDbs: () => (/* binding */ handleDaoTakeDbs),\n/* harmony export */   handleDataHiveRequest: () => (/* binding */ handleDataHiveRequest),\n/* harmony export */   init: () => (/* binding */ init)\n/* harmony export */ });\nconst init = function () {\n  this.adLog(\"Dao has been initialised\");\n  this.listens({\n    \"dao-take-dbs\": this.handleDaoTakeDbs.bind(this),\n    \"data-hive-request\": this.handleDataHiveRequest.bind(this)\n  });\n};\nconst handleDataHiveRequest = function (data) {\n  const self = this;\n  const pao = self.pao;\n  self.adLog(\"DAO\");\n  self.adLog(data);\n  if (!self.DBS) throw new Error(\"No database vendor configured\");\n  if (!pao.pa_contains(self.DBS, data.model.vendor)) {\n    throw new Error(\"Specified database client is unknown\");\n  } else {\n    let model = data.model;\n    self.emit({\n      type: `${model.vendor}-data-request`,\n      data: {\n        conn: self.DBS[model.vendor],\n        connector: self.connectors[model.vendor],\n        table: model.table,\n        opi: model.operation,\n        query: data.document,\n        outComehandler: data.handler\n      }\n    });\n  }\n};\nconst handleDaoTakeDbs = function (data) {\n  const self = this;\n  self.pao.pa_wiLog(\"Handling Hive Request\");\n  if (self.DBS === null) {\n    self.DBS = {};\n    self.connectors = {};\n    self.DBS[data.vendor] = data.conn;\n    self.connectors[data.vendor] = data.connector;\n  } else {\n    self.DBS[data.vendor] = data.conn;\n    self.connectors[data.vendor] = data.connector;\n  }\n  // self.pao.pa_wiLog('The dbs inside self.DBS')\n  //self.pao.pa_wiLog(self.DBS)\n};\n\n//# sourceURL=webpack://anzii/./lib/esm/dao/methods.js?");

/***/ }),

/***/ "./lib/esm/dman/dman.js":
/*!******************************!*\
  !*** ./lib/esm/dman/dman.js ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var mysql2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mysql2 */ \"mysql2\");\n/* harmony import */ var _methods_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./methods.js */ \"./lib/esm/dman/methods.js\");\n\n\n//\n// const dman = require('redis')\nclass Dman {\n  constructor(pao) {\n    this.pao = pao;\n    this.DBS = [];\n    this.mysql2 = mysql2__WEBPACK_IMPORTED_MODULE_0__;\n    this.supportedClients = {\n      // mongo: {\n      //   protocol: 'mongopro',\n      //   connectMethods: ''\n      // \t// connect: (0\n      // },\n      mysql: {\n        protocol: \"\",\n        // connectMethod: 'createConnection'\n        connectMethod: \"createPool\"\n      }\n      // pg: {\n      // },\n      // redis: {\n      // },\n      // sqlite: {\n      // }\n    };\n    // // methods\n    this.init = _methods_js__WEBPACK_IMPORTED_MODULE_1__.init;\n    this.handleConfigureDBMan = _methods_js__WEBPACK_IMPORTED_MODULE_1__.handleConfigureDBMan;\n    this.connectToClient = _methods_js__WEBPACK_IMPORTED_MODULE_1__.connectToClient;\n    this.getClientDriver = _methods_js__WEBPACK_IMPORTED_MODULE_1__.getClientDriver;\n    this.connect = _methods_js__WEBPACK_IMPORTED_MODULE_1__.connect;\n  }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Dman);\n\n//# sourceURL=webpack://anzii/./lib/esm/dman/dman.js?");

/***/ }),

/***/ "./lib/esm/dman/index.js":
/*!*******************************!*\
  !*** ./lib/esm/dman/index.js ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _dman_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dman.js */ \"./lib/esm/dman/dman.js\");\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_dman_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n//# sourceURL=webpack://anzii/./lib/esm/dman/index.js?");

/***/ }),

/***/ "./lib/esm/dman/methods.js":
/*!*********************************!*\
  !*** ./lib/esm/dman/methods.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   connect: () => (/* binding */ connect),\n/* harmony export */   connectToClient: () => (/* binding */ connectToClient),\n/* harmony export */   getClientDriver: () => (/* binding */ getClientDriver),\n/* harmony export */   handleConfigureDBMan: () => (/* binding */ handleConfigureDBMan),\n/* harmony export */   init: () => (/* binding */ init)\n/* harmony export */ });\nconst init = function () {\n  this.adLog(\"Dman has been initialised\");\n  this.listens({\n    \"config-dman\": this.handleConfigureDBMan.bind(this)\n  });\n  //   self.query('mysql',sql,process)\n};\nconst handleConfigureDBMan = function (data) {\n  const self = this;\n  const pao = self.pao;\n  self.infoSync(\"The database credentials\");\n  self.infoSync(data);\n  //   self.pao.pa_wiLog('THE DBMAN HANLDECONFIGURE')\n  //   self.pao.pa_wiLog('THE SUPPORTED CLIENTS')\n  //   self.pao.pa_wiLog(self.supportedClients)\n  if (!pao.pa_isObject(data)) {\n    self.logSync(`No database client specified,System will use default`, \"warn\");\n  } else {\n    if (!pao.pa_contains(data, \"clients\")) {\n      self.error(\"System requires clients property with valid config to interface with database clients\");\n    } else {\n      // eslint-disable-next-line no-empty\n      if (!pao.pa_isArray(data.clients)) {} else {\n        let supported = self.supportedClients;\n        try {\n          // eslint-disable-next-line no-unused-vars\n          data.clients.forEach((c, i) => {\n            if (!pao.pa_contains(supported, c.name)) {\n              self.throwError(`Client: \"${c.name} is not supported by the system\"`);\n            } else {\n              self.pao.pa_wiLog(\"THE SYSTEM IS ABOUT TO CONNECT TO THE THE SERVER\");\n              self.connectToClient(c);\n            }\n          });\n          if (self.DBS.length > 0) {\n            self.adLog(`Sending databases to the dao`);\n            self.emit({\n              type: \"dao-take-dbs\",\n              data: {\n                dbs: self.DBS\n              }\n            });\n          }\n          // eslint-disable-next-line no-empty\n        } catch (e) {}\n      }\n    }\n  }\n};\nconst connectToClient = function (client) {\n  const self = this;\n  self.infoSync(`System is about to connect to client: ${client.name}`);\n  // self.infoSync(client)\n  self.getClientDriver(client);\n  // self.supportedClients[client.name].connect(client)\n};\nconst getClientDriver = function (client) {\n  const self = this;\n  self.pao.pa_wiLog(`System is getting a client driver`);\n  self.pao.pa_wiLog(\"THE OTHER DETAILS BELOW\");\n  self.pao.pa_wiLog(client.name);\n  self.pao.pa_wiLog(client.name === \"mysql\");\n  try {\n    let name = client.name;\n    if (name === \"mysql\") {\n      // self.supportedClients[client.name].driver = require(\"mysql2\");\n      self.supportedClients[client.name].driver = self.mysql2;\n    }\n    // }else if(name === 'pg'){\n    // \tself.supportedClients[client.name].driver = require('pg')\n    // }else if(name === 'redis'){\n    // \tself.supportedClients[client.name].driver = require('redis')\n    // }else if(name === 'mongo'){\n    // \tself.supportedClients[client.name].driver = require('mongo')\n    // }else{\n    // \tself.supportedClients[client.name].driver = require('sqlite')\n    // }\n    // switch(client.name){\n    // \tcase 'mysql': self.supportedClients[client.name].driver = require('mysql')\n    // \tbreak;\n    // \tcase 'pg': self.supportedClients[client.name].driver = require('pg')\n    // \tbreak;\n    // \tcase 'redis': self.supportedClients[client.name].driver = require('redis')\n    // \tbreak;\n    // \tcase 'mongo': self.supportedClients[client.name].driver = require('mongo')\n    // \tbreak;\n    // \tdefault: self.supportedClients[client.name].driver = require('sqlite')\n    // \tbreak;\n    // }\n    if (!self.supportedClients[client.name].driver) {\n      self.pao.pa_wiLog(\"THE DRIVER REQUIREMENT FAILED\");\n      self.throwError(\"Failed to get client driver module\");\n    }\n    self.connect(client);\n  } catch (e) {\n    self.pao.pa_wiLog(\"THE DRIVER CONNECT ERROR\");\n    self.pao.pa_wiLog(e.stack);\n  }\n};\nconst connect = function (client) {\n  const self = this;\n  self.infoSync(`System is connecting to client: ${client.name}`);\n  try {\n    let sclient = self.supportedClients[client.name];\n    let opts = {\n      host: client.connect.host,\n      user: client.connect.user,\n      password: client.connect.pass,\n      database: client.connect.name\n    };\n    //  self.infoSync('THE CLIENT DRIVER')\n    //  self.infoSync(sclient)\n    //  self.infoSync(sclient.driver)\n    //  self.infoSync('THE CLIENT OPTIONS')\n    //  self.infoSync(opts)\n    let res = sclient.driver[sclient.connectMethod](opts, (err, res) => {\n      if (err) {\n        self.pao.pa_wiLog(\"THE ACTUAL CONNECTION ERROR\");\n        self.pao.pa_wiLog(err.stack);\n      } else {\n        self.DBS[client.name] = res;\n        self.infoSync(\"System has successfully connected to client\");\n        self.infoSync(`Client ready to serve queries`);\n      }\n    });\n    //   self.pao.pa_wiLog(res)\n    // eslint-disable-next-line no-unused-vars\n    res.query(\"SELECT 1 + 1 AS solution\", function (error, results, fields) {\n      if (error) throw error;\n      self.DBS[client.name] = res;\n      self.infoSync(`System has successfully connected to ${client.name} database client`);\n      self.adLog(\"System is handing client connection\");\n      self.emit({\n        type: \"dao-take-dbs\",\n        data: {\n          vendor: client.name,\n          conn: res,\n          connector: sclient.driver\n        }\n      });\n      self.adLog(`Client ready to serve queries`);\n      // console.log('The solution is: ', results[0].solution);\n    });\n    // res.query(function(e){\n    // \tif(e){\n    // \t\tself.pao.pa_wiLog('THE SYSTEM HAS FAILED TO CONNECT TO THE DATABASE, please refer to the error below:')\n    // \t\tself.pao.pa_wiLog(e.message)\n    // \t\tthrow new Error(e)\n    // \t}else{\n    // \t\tself.DBS[client.name] = res\n    // \t\tself.infoSync(`System has successfully connected to ${client.name} database client`)\n    // \t\tself.adLog(\"System is handing client connection\")\n    // \t\tself.emit({type: 'dao-take-dbs',data:{vendor: client.name,conn: res}})\n    // \t\tself.adLog(`Client ready to serve queries`)\n    // \t}\n    // })\n    //   self.pao.pa_wiLog('THE RESULTS')\n    //   res.query('SELECT 1 + 1 AS solution', function (error, results, fields) {\n    // \tif (error) throw error;\n    // \tself.pao.pa_wiLog('THE CONNECTION TO THE DATABASE')\n    // \tself.pao.pa_wiLog('The solution is: ', results[0].solution);\n    //   });\n    //   res.query()\n  } catch (e) {\n    self.infoSync(\"THE CONNECTION ERROR\");\n    self.infoSync(e.stack);\n    self.pao.pa_wiLog(\"THE CONNECTION EROR\");\n    self.pao.pa_wiLog(e.stack);\n  }\n};\n\n//# sourceURL=webpack://anzii/./lib/esm/dman/methods.js?");

/***/ }),

/***/ "./lib/esm/domain/domain.js":
/*!**********************************!*\
  !*** ./lib/esm/domain/domain.js ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var passport__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! passport */ \"passport\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var _methods_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./methods.js */ \"./lib/esm/domain/methods.js\");\n\n\n\n\nconst {\n  initialize\n} = passport__WEBPACK_IMPORTED_MODULE_1__;\nclass Domain {\n  constructor(pao) {\n    this.pao = pao;\n    this.system = null;\n    this.fs = fs__WEBPACK_IMPORTED_MODULE_0__;\n    this.path = path__WEBPACK_IMPORTED_MODULE_2__;\n    this.passport = passport__WEBPACK_IMPORTED_MODULE_1__;\n    this.init = _methods_js__WEBPACK_IMPORTED_MODULE_3__.init;\n    this.passportInitialize = initialize;\n    this.handleSetDomainDefaults = _methods_js__WEBPACK_IMPORTED_MODULE_3__.handleSetDomainDefaults;\n    this.handleConfigDomain = _methods_js__WEBPACK_IMPORTED_MODULE_3__.handleConfigDomain;\n    this.handleTakeSystemBase = _methods_js__WEBPACK_IMPORTED_MODULE_3__.handleTakeSystemBase;\n    this.hookIntoWebpackCompilation = _methods_js__WEBPACK_IMPORTED_MODULE_3__.hookIntoWebpackCompilation;\n  }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Domain);\n\n//# sourceURL=webpack://anzii/./lib/esm/domain/domain.js?");

/***/ }),

/***/ "./lib/esm/domain/index.js":
/*!*********************************!*\
  !*** ./lib/esm/domain/index.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _domain_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./domain.js */ \"./lib/esm/domain/domain.js\");\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_domain_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n//# sourceURL=webpack://anzii/./lib/esm/domain/index.js?");

/***/ }),

/***/ "./lib/esm/domain/methods.js":
/*!***********************************!*\
  !*** ./lib/esm/domain/methods.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   handleConfigDomain: () => (/* binding */ handleConfigDomain),\n/* harmony export */   handleSetDomainDefaults: () => (/* binding */ handleSetDomainDefaults),\n/* harmony export */   handleTakeSystemBase: () => (/* binding */ handleTakeSystemBase),\n/* harmony export */   hookIntoWebpackCompilation: () => (/* binding */ hookIntoWebpackCompilation),\n/* harmony export */   init: () => (/* binding */ init)\n/* harmony export */ });\nconst init = function () {\n  this.adLog(\"Domain has been initialised\");\n  this.listens({\n    \"config-domain\": this.handleConfigDomain.bind(this),\n    \"take-premier-system-base\": this.handleTakeSystemBase.bind(this),\n    \"set-domain-defaults\": this.handleSetDomainDefaults.bind(this)\n  });\n};\nconst handleSetDomainDefaults = function (data) {\n  const self = this;\n  const domains = self.domainCandidates;\n  const passport = self.passport;\n  const path = self.path;\n  self.infoSync(\"SETTING DOMAIN DEFAULTS\");\n  self.pao.pa_wiLog(`Domain resources data, ${data}`);\n  self.pao.pa_wiLog(`THE DOMAINS, ${domains}`);\n  self.pao.pa_wiLog(`THE DOMAINS PASSPORT, ${passport}`);\n  self.pao.pa_wiLog(`THE PASSPORT, ${self.passportInitialize}`);\n  // self.pao.pa_wiLog(data)\n  self.pao.pa_wiLog(self.system);\n  // self.pao.pa_wiLog(data)\n  // self.pao.pa_wiLog(`OUTPUT PATH\", ${data.custom.webpackConfig.output}`);\n  // self.pao.pa_wiLog(`PATH\", ${data.custom.webpackConfig.output.path}`);\n  if (!domains) return;\n  domains.forEach(dumain => {\n    self.pao.pa_wiLog(\"THE DOMAIN SETTInGS\");\n    self.pao.pa_wiLog(dumain);\n    if (dumain.name === \"views\") return data.app.set(dumain.name, path.join(self.system?.DOCUMENT_ROOT, dumain.set));\n    if (dumain.name === \"static\") {\n      self.pao.pa_wiLog(\"DOMAIN IS STATIC\");\n      self.pao.pa_wiLog(`${path.join(self.system?.DOCUMENT_ROOT)}, ${dumain.set}`);\n      self.pao.pa_wiLog(`DOMAIN IS STATIC\", ${dumain}`);\n      self.pao.pa_wiLog(`DOCUMENT ROOT\", ${self.system?.DOCUMENT_ROOT}`);\n      self.pao.pa_wiLog(`JOINED PATH : ${path.join(self.system?.DOCUMENT_ROOT, dumain.set)}`);\n      return data.app.use(data.xpress.static(path.join(self.system?.DOCUMENT_ROOT, dumain.set)));\n    }\n    if (dumain.name === \"passport\") return data.app.use(passport.initialize());\n    // if (dumain.name === \"webpackDevMiddleware\")\n    //     return data.app.use(dumain.use(data.custom.compiler, {\n    //         publicPath: data.custom.webpackConfig.output.path,\n    //         writeToDisk: true\n    //     }));\n    // if (dumain.name === \"webpackHotMiddleware\")\n    //     return data.app.use(dumain.use(data.custom.compiler));\n    data.app.set(dumain.name, dumain.set);\n  });\n  //data.app.set(, dumain.set);\n  // data?.custom?.compiler ? self.hookIntoWebpackCompilation(data.custom.compiler) : null;\n};\nconst handleConfigDomain = function (data) {\n  const self = this;\n  self.pao.pa_wiLog(\"Configuring Domain\");\n  self.pao.pa_wiLog(data);\n  self.domainCandidates = data;\n};\nconst handleTakeSystemBase = function (data) {\n  const self = this;\n  self.pao.pa_wiLog(\"THE SYSTEMBASE HANDLE\");\n  self.pao.pa_wiLog(data);\n  self.system = data.systemBase;\n};\nconst hookIntoWebpackCompilation = async function (compiler) {\n  compiler.hooks.invalid.tap(\"invalid\", () => {\n    self.pao.pa_wiLog(\"wEBPACK is compiling....\");\n  });\n  compiler.hooks.done.tap(\"done\", stats => {\n    self.pao.pa_wiLog(\"WEBPACK IS DONE COMPILING\");\n    self.pao.pa_wiLog(`${stats.toJson({\n      all: false,\n      errors: true,\n      warnings: true\n    })}`);\n  });\n  return true;\n};\n\n//# sourceURL=webpack://anzii/./lib/esm/domain/methods.js?");

/***/ }),

/***/ "./lib/esm/esm.js":
/*!************************!*\
  !*** ./lib/esm/esm.js ***!
  \************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _anziiloger_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./anziiloger/index.js */ \"./lib/esm/anziiloger/index.js\");\n/* harmony import */ var _config_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./config/index.js */ \"./lib/esm/config/index.js\");\n/* harmony import */ var _dao_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dao/index.js */ \"./lib/esm/dao/index.js\");\n/* harmony import */ var _dman_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dman/index.js */ \"./lib/esm/dman/index.js\");\n/* harmony import */ var _domain_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./domain/index.js */ \"./lib/esm/domain/index.js\");\n/* harmony import */ var _global_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./global/index.js */ \"./lib/esm/global/index.js\");\n/* harmony import */ var _io_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./io/index.js */ \"./lib/esm/io/index.js\");\n/* harmony import */ var _middleware_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./middleware/index.js */ \"./lib/esm/middleware/index.js\");\n/* harmony import */ var _mysql_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./mysql/index.js */ \"./lib/esm/mysql/index.js\");\n/* harmony import */ var _parsers_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./parsers/index.js */ \"./lib/esm/parsers/index.js\");\n/* harmony import */ var _request_index_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./request/index.js */ \"./lib/esm/request/index.js\");\n/* harmony import */ var _router_index_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./router/index.js */ \"./lib/esm/router/index.js\");\n/* harmony import */ var _server_index_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./server/index.js */ \"./lib/esm/server/index.js\");\n/* harmony import */ var _system_index_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./system/index.js */ \"./lib/esm/system/index.js\");\n/* harmony import */ var _view_index_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./view/index.js */ \"./lib/esm/view/index.js\");\n\n\n\n\n//import DoBefores from \"./dobefore/dobefores.js\";\n\n\n\n\n\n\n\n\n\n\n\nclass Esm {\n  constructor() {\n    this.Esm = {\n      Anziiloger: _anziiloger_index_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"],\n      Mysql: _mysql_index_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"],\n      System: _system_index_js__WEBPACK_IMPORTED_MODULE_13__[\"default\"],\n      Middleware: _middleware_index_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"],\n      Parsers: _parsers_index_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"],\n      //DoBefores,\n      Router: _router_index_js__WEBPACK_IMPORTED_MODULE_11__[\"default\"],\n      Request: _request_index_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"],\n      View: _view_index_js__WEBPACK_IMPORTED_MODULE_14__[\"default\"],\n      Domain: _domain_index_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"],\n      Dao: _dao_index_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"],\n      Dman: _dman_index_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"],\n      Server: _server_index_js__WEBPACK_IMPORTED_MODULE_12__[\"default\"],\n      Config: _config_index_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n      IO: _io_index_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"],\n      Global: _global_index_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]\n    };\n  }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new Esm());\n\n//# sourceURL=webpack://anzii/./lib/esm/esm.js?");

/***/ }),

/***/ "./lib/esm/global/global.js":
/*!**********************************!*\
  !*** ./lib/esm/global/global.js ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _methods_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./methods.js */ \"./lib/esm/global/methods.js\");\n\nclass Global {\n  constructor(pao) {\n    this.pao = pao;\n    this.globals = [];\n    this.init = _methods_js__WEBPACK_IMPORTED_MODULE_0__.init;\n    this.handleRequestGlobalRequest = _methods_js__WEBPACK_IMPORTED_MODULE_0__.handleRequestGlobalRequest;\n  }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Global);\n\n//# sourceURL=webpack://anzii/./lib/esm/global/global.js?");

/***/ }),

/***/ "./lib/esm/global/index.js":
/*!*********************************!*\
  !*** ./lib/esm/global/index.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _global_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./global.js */ \"./lib/esm/global/global.js\");\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_global_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n//# sourceURL=webpack://anzii/./lib/esm/global/index.js?");

/***/ }),

/***/ "./lib/esm/global/methods.js":
/*!***********************************!*\
  !*** ./lib/esm/global/methods.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   handleRequestGlobalRequest: () => (/* binding */ handleRequestGlobalRequest),\n/* harmony export */   init: () => (/* binding */ init)\n/* harmony export */ });\nconst init = function () {\n  this.adLog(\"Global has been initialised\");\n  this.listens({\n    \"request-global-request\": this.handleRequestGlobalRequest.bind(this)\n  });\n};\nconst handleRequestGlobalRequest = function (data) {\n  const self = this;\n  self.pao.pa_wiLog(\"The Modules: \", self.globals);\n  if (self.globals && self.globals.length > 0) {\n    if (self.globals.indexOf(data) > -1) {\n      self.emit({\n        type: \"request-global-request-response\",\n        data: true\n      });\n    } else {\n      self.emit({\n        type: \"request-global-request-response\",\n        data: false\n      });\n    }\n  } else {\n    self.emit({\n      type: \"request-global-request-error\",\n      data: false\n    });\n  }\n};\n\n//# sourceURL=webpack://anzii/./lib/esm/global/methods.js?");

/***/ }),

/***/ "./lib/esm/io/index.js":
/*!*****************************!*\
  !*** ./lib/esm/io/index.js ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _io_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./io.js */ \"./lib/esm/io/io.js\");\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_io_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n//# sourceURL=webpack://anzii/./lib/esm/io/index.js?");

/***/ }),

/***/ "./lib/esm/io/io.js":
/*!**************************!*\
  !*** ./lib/esm/io/io.js ***!
  \**************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _methods_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./methods.js */ \"./lib/esm/io/methods.js\");\n\nclass IO {\n  constructor(pao) {\n    this.pao = pao;\n    this.init = _methods_js__WEBPACK_IMPORTED_MODULE_0__.init;\n    this.startIOShell = _methods_js__WEBPACK_IMPORTED_MODULE_0__.startIOShell;\n  }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (IO);\n\n//# sourceURL=webpack://anzii/./lib/esm/io/io.js?");

/***/ }),

/***/ "./lib/esm/io/methods.js":
/*!*******************************!*\
  !*** ./lib/esm/io/methods.js ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   init: () => (/* binding */ init),\n/* harmony export */   startIOShell: () => (/* binding */ startIOShell)\n/* harmony export */ });\nconst init = function () {\n  this.adLog(\"IO has been initialised\");\n  this.startIOShell();\n};\nconst startIOShell = function () {\n  const self = this;\n  self.adLog(\"Starting i/o Shell operations\");\n  self.emit({\n    type: \"start-io-operations\",\n    data: \"\"\n  });\n};\n\n//# sourceURL=webpack://anzii/./lib/esm/io/methods.js?");

/***/ }),

/***/ "./lib/esm/middleware/index.js":
/*!*************************************!*\
  !*** ./lib/esm/middleware/index.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _middleware_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./middleware.js */ \"./lib/esm/middleware/middleware.js\");\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_middleware_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n//# sourceURL=webpack://anzii/./lib/esm/middleware/index.js?");

/***/ }),

/***/ "./lib/esm/middleware/methods.js":
/*!***************************************!*\
  !*** ./lib/esm/middleware/methods.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   allWares: () => (/* binding */ allWares),\n/* harmony export */   attachMiddleware: () => (/* binding */ attachMiddleware),\n/* harmony export */   handleAddExternalMiddleware: () => (/* binding */ handleAddExternalMiddleware),\n/* harmony export */   handleAttachMiddleware: () => (/* binding */ handleAttachMiddleware),\n/* harmony export */   handleConfigMiddleware: () => (/* binding */ handleConfigMiddleware),\n/* harmony export */   init: () => (/* binding */ init)\n/* harmony export */ });\nconst init = function () {\n  this.adLog(\"Middleware has been initialised\");\n  this.listens({\n    \"config-middleware\": this.handleConfigMiddleware.bind(this),\n    \"add-ext-middleware\": this.handleAddExternalMiddleware.bind(this),\n    \"attach-middleware\": this.handleAttachMiddleware.bind(this)\n  });\n};\nconst handleAttachMiddleware = function (data) {\n  this.attachMiddleware(data);\n};\nconst handleConfigMiddleware = function (data) {\n  console.log(\"CONFIG MIDDLEWARE\", data);\n  const self = this;\n  //  self.pao.pa_wiLog('THE HANDLE CONFIG MIDDLEWARE')\n  //  self.pao.pa_wiLog(data)\n  //  self.pao.pa_wiLog(data)\n  let middlewares = data;\n  //  self.pao.pa_wiLog(middlewares)\n  for (let p in middlewares) {\n    // self.pao.pa_wiLog('THE P')\n    // self.pao.pa_wiLog(p)\n    if (self.middlewares[p]) {\n      if (middlewares[p].addMiddleware) {\n        // self.pao.pa_wiLog('INSIDE EXISTENT MIDDLEWARE ITEM')\n        // self.pao.pa_wiLog(middlewares[p])\n        // eslint-disable-next-line no-unused-vars\n        middlewares[p].addMiddleware.forEach((m, i) => {\n          self.middlewares[p].push(m);\n        });\n        // eslint-disable-next-line no-empty\n      } else if (p === \"removeMiddleware\") {}\n    } else {\n      console.log(\"CONFIG MIDDLEWALRES\", middlewares, p);\n      if (middlewares[p].addMiddleware) {\n        self.middlewares[p] = [...middlewares[p].addMiddleware];\n        console.log(\"CONFIG MIDDLEWARES SELF\", self.middlewares);\n      }\n    }\n  }\n};\nconst handleAddExternalMiddleware = function (data) {\n  const self = this;\n  const pao = self.pao;\n  self.pao.pa_wiLog(\"ADD EXTERNAL MIDDLEWARE EVENT HAS OCCURED\");\n  if (data.type) {\n    if (data.type === \"private\") {\n      if (data.level === \"top\") {\n        if (pao.pa_isArray(data.middleware.funk)) {\n          // eslint-disable-next-line no-unused-vars\n          data.middleware.forEach((m, i) => {\n            self.middleware.unshift({\n              type: \"function\",\n              value: m.funk,\n              ext: true\n            });\n          });\n        } else {\n          self.pao.pa_wiLog(\"THE MIDDLEWARES BEFORE\");\n          self.pao.pa_wiLog(self.middlewares);\n          if (self.middlewares.pprivate) {\n            let len = Object.keys(self.middlewares.pprivate).length;\n            self.middlewares.pprivate[len] = {\n              type: \"function\",\n              value: data.middleware.funk,\n              ext: true\n            };\n            self.pao.pa_wiLog(\"Middlewares\");\n            self.pao.pa_wiLog(self.middlewares);\n          }\n        }\n        // eslint-disable-next-line no-empty\n      } else {}\n      // eslint-disable-next-line no-empty\n    } else if (data.type === \"public\") {} else if (data.type === \"all\") {\n      // eslint-disable-next-line no-empty\n      if (data.level === \"top\") {}\n    }\n  }\n};\nconst attachMiddleware = function (data) {\n  const self = this;\n  if (data.app) {\n    // self.pao.pa_wiLog('SELF.MIDDLEWARES')\n    // self.pao.pa_wiLog(self.middlewares)\n    if (self.all.length > 0) {\n      self.pao.pa_wiLog(\"THE Allwares is greater than zero\");\n      if (data.xpress) {\n        self.allWares(data.app, data.xpress);\n      }\n    }\n    if (self.middlewares.pprivate && self.middlewares.ppublic) {\n      self.emit({\n        type: \"router-middleware\",\n        data: {\n          middleware: {\n            public: self.middlewares.ppublic,\n            private: self.middlewares.pprivate\n          }\n        }\n      });\n    } else if (self.middlewares.pprivate) {\n      self.emit({\n        type: \"router-middleware\",\n        data: {\n          middleware: {\n            private: self.middlewares.pprivate\n          }\n        }\n      });\n    } else if (self.middlewares.ppublic) {\n      console.log(\"CONFIG MIDDLEWARE public\");\n      self.emit({\n        type: \"router-middleware\",\n        data: {\n          middleware: {\n            public: self.middlewares.ppublic\n          }\n        }\n      });\n    }\n    if (self.middlewares.all) {\n      console.log(\"CONFIG MIDDLEWARE PROCESSING ALL MIDDLEWARE\", self.middlewares.all);\n\n      // self.pao.pa_wiLog('FOR EVERY REQUEST MIDDLEWARES')\n      // self.pao.pa_wiLog(self.middlewares.all)\n      // eslint-disable-next-line no-unused-vars\n      self.middlewares.all.forEach((m, i) => {\n        console.log(\"MIDDLEWARE ALL\", m);\n        if (m.type === \"function\") {\n          if (m?.options) {\n            data.app.use(m.value(m.options));\n          } else {\n            data.app.use(m.value);\n          }\n        } else if (m.type === \"module\") {\n          // self.emit({type: `add-${m.value}-middleware`,data: data.app})\n        }\n      });\n    }\n  }\n};\nconst allWares = function (app, xpress) {\n  const self = this;\n  const pao = self.pao;\n  // eslint-disable-next-line no-unused-vars\n  self.all.forEach((w, i) => {\n    if (pao.pa_isObject(w)) {\n      self.pao.pa_wiLog(\"Executing allwares\");\n      if (w.use) {\n        self.pao.pa_wiLog(\"The public:\", w.call);\n        app.use(xpress[w.call](\"public\"));\n      } else {\n        self.pao.pa_wiLog(\"The none-public:\", w.call);\n        app.use(xpress[w.call]());\n      }\n    } else {\n      self.pao.pa_wiLog(\"middleware is string\");\n      app.use(xpress[w]());\n    }\n  });\n};\n\n//# sourceURL=webpack://anzii/./lib/esm/middleware/methods.js?");

/***/ }),

/***/ "./lib/esm/middleware/middleware.js":
/*!******************************************!*\
  !*** ./lib/esm/middleware/middleware.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _methods_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./methods.js */ \"./lib/esm/middleware/methods.js\");\n\nclass Middleware {\n  constructor(pao) {\n    this.pao = pao;\n    this.all = [{\n      call: \"static\",\n      use: \"public\"\n    }, \"json\"];\n    this.middlewares = {\n      all: [{\n        type: \"function\",\n        value: (req, res, next) => {\n          //  adL('I am the zeenith ware'),\n          res.header(\"Access-Control-Allow-Origin\", \"*\");\n          res.header(\"Access-Control-Allow-Headers\", \"Origin, X-Requested-With, Content-Type, Accept\");\n          next();\n        }\n      }\n      // {type: 'module',value: 'test'}\n      ]\n    };\n    // console.log('THE STORE')\n    // console.log(this.supubu\n    this.init = _methods_js__WEBPACK_IMPORTED_MODULE_0__.init;\n    this.handleAttachMiddleware = _methods_js__WEBPACK_IMPORTED_MODULE_0__.handleAttachMiddleware;\n    this.attachMiddleware = _methods_js__WEBPACK_IMPORTED_MODULE_0__.attachMiddleware;\n    this.handleConfigMiddleware = _methods_js__WEBPACK_IMPORTED_MODULE_0__.handleConfigMiddleware;\n    this.handleAddExternalMiddleware = _methods_js__WEBPACK_IMPORTED_MODULE_0__.handleAddExternalMiddleware;\n    this.allWares = _methods_js__WEBPACK_IMPORTED_MODULE_0__.allWares;\n  }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Middleware);\n\n//# sourceURL=webpack://anzii/./lib/esm/middleware/middleware.js?");

/***/ }),

/***/ "./lib/esm/mysql/index.js":
/*!********************************!*\
  !*** ./lib/esm/mysql/index.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _mysql_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mysql.js */ \"./lib/esm/mysql/mysql.js\");\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_mysql_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n//# sourceURL=webpack://anzii/./lib/esm/mysql/index.js?");

/***/ }),

/***/ "./lib/esm/mysql/methods.js":
/*!**********************************!*\
  !*** ./lib/esm/mysql/methods.js ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JOIN: () => (/* binding */ JOIN),\n/* harmony export */   PROCEDURE: () => (/* binding */ PROCEDURE),\n/* harmony export */   SEARCH: () => (/* binding */ SEARCH),\n/* harmony export */   TRANSACTION: () => (/* binding */ TRANSACTION),\n/* harmony export */   combineFields: () => (/* binding */ combineFields),\n/* harmony export */   conditionsConnector: () => (/* binding */ conditionsConnector),\n/* harmony export */   deleteandtake: () => (/* binding */ deleteandtake),\n/* harmony export */   fieldFormat: () => (/* binding */ fieldFormat),\n/* harmony export */   find: () => (/* binding */ find),\n/* harmony export */   findIterateItemPromise: () => (/* binding */ findIterateItemPromise),\n/* harmony export */   findOne: () => (/* binding */ findOne),\n/* harmony export */   getOperand: () => (/* binding */ getOperand),\n/* harmony export */   handleMysqlDataRequest: () => (/* binding */ handleMysqlDataRequest),\n/* harmony export */   init: () => (/* binding */ init),\n/* harmony export */   insert: () => (/* binding */ insert),\n/* harmony export */   insertMany: () => (/* binding */ insertMany),\n/* harmony export */   insertOne: () => (/* binding */ insertOne),\n/* harmony export */   insertandtake: () => (/* binding */ insertandtake),\n/* harmony export */   join: () => (/* binding */ join),\n/* harmony export */   joinConditionsFormat: () => (/* binding */ joinConditionsFormat),\n/* harmony export */   joinExek: () => (/* binding */ joinExek),\n/* harmony export */   joinStatement: () => (/* binding */ joinStatement),\n/* harmony export */   limit: () => (/* binding */ limit),\n/* harmony export */   multiTableUpdate: () => (/* binding */ multiTableUpdate),\n/* harmony export */   options: () => (/* binding */ options),\n/* harmony export */   parseFormatCondition: () => (/* binding */ parseFormatCondition),\n/* harmony export */   parseGroup: () => (/* binding */ parseGroup),\n/* harmony export */   procedure: () => (/* binding */ procedure),\n/* harmony export */   procedureDelete: () => (/* binding */ procedureDelete),\n/* harmony export */   procedureSelect: () => (/* binding */ procedureSelect),\n/* harmony export */   procedureUpdate: () => (/* binding */ procedureUpdate),\n/* harmony export */   queryOptions: () => (/* binding */ queryOptions),\n/* harmony export */   queryTemplate: () => (/* binding */ queryTemplate),\n/* harmony export */   remove: () => (/* binding */ remove),\n/* harmony export */   removeJoin: () => (/* binding */ removeJoin),\n/* harmony export */   rollback: () => (/* binding */ rollback),\n/* harmony export */   search: () => (/* binding */ search),\n/* harmony export */   searchConditionsFormat: () => (/* binding */ searchConditionsFormat),\n/* harmony export */   searchExek: () => (/* binding */ searchExek),\n/* harmony export */   searchFieldsFormat: () => (/* binding */ searchFieldsFormat),\n/* harmony export */   searchOptions: () => (/* binding */ searchOptions),\n/* harmony export */   searchStatement: () => (/* binding */ searchStatement),\n/* harmony export */   set: () => (/* binding */ set),\n/* harmony export */   sort: () => (/* binding */ sort),\n/* harmony export */   take: () => (/* binding */ take),\n/* harmony export */   takeSql: () => (/* binding */ takeSql),\n/* harmony export */   transaction: () => (/* binding */ transaction),\n/* harmony export */   updateJoinTemplate: () => (/* binding */ updateJoinTemplate),\n/* harmony export */   updateMany: () => (/* binding */ updateMany),\n/* harmony export */   updateOne: () => (/* binding */ updateOne),\n/* harmony export */   updateandtake: () => (/* binding */ updateandtake)\n/* harmony export */ });\n/* eslint-disable no-irregular-whitespace */\n/* eslint-disable no-mixed-spaces-and-tabs */\nconst init = function () {\n  this.adLog(\"Mysql has been initialised\");\n  this.listens({\n    \"mysql-data-request\": this.handleMysqlDataRequest.bind(this)\n  });\n};\nconst handleMysqlDataRequest = function (data) {\n  const self = this;\n  const pao = self.pao;\n  // self.pao.pa_wiLog(\"Handling Mysql Data Request\")\n  // self.pao.pa_wiLog(data.table)\n  // self.pao.pa_wiLog(data.outComehandler)\n  // self.pao.pa_wiLog(data.opi)\n  // self.pao.pa_wiLog(data)\n  if (!pao.pa_contains(data, [\"conn\", \"table\", \"opi\", \"query\", \"outComehandler\"])) {\n    self.pao.pa_wiLog(\"Data request operations failed\");\n    return data.outComehandler({\n      message: \"Database operation failed\"\n    });\n  } else {\n    if (!pao.pa_isObject(data.conn)) {\n      self.pao.pa_wiLog(\"THE connection is not object\");\n    } else {\n      if (!pao.pa_isString(data.table)) {\n        self.pao.pa_wiLog(\"THE TABLE NAME IS NOT A STRING\");\n      } else {\n        if (data.opi.trim() !== \"deletemultiple\" && !self[data.opi]) {\n          self.pao.pa_wiLog(\"DATA.OPI IS NOT CONTAINED AS FUNCTION\");\n          self.pao.pa_wiLog(data.opi.trim() !== \"deletemultiple\");\n          self.pao.pa_wiLog(data.opi);\n          return data.outComehandler({\n            message: \"The specified operation is not supported\"\n          });\n        } else {\n          self.pao.pa_wiLog(\"THE CODE GOES THIS FAR\");\n          if (data.opi === \"insert\") {\n            data.opi = \"insertOne\";\n            self[data.opi](data);\n            self.pao.pa_wiLog(\"this runs after opi finishes\");\n          } else if (data.opi === \"find\") {\n            // data.opi = 'findOne'\n            self[data.opi](data);\n          } else if (data.opi === \"updateOne\") {\n            data.opi = \"updateOne\";\n            self[data.opi](data);\n          } else if (data.opi === \"transaction\") {\n            data.opi = \"transaction\";\n            self[data.opi](data);\n          } else if (data.opi === \"procedure\") {\n            data.opi = \"procedure\";\n            self[data.opi](data);\n          } else if (data.opi === \"join\") {\n            data.opi = \"join\";\n            self[data.opi](data);\n          } else if (data.opi === \"search\") {\n            data.opi = \"search\";\n            self[data.opi](data);\n          } else if (data.opi === \"remove\") {\n            data.opi = \"remove\";\n            self[data.opi](data);\n          } else if (data.opi === \"updateandtake\") {\n            self[data.opi](data);\n          } else if (data.opi === \"insertandtake\") {\n            self[data.opi](data);\n          } else if (data.opi === \"deleteandtake\") {\n            self[data.opi](data);\n          } else if (data.opi === \"deletemultiple\") {\n            self.deleteandtake(data);\n          } else {\n            self[data.opi](data);\n          }\n        }\n      }\n    }\n  }\n};\nconst insertOne = function (insert) {\n  const self = this;\n  const pao = self.pao;\n  // eslint-disable-next-line no-empty\n  if (!pao.pa_isObject(insert)) {} else {\n    try {\n      // self.infoSync('THE INSERT INSERT ONE')\n      // self.infoSync(insert)\n      let handler = insert.outComehandler;\n      const conn = insert.conn;\n      const connector = insert.connector;\n      const query = insert.query;\n      self.pao.pa_wiLog(\"THE INSERT OBJECT\");\n      self.pao.pa_wiLog(insert);\n      let sql = `INSERT INTO ?? (??) VALUES(?)`;\n      let queryAttributes = [insert.table, [\"id\", ...query.fields], [null, ...query.values]];\n      sql = connector.format(sql, queryAttributes);\n      self.pao.pa_wiLog(\"THE SQL STATEMENT\");\n      self.pao.pa_wiLog(sql);\n      self.infoSync(\"THE HANDLER\");\n      self.infoSync(handler);\n      //  let sql = `INSERT INTO ${data.table} SET ?`\n      conn.query(sql, function (e, r) {\n        self.pao.pa_wiLog(\"INSERT RESULT\");\n        self.pao.pa_wiLog(r);\n        self.pao.pa_wiLog(e);\n        if (e) return handler(e, null);\n        r.user = insert.values;\n        self.pao.pa_wiLog(r.user);\n        self.info(\"THE HANDLER IN QUERY\");\n        self.infoSync(handler);\n        handler(null, r);\n      });\n    } catch (e) {\n      self.pao.pa_wiLog(\"CAUTH ERROR\");\n      self.pao.pa_wiLog(e);\n      self.infoSync(\"THE CAUTH ERROR\");\n      self.infoSync(e);\n      // eslint-disable-next-line no-undef\n      handler(e, null);\n    }\n  }\n};\nconst insertMany = function (insert) {\n  const self = this;\n  const pao = self.pao;\n  // eslint-disable-next-line no-undef, no-empty\n  if (!pao.pa_isObject(data)) {} else {\n    try {\n      let sql = `INSERT INTO ?? (?) VALUES(?)`;\n      let result = [];\n      // eslint-disable-next-line no-unused-vars\n      let fullImplement = true;\n      insert.bulk.forEach(insertItem => {\n        let queryAttributes = [insertItem.table, [...insertItem.fields], [...insertItem.values]];\n        // eslint-disable-next-line no-undef\n        sql = connector.format(sql, queryAttributes);\n        // eslint-disable-next-line no-undef\n        conn.query(sql, insertItem, function (e, r) {\n          if (e) {\n            fullImplement = false;\n          } else {\n            result.push(r);\n          }\n        });\n      });\n      self.pao.pa_wiLog(\"bulk insert completed\");\n      // eslint-disable-next-line no-undef\n      handler(null, result);\n    } catch (e) {\n      // eslint-disable-next-line no-undef\n      handler(e, null);\n    }\n  }\n};\nconst find = async function (findiks) {\n  const self = this;\n  const pao = self.pao;\n  // self.infoSync('THE FINDIKS')\n  // self.infoSync(findiks)\n  // self.pao.pa_wiLog('fIND.FINDIKS')\n  // self.pao.pa_wiLog(findiks.query.length)\n  // if(findiks.query.length > 0){ return findiks.outComehandler({message: 'ERROR IN MYSQL.FIND.METHOD'})}\n  // self.pao.pa_wiLog('THE DATA IN FINDONE')\n  // self.pao.pa_wiLog(findiks)\n  if (!pao.pa_isObject(findiks)) {\n    throw new Error(\"Argument:: findiks, is required\");\n  } else {\n    let conn = findiks.conn;\n    let connector = findiks.connector;\n    let handler = findiks.outComehandler;\n    let query = [];\n    let result = [];\n    // self.infoSync('THE FUNCTIONS')\n    // self.infoSync(connector.format)\n    // self.infoSync(conn.query)\n    conn.getConnection(async function (err, connection) {\n      if (err) throw new Error(\"THERE WAS AN ERROR GETTING CONNECTION FROM THE POOL\");\n      let multiple = false;\n      if (findiks.table.toUpperCase().trim() === \"MULTIPLE\") {\n        self.infoSync(\"IT IS MULTIPLE\");\n        self.infoSync(findiks.query);\n        multiple = true;\n        query = findiks.query;\n      } else {\n        self.infoSync(\"THE QURY\");\n        self.infoSync(query);\n        query.push(findiks.query);\n      }\n      for (let q = 0; q < query.length; q++) {\n        // self.infoSync('INDEX')\n        // self.infoSync(q)\n        // self.infoSync('THE RESULT VALUE')\n        // self.infoSync(result)\n        let find = null;\n        if (multiple) {\n          find = {\n            table: query[q].table,\n            ...query[q]\n          };\n        } else {\n          find = {\n            table: findiks.table,\n            ...query[q]\n          };\n          // find.opiks && Object.keys(find).length === 2 ? '' : !find.conditions ? find.conditions = [`${Object.keys(query)[0]} ISEQUALS ${query[Object.keys(query)[0]]}`]: ''\n        }\n        try {\n          // self.infoSync('THE FIND')\n          // self.infoSync(find)\n          self.infoSync(\"THE CURRENT INDEX\");\n          self.infoSync(q);\n          let sql = \"\";\n          let attribs = null;\n          let sqliks = self.queryTemplate(self.queryOptions(find), \"select\");\n          //  self.pao.pa_wiLog('THE SQLKIKS OBJECT FIND')\n          //  self.pao.pa_wiLog(sqliks)\n          attribs = [sqliks.attribs.from.table];\n          sql = sqliks.statement;\n          let queryAttributes = attribs;\n          // self.pao.pa_wiLog('THE SQL BEFORE FORMAT')\n          sql = connector.format(sql, queryAttributes);\n          // self.pao.pa_wiLog(sql)\n          // self.pao.pa_wiLog(sql)\n          self.infoSync(\"THE SQL AFTER FORMATTING\");\n          self.infoSync(sql);\n          // self.infoSync('CHECK IF CONN.QUERY IS A PROMISE')\n          // self.infoSync(conn.query)\n          // self.infoSync(conn.query.then ? 'It is promise' : 'it is not a promise')\n          let currentResult = await self.findIterateItemPromise(connection, sql);\n          let isError = currentResult instanceof Array ? false : true;\n          self.infoSync(\"THE RESULT\");\n          self.infoSync(currentResult);\n          self.infoSync(currentResult.length);\n          self.infoSync(isError);\n          self.infoSync(currentResult.length === 0 && query.length === 1);\n          if (isError) {\n            if (find.alias) {\n              if (result instanceof Array) {\n                result = {\n                  [find.alias]: {\n                    ERROR: currentResult.e\n                  }\n                };\n              } else {\n                result[find.alias] = {\n                  ERROR: currentResult.e\n                };\n              }\n            } else {\n              result.push({\n                ERROR: currentResult.e\n              });\n            }\n          } else if (currentResult.length === 0 && query.length === 1) {\n            self.infoSync(\"cURRENT RESULT IS EMPTY AND THE IS ONLY ONE QUERY BEING PROCESSED\");\n            self.infoSync(currentResult);\n            connection.release();\n            findiks.select ? handler(null, [], findiks.select) : handler(null, []);\n            return;\n          } else {\n            if (find.alias) {\n              if (result instanceof Array) {\n                result = {\n                  [find.alias]: currentResult\n                };\n              } else {\n                result[find.alias] = currentResult;\n              }\n            } else {\n              result.push(currentResult);\n            }\n          }\n          if (q === query.length - 1) {\n            self.infoSync(\"WE ARE RELEASING THE CONNECTION\");\n            connection.release();\n            if (result.length === 1 && result[0] instanceof Array) result = result[0];\n            findiks.select ? handler(null, result, findiks.select) : handler(null, result);\n            return;\n          }\n          // self.infoSync('THE QUERYRESULT')\n          // self.infoSync(queryRes)\n          // conn.query(sql,function(e,r,f){\n          //       // self.pao.pa_wiLog('THE QUERY IS COMPLETED WITH RESULTS')\n          //       // self.pao.pa_wiLog(e)\n          //       // self.pao.pa_wiLog(r)\n          //       // self.pao.pa_wiLog(typeof r)\n          //       // self.pao.pa_wiLog(f)\n          //       // self.pao.pa_wiLog(r instanceof Array)\n          //       // self.pao.pa_wiLog(pao.pa_isArray(r))\n          //       // self.pao.pa_wiLog(r.length)\n          //       // self.pao.pa_wiLog('After R evaluation')\n          //       // self.infoSync('THE rESULT HAS BEEN RETRIEVED')\n          //       // self.infoSync(r)\n          //       // self.infoSync(result)\n          //       // self.infoSync(pao.pa_isArray(r))\n          //       // self.infoSync(r.length)\n          //       // self.infoSync(query.length)\n          //       // self.infoSync(e)\n          //       try{\n          //       if(e) result.push(e)\n          //       if(pao.pa_isArray(r) && r.length > 0 && query.length !== 1 ){\n          //           if(find.alias){\n          //             if(result instanceof Array){\n          //               self.infoSync('THE RESULT TO BE CONVERTED TO OBJECT')\n          //               self.infoSync(find.alias)\n          //               result = {[find.alias]: [...r]}\n          //               self.infoSync(result)\n          //             }else{\n          //               self.infoSync('THE RESULT OBJECT IS TYPE OBJECT')\n          //               self.infoSync(result)\n          //               result[find.alias] = [...r]\n          //             }\n          //           }else{\n          //             r = [...r];\n          //             result.push(r)\n          //           }\n          //         }else{\n          //           // self.infoSync('the result is not an array')\n          //           // self.infoSync(r)\n          //           // if(result.length > 0){\n          //           //   self.infoSync('THE RESULT IS GREATER THAN ZERO')\n          //           // }else{\n          //           // }\n          //           result = r\n          //         }\n          //       if(q === query.length - 1){\n          //         self.pao.pa_wiLog('THE LOOP IS COMPLETE WITH DATA:')\n          //         self.pao.pa_wiLog(result)\n          //         self.infoSync('THE CURRENT LAST RESULT')\n          //          self.infoSync(q)\n          //          self.infoSync(r)\n          //         self.infoSync('THE LOOP IS COMPLETE WITH RESULTS')\n          //         self.infoSync(result)\n          //         findiks.select ?  handler(null,result,findiks.select) : handler(null,result)\n          //         return\n          //       }else{\n          //          self.infoSync('THE CURRENT RESULT')\n          //          self.infoSync(q)\n          //          self.infoSync(r)\n          //       }\n          //     }catch(erra){\n          //       self.infoSync('ther erra')\n          //       self.infoSync(erra)\n          //     }\n          //   })\n        } catch (e) {\n          // self.pao.pa_wiLog('AN ERROR OCCURED IN FIND ONE ')\n          // self.pao.pa_wiLog(e)\n          findiks.select ? handler(e, null, findiks.select) : handler(e, null);\n          return;\n        }\n      }\n    });\n  }\n};\nconst findOne = async function (findiks) {\n  const self = this;\n  const pao = self.pao;\n  // self.infoSync('THE FINDIKS')\n  // self.infoSync(findiks)\n  // self.pao.pa_wiLog('fIND.FINDIKS')\n  // self.pao.pa_wiLog(findiks.query.length)\n  // if(findiks.query.length > 0){ return findiks.outComehandler({message: 'ERROR IN MYSQL.FIND.METHOD'})}\n  // self.pao.pa_wiLog('THE DATA IN FINDONE')\n  // self.pao.pa_wiLog(findiks)\n  if (!pao.pa_isObject(findiks)) {\n    throw new Error(\"Argument:: findiks, is required\");\n  } else {\n    let conn = findiks.conn;\n    let connector = findiks.connector;\n    let handler = findiks.outComehandler;\n    let query = [];\n    let result = [];\n    let multiple = false;\n    if (findiks.table.toUpperCase().trim() === \"MULTIPLE\") {\n      self.infoSync(\"IT IS MULTIPLE\");\n      self.infoSync(findiks.query);\n      multiple = true;\n      query = findiks.query;\n    } else {\n      self.infoSync(\"THE QURY\");\n      self.infoSync(query);\n      query.push(findiks.query);\n    }\n    for (let q = 0; q < query.length; q++) {\n      // self.infoSync('INDEX')\n      // self.infoSync(q)\n      // self.infoSync('THE RESULT VALUE')\n      // self.infoSync(result)\n      let find = null;\n      if (multiple) {\n        find = {\n          table: query[q].table,\n          ...query[q]\n        };\n      } else {\n        find = {\n          table: findiks.table,\n          ...query[q]\n        };\n        // find.opiks && Object.keys(find).length === 2 ? '' : !find.conditions ? find.conditions = [`${Object.keys(query)[0]} ISEQUALS ${query[Object.keys(query)[0]]}`]: ''\n      }\n      try {\n        // self.infoSync('THE FIND')\n        // self.infoSync(find)\n        self.infoSync(\"THE CURRENT INDEX\");\n        self.infoSync(q);\n        let sql = \"\";\n        let attribs = null;\n        let sqliks = self.queryTemplate(self.queryOptions(find), \"select\");\n        //  self.pao.pa_wiLog('THE SQLKIKS OBJECT FIND')\n        //  self.pao.pa_wiLog(sqliks)\n        attribs = [sqliks.attribs.from.table];\n        sql = sqliks.statement;\n        let queryAttributes = attribs;\n        // self.pao.pa_wiLog('THE SQL BEFORE FORMAT')\n        sql = connector.format(sql, queryAttributes);\n        // self.pao.pa_wiLog(sql)\n        // self.pao.pa_wiLog(sql)\n        self.infoSync(\"THE SQL AFTER FORMATTING\");\n        self.infoSync(sql);\n        // self.infoSync('CHECK IF CONN.QUERY IS A PROMISE')\n        // self.infoSync(conn.query)\n        // self.infoSync(conn.query.then ? 'It is promise' : 'it is not a promise')\n        let currentResult = await self.findIterateItemPromise(conn, sql);\n        let isError = currentResult instanceof Array ? false : true;\n        self.infoSync(\"THE RESULT\");\n        self.infoSync(currentResult);\n        self.infoSync(currentResult.length);\n        self.infoSync(isError);\n        self.infoSync(currentResult.length === 0 && query.length === 1);\n        if (isError) {\n          if (find.alias) {\n            if (result instanceof Array) {\n              result = {\n                [find.alias]: {\n                  ERROR: currentResult.e\n                }\n              };\n            } else {\n              result[find.alias] = {\n                ERROR: currentResult.e\n              };\n            }\n          } else {\n            result.push({\n              ERROR: currentResult.e\n            });\n          }\n        } else if (currentResult.length === 0 && query.length === 1) {\n          self.infoSync(\"cURRENT RESULT IS EMPTY AND THE IS ONLY ONE QUERY BEING PROCESSED\");\n          self.infoSync(currentResult);\n          // eslint-disable-next-line no-undef\n          connection.release();\n          findiks.select ? handler(null, [], findiks.select) : handler(null, []);\n          return;\n        } else {\n          if (find.alias) {\n            if (result instanceof Array) {\n              result = {\n                [find.alias]: currentResult\n              };\n            } else {\n              result[find.alias] = currentResult;\n            }\n          } else {\n            result.push(currentResult);\n          }\n        }\n        if (q === query.length - 1) {\n          if (result.length === 1 && result[0] instanceof Array) result = result[0];\n          findiks.select ? handler(null, result, findiks.select) : handler(null, result);\n          return;\n        }\n      } catch (e) {\n        // self.pao.pa_wiLog('AN ERROR OCCURED IN FIND ONE ')\n        // self.pao.pa_wiLog(e)\n        // eslint-disable-next-line no-undef\n        connection.release();\n        findiks.select ? handler(e, null, findiks.select) : handler(e, null);\n        return;\n      }\n    }\n  }\n};\nconst findIterateItemPromise = function (conn, sql) {\n  const self = this;\n  return new Promise((resolve, reject) => {\n    conn.query(sql, function (e, r) {\n      self.infoSync(\"fINDITERATE ERROR\");\n      self.infoSync(e);\n      self.infoSync(r);\n      if (e) return reject({\n        FIND_ITERATE_ERROR: true,\n        e: e\n      });\n      return resolve(r);\n      // if(pao.pa_isArray(r) && r.length > 0 && query.length !== 1 ){\n      //     if(find.alias){\n      //       if(result instanceof Array){\n      //         self.infoSync('THE RESULT TO BE CONVERTED TO OBJECT')\n      //         self.infoSync(find.alias)\n      //         result = {[find.alias]: [...r]}\n      //         self.infoSync(result)\n      //       }else{\n      //         self.infoSync('THE RESULT OBJECT IS TYPE OBJECT')\n      //         self.infoSync(result)\n      //         result[find.alias] = [...r]\n      //       }\n      //     }else{\n      //       r = [...r];\n      //       result.push(r)\n      //     }\n      //   }else{\n      //     result = r\n      //   }\n    });\n  });\n};\nconst updateOne = function (updatiks) {\n  const self = this;\n  self.pao.pa_wiLog(\"THE UPDATIKS\");\n  self.pao.pa_wiLog(updatiks);\n  self.infoSync(\"THE UPDATIKS\");\n  self.infoSync(updatiks.update);\n  const pao = self.pao;\n  let conn = updatiks.conn;\n  let connector = updatiks.connector;\n  let handler = updatiks.outComehandler;\n  let update = {\n    table: updatiks.table,\n    ...updatiks.query\n  };\n  //self.pao.pa_wiLog(update)\n  // eslint-disable-next-line no-empty\n  if (!pao.pa_isObject(updatiks)) {} else {\n    try {\n      let sql = \"\";\n      let attribs = null;\n      let sqliks = self.queryTemplate(self.queryOptions(update), \"update\");\n      self.pao.pa_wiLog(\"THE SQLKIKS OBJECT UPDATE\");\n      self.pao.pa_wiLog(sqliks);\n      attribs = [sqliks.attribs.from.table];\n      sql = sqliks.statement;\n      let queryAttributes = attribs;\n      self.pao.pa_wiLog(\"THE SQL BEFORE FORMAT\");\n      self.pao.pa_wiLog(sql);\n      // self.infoSync('THE CONNECTION METHODS')\n      // self.infoSync(conn)\n      sql = connector.format(sql, queryAttributes);\n      self.pao.pa_wiLog(sql);\n      self.infoSync(\"THE UPDATE SQL\");\n      self.infoSync(sql);\n      conn.query(sql, function (e, r) {\n        if (e) handler(e, null);\n        updatiks.update ? handler(null, r, updatiks.update) : handler(null, r);\n      });\n    } catch (e) {\n      handler(e, null);\n    }\n  }\n};\nconst updateMany = function (update) {\n  const self = this;\n  const pao = self.pao;\n  // eslint-disable-next-line no-empty, no-undef\n  if (!pao.pa_isObject(data)) {} else {\n    try {\n      let sql = `UPDATE TABLE ?? SET ?? WHERE ??`;\n      let result = [];\n      // eslint-disable-next-line no-unused-vars\n      let fullImplement = true;\n      update.bulk.forEach(updateItem => {\n        let queryAttributes = [update.table, [...update.fields], update.condition];\n        // eslint-disable-next-line no-undef\n        sql = connector.format(sql, queryAttributes);\n        // eslint-disable-next-line no-undef\n        conn.query(sql, updateItem, function (e, r) {\n          if (e) {\n            fullImplement = false;\n          } else {\n            result.push(r);\n          }\n        });\n      });\n      self.pao.pa_wiLog(\"bulk update completed\");\n      // eslint-disable-next-line no-undef\n      handler(null, result);\n    } catch (e) {\n      // eslint-disable-next-line no-undef\n      handler(e, null);\n    }\n  }\n};\nconst updateandtake = async function (updateAndTake) {\n  const self = this;\n  self.pao.pa_wiLog(\"THE UPDATIKANDTAKE\");\n  self.pao.pa_wiLog(updateAndTake);\n  const pao = self.pao;\n  let conn = updateAndTake.conn;\n  let connector = updateAndTake.connector;\n  let handler = updateAndTake.outComehandler;\n  let updateTake = updateAndTake.query;\n  //self.pao.pa_wiLog(update)\n  // eslint-disable-next-line no-empty\n  if (!pao.pa_isObject(updateAndTake)) {} else {\n    try {\n      let options = await self.searchOptions(updateTake, true);\n      self.multiTableUpdate(options, conn, connector).then(updated => {\n        if (updated.changedRows > 0) {\n          self.take(options, conn, updateTake.conditions, connector).then(taken => {\n            // updated.changedRows > 0 ? handler(null,{updated: true,taken: taken}) : ''\n            handler(null, {\n              updated: true,\n              taken: taken\n            });\n          }).catch(e => {\n            handler(e, null);\n          });\n        } else {\n          // handler({updated: false,taken: taken})\n          self.pao.pa_wiLog(\"NO CHANGED ROWS IN A MULTIPLE UPDATE\");\n          self.pao.pa_wiLog(options);\n          self.take(options, conn, updateTake.conditions, connector).then(taken => {\n            handler(null, {\n              updated: false,\n              taken: taken\n            });\n          }).catch(e => {\n            handler(e, null);\n          });\n          //\n          // {\n          //   tables:['jo_user','jo_pao.pa_wiLogin'],\n          //   joins: 2,\n          //   joinPoints: ['jo_user.id EQUALS jo_pao.pa_wiLogin.id'],\n          //   conditions: [`jo_user.id EQUALS 1`,`AND jo_pao.pa_wiLogin.u_id EQUALS 1`],\n          //   opiks: ['field.first_name.as[firstName]','field.last_name.as[lastName]',\n          //   set: [{first_name: 'Surprise',last_name: 'Mashele'},{password: '1234567'}],\n          //   takeFrom: 'jo_user'\n          //  }\n        }\n      }).catch(e => {\n        handler(e, null);\n      });\n    } catch (e) {\n      handler(e, null);\n    }\n  }\n};\nconst insertandtake = async function (insertAndTake) {\n  const self = this;\n  self.pao.pa_wiLog(\"THE INSERTANDTAKE\");\n  self.pao.pa_wiLog(insertAndTake);\n  // self.infoSync('THe insertAnd Take')\n  // self.infoSync(insertAndTake)\n  const pao = self.pao;\n  let conn = insertAndTake.conn;\n  let handler = insertAndTake.outComehandler;\n  let insert = insertAndTake.query.insert;\n  let takeQuery = insertAndTake.query.take;\n  let connector = insertAndTake.connector;\n  //self.pao.pa_wiLog(update)\n  // eslint-disable-next-line no-empty\n  if (!pao.pa_isObject(insertAndTake)) {} else {\n    try {\n      let insertTakeHandle = async function (error = null, inserted = null) {\n        await self.pao.pa_wiLog(\"THE INSERTED RECORD UPDATE\");\n        await self.pao.pa_wiLog(error);\n        await self.pao.pa_wiLog(inserted);\n        await self.pao.pa_wiLog(self.SEARCH);\n        !takeQuery.conditions ? takeQuery.conditions = [`id ISEQUAL ${inserted.insertId}`] : \"\";\n        await self.pao.pa_wiLog(takeQuery);\n        let take = {};\n        take.conn = conn;\n        take.query = takeQuery;\n        take.connector = connector;\n        // eslint-disable-next-line no-unused-vars\n        take.outComehandler = (e = null, taken) => {\n          handler(null, {\n            inserted: inserted,\n            taken: taken\n          });\n        };\n        self.infoSync(\"INSERTANDTAKE TAKING\");\n        self.infoSync(take);\n        self.search(take);\n        // throw new Error('MADE UP ERROR')\n        //  self.SEARCH(take)\n      };\n      insert.outComehandler = insertTakeHandle.bind(self);\n      insert.conn = conn;\n      insert.connector = connector;\n      insert.query = {\n        fields: [...insert.fields],\n        values: [...insert.values]\n      };\n      self.insertOne(insert);\n    } catch (e) {\n      handler(e, null);\n    }\n  }\n};\nconst deleteandtake = async function (deleteAndTake) {\n  const self = this;\n  self.pao.pa_wiLog(\"THE DELETEANDTAKE\");\n  self.pao.pa_wiLog(deleteAndTake);\n  const pao = self.pao;\n  let conn = deleteAndTake.conn;\n  let handler = deleteAndTake.outComehandler;\n  let connector = deleteAndTake.connector;\n  let remove = null;\n  let takeQuery = null;\n  if (deleteAndTake.query.remove) {\n    remove = deleteAndTake.query.remove;\n    takeQuery = deleteAndTake.query.take;\n  }\n  //self.pao.pa_wiLog(update)\n  // eslint-disable-next-line no-empty\n  if (!pao.pa_isObject(deleteAndTake)) {} else {\n    try {\n      let deleteTakeHandle = async function (error = null, deleted = null) {\n        await self.pao.pa_wiLog(\"THE deleted RECORD UPDATE\");\n        await self.pao.pa_wiLog(error);\n        await self.pao.pa_wiLog(deleted);\n        if (!takeQuery) {\n          handler(null, {\n            deleted: deleted\n          });\n        } else {\n          !takeQuery.conditions ? takeQuery.conditions = remove.conditions : \"\";\n          await self.pao.pa_wiLog(takeQuery);\n          let take = {};\n          take.conn = conn;\n          take.connector = connector;\n          take.query = takeQuery;\n          // eslint-disable-next-line no-unused-vars\n          take.outComehandler = (e = null, taken) => {\n            self.pao.pa_wiLog(\"DELETED AND TAKEN OPERATION\");\n            self.pao.pa_wiLog(deleted);\n            self.pao.pa_wiLog(taken);\n            handler(null, {\n              deleted: deleted,\n              taken: taken\n            });\n          };\n          self.search(take);\n        }\n        // throw new Error('MADE UP ERROR')\n        //  self.SEARCH(take)\n      };\n      if (!remove) remove = deleteAndTake.query;\n      remove.outComehandler = deleteTakeHandle.bind(self);\n      remove.conn = conn;\n      remove.connector = connector;\n      self.removeJoin(remove);\n    } catch (e) {\n      handler(e, null);\n    }\n  }\n};\nconst updateJoinTemplate = function (options) {\n  // `UPDATE ??\n  // SET ${options.set}\n  // WHERE ${options.from.condition}\n  // `\n  const self = this;\n  self.pao.pa_wiLog(\"UPDATE OPTIONS\");\n  self.pao.pa_wiLog(options);\n  let sqlAttribs = {};\n  sqlAttribs.attribs = {\n    from: options.from,\n    tables: options.tables\n  };\n  switch (options.length) {\n    case 2:\n      sqlAttribs.statement = `UPDATE ??\n                            JOIN ${options.tables[0]}\n                              ON ${options.joinPoints[0]}\n                            SET ${options.set}\n                            WHERE ${options.from.condition}\n                            `;\n      break;\n    case 3:\n      sqlAttribs.statement = `UPDATE ??,??,??\n                              JOIN ${options.tables[0]}\n                                ON ${options.conditions[0]}\n                              JOIN ${options.tables[1]}\n                                ON ${options.conditions[1]}\n                              SET ${options.set}\n                              WHERE ${options.from.condition}\n                              \n                              `;\n      break;\n    case 4:\n      sqlAttribs.statement = `UPDATE ??,??,??,??\n                            JOIN ${options.tables[0]}\n                              ON ${options.conditions[0]}\n                            JOIN ${options.tables[1]}\n                              ON ${options.conditions[1]}\n                            JOIN ${options.tables[2]}\n                            ON ${options.conditions[2]}\n                            SET ${options.set}\n                            WHERE ${options.from.condition}\n                            \n                            `;\n      break;\n    default:\n      sqlAttribs.statement = `UPDATE ??\n                            SET ${options.set}\n                            WHERE ${options.from.condition}\n                            \n                            `;\n  }\n  return sqlAttribs;\n};\nconst multiTableUpdate = async function (options, conn, connector) {\n  const self = this;\n  const pao = self.pao;\n  const contains = pao.pa_contains;\n  return new Promise((resolve, reject) => {\n    try {\n      // self.pao.pa_wiLog('THE SQLKIKS OBJECT UPDATE')\n      // self.pao.pa_wiLog(sqliks)\n      // attribs = [sqliks.attribs.from.table]\n      let sql = \"\";\n      let attribs = null;\n      let sqliks = self.updateJoinTemplate(options);\n      self.pao.pa_wiLog(\"THE SQLKIKS OBJECT\");\n      self.pao.pa_wiLog(sqliks);\n      contains(sqliks.attribs, \"tables\") && sqliks.attribs.tables ? attribs = [sqliks.attribs.from.table, ...sqliks.attribs.tables] : attribs = [sqliks.attribs.from.table];\n      sql = sqliks.statement;\n      let queryAttributes = attribs;\n      self.pao.pa_wiLog(\"THE SQL BEFORE FORMAT::MULTIUPDATE\");\n      self.pao.pa_wiLog(sql);\n      sql = connector.format(sql, queryAttributes);\n      self.pao.pa_wiLog(sql);\n      conn.query(sql, function (e, r) {\n        if (e) return reject(e);\n        resolve(r);\n      });\n    } catch (e) {\n      reject(e);\n    }\n  });\n};\nconst take = async function (options, conn, conditions, connector) {\n  const self = this;\n  self.pao.pa_wiLog(\"TAKE:::\");\n  self.pao.pa_wiLog(options);\n  return new Promise((resolve, reject) => {\n    if (options.takeFrom) {\n      let takeFrom = options.takeFrom;\n      self.pao.pa_wiLog(\"THE TAKEFROM BY TAKEFROM\");\n      self.pao.pa_wiLog(takeFrom);\n      if (takeFrom.condition) {\n        self.pao.pa_wiLog(\"THE TAKEFROM CONDITIION IS SET\");\n        options.from.condition = takeFrom.condition;\n        takeFrom.tables.length > 1 ? options.length = takeFrom.tables.length : \"\";\n        options.length ? takeFrom.joinPoints ? options.joinPoints = takeFrom.joinPoints : \"\" : \"\";\n        self.takeSql(options, conn, connector).then(resultset => {\n          resolve(resultset);\n        }).catch(e => {\n          reject(e);\n        });\n      } else {\n        self.pao.pa_wiLog(\"THE TAKEFROM HAS NO SET CONDITIONS\");\n        self.pao.pa_wiLog(options);\n        delete options.length;\n        options.from.condition = self.searchConditionsFormat([conditions[0]]);\n        // options.tables = options.tables[0]\n        self.takeSql(options, conn, connector).then(resultset => {\n          resolve(resultset);\n        }).catch(e => {\n          reject(e);\n        });\n      }\n    } else {\n      self.pao.pa_wiLog(\"THE TAKEFROM IS NOT DEFINED\");\n      self.takeSql(options, conn, connector).then(resultset => {\n        resolve(resultset);\n      }).catch(e => {\n        reject(e);\n      });\n    }\n  });\n};\nconst takeSql = function (takeOptions, conn, connector) {\n  const self = this;\n  const pao = self.pao;\n  const contains = pao.pa_contains;\n  self.pao.pa_wiLog(\"THE SEARCH\");\n  self.pao.pa_wiLog(search);\n  return new Promise(function (resolve, reject) {\n    // do a thing, possibly async, then…\n    self.pao.pa_wiLog(\"Executing the search promise\");\n    let sql = \"\";\n    let attribs = null;\n    let sqliks = self.searchStatement(takeOptions);\n    self.pao.pa_wiLog(\"THE SQLKIKS OBJECT\");\n    self.pao.pa_wiLog(sqliks);\n    contains(sqliks.attribs, \"tables\") ? attribs = [sqliks.attribs.from.table, ...sqliks.attribs.tables] : attribs = [sqliks.attribs.from.table];\n    sql = sqliks.statement;\n    let queryAttributes = attribs;\n    self.pao.pa_wiLog(\"THE SQL BEFORE FORMAT::\");\n    self.pao.pa_wiLog(sql);\n    // self.pao.pa_wiLog(conn)\n    sql = connector.format(sql, queryAttributes);\n    self.pao.pa_wiLog(sql);\n    conn.query(sql, function (e, r) {\n      if (e) {\n        self.pao.pa_wiLog(\"Promise is rejecting search\");\n        self.pao.pa_wiLog(e);\n        reject(e);\n      } else {\n        self.pao.pa_wiLog(\"Promise is Resolving search\");\n        self.pao.pa_wiLog(r);\n        self.pao.pa_wiLog(r[0]);\n        resolve(r);\n      }\n    });\n  });\n};\nconst removeJoin = function (removiks) {\n  const self = this;\n  const pao = self.pao;\n  const contains = pao.pa_contains;\n  let conn = removiks.conn;\n  let connector = removiks.connector;\n  let handler = removiks.outComehandler;\n  // let remove = {table: removiks.table,...removiks.query}\n  // eslint-disable-next-line no-empty\n  if (!pao.pa_isObject(removiks)) {} else {\n    try {\n      let sql = \"\";\n      let attribs = null;\n      let sqliks = self.queryTemplate(self.searchOptions(removiks), \"delete\");\n      self.pao.pa_wiLog(\"THE SQLKIKS OBJECT DELETEDANDTAKE[REMOVE]\");\n      self.pao.pa_wiLog(sqliks);\n      contains(sqliks.attribs, \"tables\") ? attribs = [...sqliks.attribs.tables, sqliks.attribs.from.table] : attribs = [sqliks.attribs.from.table];\n      sql = sqliks.statement;\n      let queryAttributes = attribs;\n      self.pao.pa_wiLog(\"THE SQL BEFORE FORMAT\");\n      self.pao.pa_wiLog(sql);\n      sql = connector.format(sql, queryAttributes);\n      self.pao.pa_wiLog(sql);\n      conn.query(sql, function (e, r) {\n        if (e) return handler(e, null);\n        handler(null, r);\n      });\n    } catch (e) {\n      handler(e, null);\n    }\n  }\n};\nconst remove = function (removiks) {\n  const self = this;\n  const pao = self.pao;\n  let conn = removiks.conn;\n  let connector = removiks.connector;\n  let handler = removiks.outComehandler;\n  let remove = {\n    table: removiks.table,\n    ...removiks.query\n  };\n  // eslint-disable-next-line no-empty\n  if (!pao.pa_isObject(removiks)) {} else {\n    try {\n      let sql = \"\";\n      let attribs = null;\n      let sqliks = self.queryTemplate(self.queryOptions(remove), \"delete\");\n      self.pao.pa_wiLog(\"THE SQLKIKS OBJECT DELETED[REMOVE]\");\n      self.pao.pa_wiLog(sqliks);\n      attribs = [sqliks.attribs.from.table];\n      sql = sqliks.statement;\n      let queryAttributes = attribs;\n      self.pao.pa_wiLog(\"THE SQL BEFORE FORMAT\");\n      self.pao.pa_wiLog(sql);\n      sql = connector.format(sql, queryAttributes);\n      self.pao.pa_wiLog(sql);\n      conn.query(sql, function (e, r) {\n        if (e) handler(e, null);\n        return removiks.delete ? handler(null, r, removiks.delete) : handler(null, r);\n        // handler(null,r)\n      });\n    } catch (e) {\n      handler(e, null);\n    }\n  }\n};\nconst queryOptions = function (i) {\n  const self = this;\n  self.pao.pa_wiLog(\"THE search BATCH ITEM\");\n  self.pao.pa_wiLog(i);\n  let pao = self.pao;\n  let contains = pao.pa_contains;\n  // let rest = {\n  // \tconditions: [`country_id EQUALS 202`],\n  // \topiks: ['field.id.as[stateId]','field.state_name.as[state]','field.country_id.as[countryId]'],\n  // \tsort: 'order[state_name].asc',\n  // \trange: '2,5',\n  // \ttake: 5\n  //   }\n  let options = {};\n  i.conditions ? options.from = {\n    table: i.table,\n    condition: self.searchConditionsFormat(i.conditions)\n  } : options.from = {\n    table: i.table\n  };\n  self.pao.pa_wiLog(\"THE CODE GETS HERE\");\n  self.pao.pa_wiLog(options);\n  contains(i, [\"returnFields\", \"opiks\"]) ? options.fields = self.searchFieldsFormat(i.opiks, i.returnFields) : contains(i, \"opiks\") ? options.fields = self.searchFieldsFormat(i.opiks) : contains(i, \"returnFields\") ? i.returnFields.length === 1 && i.returnFields[0].trim() === \"all\" ? options.fields = \"*\" : options.fields = i.returnFields : options.fields = \"*\";\n  contains(i, \"take\") ? options.take = i.take : \"\";\n  contains(i, \"range\") ? options.range = i.range : \"\";\n  contains(i, \"sort\") ? options.sort = i.sort : \"\";\n  contains(i, \"set\") ? options.set = self.set(i.set) : \"\";\n  contains(i, \"takeFrom\") ? i.takeFrom.conditions ? (options.takeFrom = i.takeFrom, options.takeFrom.condition = self.searchConditionsFormat(i.takeFrom.conditions)) : options.takeFrom = i.takeFrom : \"\";\n  self.pao.pa_wiLog(\"THE OPTIONS\");\n  self.pao.pa_wiLog(options);\n  return options;\n};\nconst queryTemplate = function (options, type) {\n  const self = this;\n  const pao = self.pao;\n  const contains = pao.pa_contains;\n  self.pao.pa_wiLog(\"THE QUERY TEMPLATE\");\n  self.pao.pa_wiLog(options);\n  if (type === \"select\") {\n    let sqlAttribs = {};\n    sqlAttribs.attribs = {\n      from: options.from\n    };\n    let limit = \" \";\n    let sort = options.sort ? self.sort(options.sort) : \" \";\n    options.take ? limit = self.limit(options.take, \"take\") : options.range ? limit = self.limit(options.range, \"range\") : \" \";\n    if (contains(options.from, \"condition\")) {\n      sqlAttribs.statement = `SELECT ${options.fields}\n                              FROM  ??\n                              WHERE ${options.from.condition}\n                              ${sort}\n                              ${limit}\n\n                              `;\n    } else {\n      sqlAttribs.statement = `SELECT ${options.fields}\n                              FROM  ??\n                              ${sort}\n                              ${limit}\n                              `;\n    }\n    return sqlAttribs;\n  } else if (type === \"update\") {\n    let sqlAttribs = {};\n    sqlAttribs.attribs = {\n      from: options.from\n    };\n    sqlAttribs.statement = `UPDATE ??\n                            SET ${options.set}\n                            WHERE ${options.from.condition}\n                            `;\n    return sqlAttribs;\n  } else if (type === \"delete\") {\n    if (options.length) {\n      let sqlAttribs = {};\n      sqlAttribs.attribs = {\n        from: options.from,\n        tables: options.tables\n      };\n      options.tables.unshift(options.from.table);\n      self.pao.pa_wiLog(\"DELETE OPTIONS OBJECT\");\n      self.pao.pa_wiLog(options);\n      self.pao.pa_wiLog(options.tables);\n      self.pao.pa_wiLog(options.length);\n      switch (options.length) {\n        case 3:\n          sqlAttribs.statement = `DELETE ??,??,??\n                                  FROM ??\n                                  JOIN ${options.tables[1]}\n                                    ON ${options.joinPoints[0]}\n                                  JOIN ${options.tables[2]}\n                                    ON ${options.joinPoints[1]}\n                                  WHERE ${options.from.condition}\n                                  \n                                  `;\n          break;\n        case 4:\n          sqlAttribs.statement = `DELETE ??,??,??,??\n                                FROM ??\n                                JOIN ${options.tables[1]}\n                                  ON ${options.joinPoints[0]}\n                                JOIN ${options.tables[2]}\n                                  ON ${options.joinPoints[1]}\n                                JOIN ${options.tables[3]}\n                                ON ${options.joinPoints[3]}\n                                WHERE ${options.from.condition}\n                                \n                                `;\n          break;\n        default:\n          sqlAttribs.statement = `DELETE ??,??\n                                  FROM ??\n                                  JOIN ${options.tables[1]}\n                                    ON ${options.joinPoints[0]}\n                                  WHERE ${options.from.condition}\n                                  \n                                  `;\n      }\n      self.pao.pa_wiLog(\"SQL ATTRRIBS\");\n      self.pao.pa_wiLog(sqlAttribs);\n      return sqlAttribs;\n    } else {\n      let sqlAttribs = {};\n      sqlAttribs.attribs = {\n        from: options.from\n      };\n      sqlAttribs.statement = `DELETE\n                                FROM ??\n                                `;\n      options.from.condition ? sqlAttribs.statement += ` WHERE ${options.from.condition}` : \"\";\n      return sqlAttribs;\n    }\n  }\n};\nconst transaction = function (data) {\n  const self = this;\n  if (typeof data.query === \"function\") {\n    data.query();\n  } else {\n    self.TRANSACTION(data.query, data.conn, data.outComehandler, data.connector);\n  }\n};\nconst procedure = function (data) {\n  const self = this;\n  self.pao.pa_wiLog(\"THE procedure got a call\");\n  if (typeof data.query === \"function\") {\n    data.query();\n  } else {\n    self.pao.pa_wiLog(\"INSIDE PROCEDURE\");\n    //  self.pao.pa_wiLog(data.outComehandler)\n    //  self.pao.pa_wiLog(data)\n    self.PROCEDURE(data.query, data.conn, data.outComehandler, data.connector);\n  }\n};\nconst join = function (data) {\n  const self = this;\n  self.pao.pa_wiLog(\"THE procedure got a call\");\n  if (typeof data.query === \"function\") {\n    data.query();\n  } else {\n    self.pao.pa_wiLog(\"INSIDE JOIN\");\n    //  self.pao.pa_wiLog(data.outComehandler)\n    //  self.pao.pa_wiLog(data)\n    self.JOIN(data.query, data.conn, data.outComehandler);\n  }\n};\nconst search = function (data) {\n  const self = this;\n  self.pao.pa_wiLog(\"THE search got a call\");\n  if (typeof data.query === \"function\") {\n    data.query();\n  } else {\n    self.pao.pa_wiLog(\"INSIDE SEARCH\");\n    //  self.pao.pa_wiLog(data.outComehandler)\n    //  self.pao.pa_wiLog(data)\n    self.SEARCH(data.query, data.conn, data.outComehandler, data.connector);\n  }\n};\nconst TRANSACTION = function (collections, conn, handler = null, connector) {\n  const self = this;\n  const pao = self.pao;\n  let collectionsIds = [];\n  let breakOut = false;\n  for (let c = 0; c < collections.length; c++) {\n    let i = collections[c];\n    let fields = null;\n    let sources = null;\n    let own = null;\n    if (!pao.pa_contains(i, \"fields\")) {\n      handler(\"Required collection/table field missing\");\n      break;\n    } else {\n      if (pao.pa_contains(i.fields, \"tables\")) {\n        sources = i.fields.tables;\n        own = i.fields.own;\n      }\n    }\n    sources ? fields = self.combineFields(sources, own, collectionsIds) : \"\";\n    fields ? i.fields = fields : \"\";\n    self.insert(i, conn, connector).then(insert => {\n      collectionsIds.push(insert);\n    }).catch(failedInsert => {\n      self.rollback(collectionsIds);\n      handler(failedInsert, null);\n      breakOut = true;\n    });\n    if (breakOut) break;\n    if (c === collections.length - 1) {\n      self.pao.pa_wiLog(\"Operation completed successfully\");\n      handler(\"Transaction Operation sucessful\");\n    }\n  }\n};\nconst PROCEDURE = async function (collections, conn, handler = null, connector) {\n  const self = this;\n  const pao = self.pao;\n  self.pao.pa_wiLog(\"THE PROCEDURE METHOD\");\n  self.pao.pa_wiLog(collections);\n  self.pao.pa_wiLog(handler);\n  //self.pao.pa_wiLog(conn)\n  let collectionsIds = [];\n  let breakOut = false;\n  conn.getConnection(async (err, connection) => {\n    self.infoSync(err);\n    if (err) throw new Error(\"There was an error getting a connection from the pool\");\n    for (let c = 0; c < collections.length; c++) {\n      let i = collections[c];\n      let fields = null;\n      let sources = null;\n      let own = null;\n      let action = null;\n      let dictionary = null;\n      self.infoSync(\"tHE FIELDS AND Tables from afar\");\n      self.infoSync(i);\n      self.infoSync(i.fields);\n      self.infoSync(i.tables);\n      if (!pao.pa_contains(i, \"fields\") && i.action && i.action !== \"delete\") {\n        handler(\"Required collection/table field missing\");\n        break;\n      } else {\n        if (pao.pa_contains(i.fields, \"tables\")) {\n          self.pao.pa_wiLog(\"sources will be assigned A VALUE\");\n          sources = i.fields.tables;\n          own = i.fields.own;\n        } else if (pao.pa_contains(i.fields, \"own\")) {\n          if (i.fields.own instanceof Array) {\n            let dicts = i.fields.own.map(doc => {\n              return {\n                ...doc\n              };\n            });\n            i.fields = dicts;\n          }\n        }\n      }\n      sources ? fields = self.combineFields(sources, own, collectionsIds) : \"\";\n      fields ? i.fields = fields : \"\";\n      i.action ? action = i.action : action = \"insert\";\n      i.dictionary ? dictionary = true : dictionary;\n      switch (action) {\n        case \"insert\":\n          {\n            await self.insert(i, connection, connector).then(insert => {\n              collectionsIds.push(insert);\n            }).catch(failedInsert => {\n              handler(failedInsert, null);\n              breakOut = true;\n            });\n          }\n          break;\n        case \"update\":\n          {\n            await self.procedureUpdate(i, connection, connector).then(update => {\n              self.infoSync(\"THE UPDATED\");\n              collectionsIds.push(update);\n            }).catch(failedUpdate => {\n              handler(failedUpdate, null);\n              breakOut = true;\n            });\n          }\n          break;\n        case \"delete\":\n          {\n            await self.procedureDelete(i, connection, connector).then(deleted => {\n              self.infoSync(\"THE DELETED\");\n              collectionsIds.push(deleted);\n            }).catch(failedDelete => {\n              handler(failedDelete, null);\n              breakOut = true;\n            });\n          }\n          break;\n        case \"select\":\n          {\n            await self.procedureSelect(i, connection, connector).then(selected => {\n              self.infoSync(\"THE DELETED\");\n              collectionsIds.push(selected);\n            }).catch(failedSelect => {\n              handler(failedSelect, null);\n              breakOut = true;\n            });\n          }\n          break;\n        default:\n          throw new Error(\"No valid table procedure action has been defined\");\n      }\n      // await self.insert(i,conn)\n      // .then((insert)=>{\n      //     collectionsIds.push(insert)\n      // })\n      // .catch((failedInsert)=>{\n      //       handler(failedInsert,null)\n      //       breakOut = true\n      // })\n      if (breakOut) break;\n      if (c === collections.length - 1) {\n        self.pao.pa_wiLog(\"Operation completed successfully\");\n        self.pao.pa_wiLog(collectionsIds);\n        connection.release();\n        if (collectionsIds.length > 0) {\n          self.pao.pa_wiLog(\"PROCEDURE IS COMPLETED\");\n          self.pao.pa_wiLog(collectionsIds);\n          let savedData = null;\n          self.infoSync(\"THE COLLECTIONS\");\n          self.infoSync(collectionsIds);\n          self.infoSync(collectionsIds[0]);\n          // handler(null,{user:{username: collectionsIds[0].fields.email}})\n          if (collectionsIds[0].isDelete) {\n            savedData = collectionsIds.map(sd => {\n              return {\n                documentID: sd.collectionAlt,\n                document: {\n                  ...sd.fields\n                },\n                isDeleted: sd.isDeleted\n              };\n            });\n            return handler(null, {\n              user: savedData\n            });\n          } else if (collectionsIds[0].isUpdate || collectionsIds[0].collectionAlt) {\n            savedData = collectionsIds.map(sd => {\n              return {\n                documentID: sd.collectionAlt,\n                document: {\n                  ...sd.fields\n                },\n                isUpdated: sd.isUpdated\n              };\n            });\n            return handler(null, {\n              user: savedData\n            });\n          } else {\n            return handler(null, {\n              user: collectionsIds[0].fields\n            });\n          }\n        } else {\n          return handler(\"An insert has went wrong\");\n        }\n      }\n    }\n  });\n};\nconst insert = function (inset, conn, connector) {\n  let self = this;\n  let pao = pao;\n  return new Promise(function (resolve, reject) {\n    // do a thing, possibly async, then…\n    self.pao.pa_wiLog(\"Executing the insert promise\");\n    self.infoSync(\"THE INSET\");\n    self.infoSync(inset);\n    let sql = \"\";\n    let queryAttributes = \"\";\n    let escaped = [];\n    let sqlValues = ``;\n    let sqlKeys = `(`;\n    !inset.dictionary ? (sql = `INSERT INTO ?? SET ?`, queryAttributes = [inset.name, inset.fields], sql = connector.format(sql, queryAttributes)) : (\n    // eslint-disable-next-line no-unused-vars\n    escaped = inset.fields.map((di, i) => {\n      let values = Object.entries(di);\n      let escapedValues = {};\n      sqlValues += `(`;\n      values.forEach((v, ii) => {\n        i === 0 ? ii === values.length - 1 ? sqlKeys += `${v[0]}` : sqlKeys += `${v[0]},` : \"\";\n        escapedValues[v[0]] = conn.escape(v[1]);\n        if (ii === values.length - 1) {\n          //  i === 0 ? sqlKeys += `${v[0]}` : ''\n          sqlValues += `${escapedValues[v[0]]}`;\n        } else {\n          sqlValues += `${escapedValues[v[0]]},`;\n        }\n      });\n      if (i === inset.fields.length - 1) {\n        inset.fields.length === 1 ? sqlKeys += `)` : \"\";\n        sqlValues += `)`;\n      } else {\n        i === 0 ? sqlKeys += `)` : \"\";\n        sqlValues += `),`;\n      }\n      return escapedValues;\n    }), sql = `INSERT INTO ${inset.name} ${sqlKeys} VALUES ${sqlValues}`);\n    //     let sql = `INSERT INTO ?? SET ?`;\n    // let queryAttributes = [inset.name,inset.fields];\n    // sql = connector.format(sql, queryAttributes);\n    //  let sql = `INSERT INTO ${data.table} SET ?`\n    self.infoSync(\"THE SQL\");\n    self.infoSync(sql);\n    conn.query(sql, function (e, r) {\n      if (e) {\n        self.pao.pa_wiLog(\"Promise is rejecting\");\n        reject(e);\n      } else {\n        //{table: 'jo_job_alert',opiks: ['fuxin.count.options[*].as[alertsCount]'],conditions:[`u_id EQUALS ${uid}`]}\n        self.findOne({\n          conn: conn,\n          table: inset.name,\n          connector: connector,\n          //query:{user:{id: r.insertId}},\n          query: {\n            returnFields: [\"*\"],\n            conditions: [`id EQUALS ${r.insertId}`]\n          },\n          outComehandler: (e = null, r = null, data = null) => {\n            let insert = {};\n            if (e) {\n              self.pao.pa_wiLog(\"the errorINSERT\");\n              self.pao.pa_wiLog(e);\n              self.pao.pa_wiLog(data);\n              insert.error = e;\n              insert.lastInsert = data.query.user.id;\n              insert.fields = null;\n              insert.collection = data.table;\n              insert.collectionAlt = inset.altName ? inset.altName : \"\";\n              self.pao.pa_wiLog(\"Promise is Resolving with findOne error\");\n              self.pao.pa_wiLog(insert);\n              resolve(insert);\n            } else {\n              self.infoSync(\"THE RESULT FROM FIND\");\n              self.infoSync(r);\n              self.infoSync(r[0].email);\n              self.infoSync(inset.name);\n              let foundUser = r[0];\n              insert.lastInsert = foundUser.id;\n              insert.fields = {\n                ...foundUser\n              };\n              insert.collection = inset.name;\n              insert.collectionAlt = inset.altName ? inset.altName : \"\";\n              // throw new Error()\n              self.pao.pa_wiLog(\"Promise is Resolving with Find SUCCESS\");\n              self.pao.pa_wiLog(insert);\n              resolve(insert);\n            }\n          }\n        });\n      }\n    });\n  });\n};\nconst procedureUpdate = function (update, conn, connector) {\n  const self = this;\n  // self.infoSync('THE UPDATE IN PROCEDUREUPDATE')\n  // self.infoSync(update)\n  // let sets = Object.entries(update.fields)\n  // let set = sets.map((f,i)=>{})\n  return new Promise(function (resolve) {\n    self.updateOne({\n      conn,\n      connector,\n      update: update,\n      query: {\n        set: [...Object.entries(update.fields).map(f => {\n          return {\n            [f[0]]: f[1]\n          };\n        })],\n        conditions: [update.condition],\n        table: update.name\n      },\n      outComehandler: (e = null, r = null, data = null) => {\n        self.infoSync(\"THE UPDATE DATA\");\n        self.infoSync(data);\n        let update = {};\n        if (e) {\n          self.pao.pa_wiLog(\"the errorUDPATE\");\n          self.pao.pa_wiLog(e);\n          self.pao.pa_wiLog(data);\n          self.infoSync(\"THE ERROR\");\n          self.infoSync(e);\n          update.error = e;\n          update.fields = null;\n          update.collection = data.name;\n          update.collectionAlt = data.altName ? data.altName : \"\";\n          self.pao.pa_wiLog(\"Promise is Resolving with findOne error\");\n          self.pao.pa_wiLog(insert);\n          resolve(update);\n        } else {\n          self.infoSync(\"THE SUCCESS\");\n          self.infoSync(r);\n          // self.infoSync(data)\n          if (r.affectedRows && r.affectedRows > 0 || r.changedRows && r.changedRows > 0) {\n            self.infoSync(data.updateKeyID);\n            update.lastInsert = data.updateKey;\n            update.fields = data.updateKey && data.updateKeyID ? {\n              ...data.fields,\n              [data.updateKeyID]: data.updateKey\n            } : {\n              ...data.fields\n            };\n            update.collection = data.name;\n            update.collectionAlt = data.altName ? data.altName : \"\";\n            update.affectedRows = r.affectedRows;\n            update.isUpdate = true;\n            update.isUpdated = true;\n          } else {\n            update.lastInsert = data.updateKey;\n            // update.fields = {...data.fields,[data.updateKeyID]: data.updateKey}\n            update.fields = data.updateKey && data.updateKeyID ? {\n              ...data.fields,\n              [data.updateKeyID]: data.updateKey\n            } : {\n              ...data.fields\n            };\n            update.collection = data.name;\n            update.collectionAlt = data.altName ? data.altName : \"\";\n            update.affectedRows = 0;\n            update.isUpdate = true;\n            update.isUpdated = false;\n          }\n          self.pao.pa_wiLog(\"Promise is Resolving with FindOne SUCCESS\");\n          self.pao.pa_wiLog(update);\n          resolve(update);\n        }\n      }\n    });\n  });\n};\nconst procedureDelete = function (toDelete, conn, connector) {\n  const self = this;\n  // self.infoSync('THE UPDATE IN PROCEDUREUPDATE')\n  // self.infoSync(update)\n  // let sets = Object.entries(update.fields)\n  // let set = sets.map((f,i)=>{})\n  return new Promise(function (resolve) {\n    self.remove({\n      conn,\n      connector,\n      delete: toDelete,\n      query: {\n        conditions: [toDelete.condition],\n        table: toDelete.name\n      },\n      outComehandler: (e = null, r = null, data = null) => {\n        let update = {};\n        if (e) {\n          self.pao.pa_wiLog(\"the errorDelete\");\n          self.pao.pa_wiLog(e);\n          self.pao.pa_wiLog(data);\n          self.infoSync(\"THE ERROR\");\n          self.infoSync(e);\n          update.error = e;\n          update.fields = null;\n          update.collection = data.name;\n          update.collectionAlt = data.altName ? data.altName : \"\";\n          self.pao.pa_wiLog(\"Promise is Resolving with findOne error\");\n          self.pao.pa_wiLog(insert);\n          resolve(update);\n        } else {\n          self.infoSync(\"THE DELETE SUCCESS\");\n          self.infoSync(r);\n          // self.infoSync(data)\n          if (r.affectedRows && r.affectedRows > 0) {\n            // update.fields = {...data.fields}\n            update.collection = data.name;\n            update.collectionAlt = data.altName ? data.altName : \"\";\n            update.fields = {\n              ...data.fields\n            };\n            update.isDelete = true;\n            update.isDeleted = true;\n          } else {\n            // update.fields = {...data.fields,[data.updateKeyID]: data.updateKey}\n            // update.fields = {...data.fields}\n            update.collection = data.name;\n            update.collectionAlt = data.altName ? data.altName : \"\";\n            update.isDelete = true;\n            update.isDeleted = false;\n          }\n          self.pao.pa_wiLog(\"Promise is Resolving with FindOne SUCCESS\");\n          self.pao.pa_wiLog(update);\n          resolve(update);\n        }\n      }\n    });\n  });\n};\nconst procedureSelect = function (select, conn, connector) {\n  const self = this;\n  // self.infoSync('THE UPDATE IN PROCEDUREUPDATE')\n  // self.infoSync(update)\n  // let sets = Object.entries(update.fields)\n  // let set = sets.map((f,i)=>{})\n  return new Promise(function (resolve) {\n    self.find({\n      conn: conn,\n      select: select,\n      table: select.name,\n      connector: connector,\n      //query:{user:{id: r.insertId}},\n      query: {\n        returnFields: select.fields,\n        conditions: select.conditions\n      },\n      outComehandler: (e = null, r = null, data = null) => {\n        let select = {};\n        if (e) {\n          self.pao.pa_wiLog(\"the errorINSERT\");\n          self.pao.pa_wiLog(e);\n          self.pao.pa_wiLog(data);\n          select.error = e;\n          select.lastInsert = data.query.user.id;\n          select.fields = null;\n          select.collection = data.table;\n          self.pao.pa_wiLog(\"Promise is Resolving with findOne error\");\n          self.pao.pa_wiLog(insert);\n          resolve(insert);\n        } else {\n          self.infoSync(\"THE RESULT FROM FIND\");\n          self.infoSync(r);\n          self.infoSync(r[0].email);\n          self.infoSync(select.name);\n          let foundUser = r[0];\n          select.lastInsert = foundUser.id;\n          select.fields = {\n            ...foundUser\n          };\n          select.collection = select.name;\n          // throw new Error()\n          self.pao.pa_wiLog(\"Promise is Resolving with Find SUCCESS\");\n          self.pao.pa_wiLog(select);\n          resolve(select);\n        }\n      }\n    });\n  });\n};\nconst JOIN = async function (join, conn, handler = null) {\n  const self = this;\n  self.joinExek(join, conn).then(result => {\n    self.pao.pa_wiLog(\"jOIN is successful, sending results to the requester\");\n    self.pao.pa_wiLog(result);\n    handler(null, result);\n  }).catch(failedRequest => {\n    self.pao.pa_wiLog(\"JOIN FAILED\");\n    self.pao.pa_wiLog(failedRequest);\n    handler(failedRequest, null);\n  });\n};\nconst SEARCH = async function (search, conn, handler = null, connector) {\n  const self = this;\n  const pao = self.pao;\n  self.pao.pa_wiLog(\"THE SEARCH search object contents\");\n  self.pao.pa_wiLog(search);\n  if (!pao.pa_contains(search, \"batch\")) {\n    self.searchExek(search, conn, connector).then(result => {\n      self.pao.pa_wiLog(\"search is successful, sending results to the requester\");\n      // self.pao.pa_wiLog(result)\n      handler(null, result);\n    }).catch(failedRequest => {\n      self.pao.pa_wiLog(\"search FAILED\");\n      self.pao.pa_wiLog(failedRequest);\n      handler(failedRequest, null);\n    });\n  } else {\n    let resultSet = [];\n    let batch = search.search;\n    for (let s = 0; s < batch.length; s++) {\n      await self.searchExek(batch[s], conn, connector).then(result => {\n        self.pao.pa_wiLog(\"search is successful, pushing results to the resultSet\");\n        // self.pao.pa_wiLog(result)\n        resultSet.push(result);\n        if (s === batch.length - 1) {\n          self.pao.pa_wiLog(\"Operation completed successfully\");\n          // self.pao.pa_wiLog(resultSet)\n          handler(null, resultSet);\n        }\n        // handler(null,result)\n      }).catch(failedRequest => {\n        self.pao.pa_wiLog(\"search FAILED\");\n        self.pao.pa_wiLog(failedRequest);\n        resultSet.push({\n          item: s,\n          errorMessage: `Item of ${s} position has failed`,\n          error: failedRequest\n        });\n        // handler(failedRequest,null)\n      });\n    }\n  }\n};\nconst combineFields = function (tables, own, ids) {\n  const self = this;\n  let fields = {};\n  self.pao.pa_wiLog(\"COMBINE FIELDS GETS A CALL\");\n  self.infoSync(\"THE TABLES\");\n  self.infoSync(tables);\n  self.infoSync(ids);\n  tables.forEach(v => {\n    for (let co = 0; co < ids.length; co++) {\n      if (ids[co].collection === v.name) {\n        v.values.forEach(vv => {\n          self.pao.pa_wiLog(\"THE VV\");\n          self.pao.pa_wiLog(vv);\n          let fieldValuePair = vv.split(\".\");\n          self.pao.pa_wiLog(\"FIELD VALUE PAIR\");\n          self.pao.pa_wiLog(fieldValuePair);\n          fields[fieldValuePair[1]] = ids[co].fields[fieldValuePair[0]];\n        });\n        break;\n      }\n    }\n  });\n  let keys = Object.keys(own);\n  self.pao.pa_wiLog(\"THE KEYS OF OWN\");\n  self.pao.pa_wiLog(keys);\n  self.infoSync(\"THE KEYS OF OWN\");\n  self.infoSync(keys);\n  if (own instanceof Array) {\n    let dictFields = own.map(docu => {\n      return {\n        ...fields,\n        ...docu\n      };\n    });\n    self.infoSync(\"THE DICTIONARY FIELDS\");\n    self.infoSync(dictFields);\n    return dictFields;\n  } else {\n    let keys = Object.keys(own);\n    self.pao.pa_wiLog(\"THE KEYS OF OWN\");\n    self.pao.pa_wiLog(keys);\n    self.infoSync(\"THE KEYS OF OWN\");\n    self.infoSync(keys);\n    keys.forEach(k => {\n      fields[k] = own[k];\n    });\n    self.pao.pa_wiLog(\"THE FIELDS\");\n    self.pao.pa_wiLog(fields);\n    self.infoSync(\"THE FIELDS\");\n    self.infoSync(fields);\n    return fields;\n  }\n};\nconst rollback = function (rolbacks) {\n  const self = this;\n  rolbacks.forEach(roll => {\n    // eslint-disable-next-line no-undef\n    self.deleteOne({\n      id: roll.lastInsert\n    }, conn);\n  });\n};\nconst joinExek = function (join, conn, connector) {\n  let self = this;\n  return new Promise(function (resolve, reject) {\n    // do a thing, possibly async, then…\n    self.pao.pa_wiLog(\"Executing the JOIN promise\");\n    let options = {\n      fields: join.returnFields,\n      from: {\n        table: join.tables[0],\n        condition: self.joinConditionsFormat(join.conditions)\n      },\n      joinPoints: self.joinConditionsFormat(join.joinPoints, \"ON\"),\n      tables: join.tables.splice(1, join.tables.length),\n      type: join.type.toUpperCase(),\n      length: join.joins\n    };\n    let sql = self.joinStatement(options);\n    let queryAttributes = [options.from.table, options.tables[0]];\n    self.pao.pa_wiLog(\"THE SQL BEFORE FORMAT\");\n    self.pao.pa_wiLog(sql);\n    sql = connector.format(sql, queryAttributes);\n    self.pao.pa_wiLog(sql);\n    conn.query(sql, function (e, r) {\n      if (e) {\n        self.pao.pa_wiLog(\"Promise is rejecting JOIN\");\n        self.pao.pa_wiLog(e);\n        reject(e);\n      } else {\n        self.pao.pa_wiLog(\"Promise is Resolving JOIN\");\n        self.pao.pa_wiLog(r);\n        self.pao.pa_wiLog(r[0]);\n        resolve(r[0]);\n      }\n    });\n  });\n};\nconst joinConditionsFormat = function (conditions, type = null) {\n  const self = this;\n  self.pao.pa_wiLog(\"CONDITIONS\");\n  self.pao.pa_wiLog(conditions);\n  if (type) {\n    let cons = conditions;\n    let condition = [];\n    cons.forEach(con => {\n      let conList = con.trim().split(\" \");\n      let operand = \"=\";\n      condition.push(`${conList[0]} ${operand} ${conList[2]}`);\n    });\n    self.pao.pa_wiLog(\"THE JOIN ON CONDITION\");\n    self.pao.pa_wiLog(condition);\n    return condition;\n  } else {\n    let cons = conditions;\n    let condition = \"\";\n    cons.forEach(con => {\n      self.pao.pa_wiLog(\"THE con ITEM\");\n      self.pao.pa_wiLog(con);\n      let conList = con.trim().split(\" \");\n      self.pao.pa_wiLog(\"THE CONLIST\");\n      self.pao.pa_wiLog(conList);\n      let operand = \"\";\n      switch (conList[1]) {\n        case \"EQUALS\":\n          operand = \"=\";\n          break;\n        case \"ISGREATEROREQUALS\":\n          operand = \">=\";\n          break;\n        case \"ISLESSOREQUALS\":\n          operand = \"<=\";\n          break;\n        default:\n          operand = \"=\";\n      }\n      condition += `${conList[0]} ${operand} '${conList[2]}'`;\n    });\n    self.pao.pa_wiLog(\"THE JOIN FROM CONDITION\");\n    self.pao.pa_wiLog(condition);\n    return condition.trim();\n  }\n};\nconst joinStatement = function (options) {\n  const self = this;\n  self.pao.pa_wiLog(\"THE JOIN OPTIONS\");\n  self.pao.pa_wiLog(options);\n  switch (options.length) {\n    case 3:\n      return `SELECT ${options.fields}\n               FROM ${options.from.table}\n               JOIN ${options.tables[0]}\n                  ON ${options.conditions[0]}\n               JOIN options.tables[1]\n                  ON ${options.conditions[1]}\n               WHERE ${options.from.condition}\n               \n               `;\n    case 4:\n      return `SELECT ${options.fields}\n               FROM ${options.from.table}\n               JOIN ${options.tables[0]}\n                  ON ${options.conditions[0]}\n               JOIN options.tables[1]\n                  ON ${options.conditions[1]}\n               JOIN options.tables[2]\n                  ON ${options.conditions[2]}\n               WHERE ${options.from.condition}\n               \n               `;\n    case 5:\n      return `SELECT ${options.fields}\n               FROM ${options.from.table}\n               JOIN ${options.tables[0]}\n                  ON ${options.conditions[0]}\n               JOIN options.tables[1]\n                  ON ${options.conditions[1]}\n               JOIN options.tables[2]\n                  ON ${options.conditions[2]} \n               JOIN options.tables[3]\n                  ON ${options.conditions[3]}\n               WHERE ${options.from.condition}\n               \n               `;\n    case 6:\n      return `SELECT ${options.fields}\n               FROM ${options.from.table}\n               JOIN ${options.tables[0]}\n                  ON ${options.conditions[0]}\n               JOIN options.tables[1]\n                  ON ${options.conditions[1]}\n               JOIN options.tables[2]\n                  ON ${options.conditions[2]} \n               JOIN options.tables[3]\n                  ON ${options.conditions[3]}\n               JOIN options.tables[4]\n                 ON ${options.conditions[4]}\n               WHERE ${options.from.condition}\n               \n               `;\n    case 7:\n      return `SELECT ${options.fields}\n               FROM ${options.from.table}\n               JOIN ${options.tables[0]}\n                  ON ${options.conditions[0]}\n               JOIN options.tables[1]\n                  ON ${options.conditions[1]}\n               JOIN options.tables[2]\n                  ON ${options.conditions[2]} \n               JOIN options.tables[3]\n                  ON ${options.conditions[3]}\n               JOIN options.tables[4]\n                  ON ${options.conditions[4]}\n                JOIN options.tables[5]\n                  ON ${options.conditions[5]}\n               WHERE ${options.from.condition}\n               \n               `;\n    case 8:\n      return `SELECT ${options.fields}\n               FROM ${options.from.table}\n               JOIN ${options.tables[0]}\n                  ON ${options.conditions[0]}\n               JOIN options.tables[1]\n                  ON ${options.conditions[1]}\n               JOIN options.tables[2]\n                  ON ${options.conditions[2]} \n               JOIN options.tables[3]\n                  ON ${options.conditions[3]}\n               JOIN options.tables[4]\n                  ON ${options.conditions[4]}\n                JOIN options.tables[5]\n                  ON ${options.conditions[5]}\n                JOIN options.tables[6]\n                  ON ${options.conditions[6]}\n               WHERE ${options.from.condition}\n               \n               `;\n    default:\n      return `SELECT ${options.fields}\n               FROM  ??\n               JOIN  ${options.tables[0]}\n                  ON ${options.joinPoints[0]}\n               WHERE ${options.from.condition}\n               `;\n  }\n};\nconst searchExek = function (search, conn, connector) {\n  const self = this;\n  const contains = self.pao.pa_contains;\n  self.pao.pa_wiLog(\"THE SEARCH\");\n  self.pao.pa_wiLog(search);\n  return new Promise(function (resolve, reject) {\n    // do a thing, possibly async, then…\n    self.pao.pa_wiLog(\"Executing the search promise\");\n    let sql = \"\";\n    let attribs = null;\n    let sqliks = self.searchStatement(self.searchOptions(search));\n    self.pao.pa_wiLog(\"THE SQLKIKS OBJECT\");\n    self.pao.pa_wiLog(sqliks);\n    contains(sqliks.attribs, \"tables\") ? attribs = [sqliks.attribs.from.table, ...sqliks.attribs.tables] : attribs = [sqliks.attribs.from.table];\n    sql = sqliks.statement;\n    let queryAttributes = attribs;\n    self.pao.pa_wiLog(\"THE SQL BEFORE FORMAT\");\n    self.pao.pa_wiLog(sql);\n    sql = connector.format(sql, queryAttributes);\n    self.pao.pa_wiLog(sql);\n    // self.infoSync('THE SEARCH SQL')\n    // self.infoSync(sql)\n    conn.query(sql, function (e, r) {\n      if (e) {\n        self.pao.pa_wiLog(\"Promise is rejecting search\");\n        self.pao.pa_wiLog(e);\n        reject(e);\n      } else {\n        self.pao.pa_wiLog(\"Promise is Resolving search\");\n        //  self.pao.pa_wiLog(r)\n        //  self.pao.pa_wiLog(r[0])\n        self.infoSync(\"THE SEARCH RESULTS\");\n        self.infoSync(r);\n        resolve(r);\n      }\n    });\n  });\n};\nconst searchConditionsFormat = function (conditions, type = null) {\n  const self = this;\n  self.pao.pa_wiLog(\"CONDITIONS\");\n  self.pao.pa_wiLog(conditions);\n  if (type) {\n    let condition = self.parseFormatCondition(conditions, type);\n    self.pao.pa_wiLog(\"THE search ON CONDITION\");\n    self.pao.pa_wiLog(condition);\n    return condition;\n  } else {\n    let cons = conditions;\n    let condition = \"\";\n    cons.forEach(con => {\n      if (con.indexOf(\"GROUP::\") >= 0) {\n        self.pao.pa_wiLog(\"CONDITION FROM SEARCHCONDITIONFORMAT\");\n        self.pao.pa_wiLog(con);\n        condition += self.parseGroup(con);\n      } else {\n        condition += self.parseFormatCondition(con);\n      }\n      /*self.pao.pa_wiLog('THE con ITEM')\n               self.pao.pa_wiLog(con)\n               let conList = con.trim().split(' ')\n               self.pao.pa_wiLog('THE CONLIST')\n               self.pao.pa_wiLog(conList)\n               let operand = ''\n               let leftoperand = ''\n               let multiCon = false\n               let match = false\n           \n               if(conList[0].trim() === 'MATCH' || conList[1].trim() === 'MATCH'){\n           \n                 \n                 if(conList.indexOf('AGAINST') > 0 && conList.length >= 5){\n           \n           \n                   let oCon = conList.slice(0)\n           \n                   self.pao.pa_wiLog('THE O CON')\n                   self.pao.pa_wiLog(oCon)\n                    multiCon = oCon[0].trim().toUpperCase() !== 'MATCH' ? true : false\n           \n                   let matchFields = ''\n                   let matchKeys = ''\n           \n                   if(multiCon){\n                     \n                       matchFields = oCon[2].trim()\n                     matchKeys = oCon[4].trim()\n                     \n                   }else{\n                       \n                         matchFields = oCon[1].trim()\n                       matchKeys = oCon[3].trim()\n                   }\n                   \n           \n                   matchFields[0] === '[' ? matchFields = matchFields.slice(1,matchFields.length -1) : ''\n                   matchKeys[0] === '[' ? matchKeys = matchKeys.slice(1,matchKeys.length - 1) : ''\n                   self.pao.pa_wiLog('THE MATCH FIELDS')\n                   self.pao.pa_wiLog(matchFields)\n                   let op = ''\n                   operand = multiCon ? oCon[3].trim() : oCon[2].trim()\n                   let mode = multiCon ? oCon[5] : oCon[4]\n                 \n           \n                 \n                   switch(mode){\n           \n                   case 'BOOLEAN' :\n                     op = `AGAINST (\"${matchKeys}\"\" IN BOOLEAN MODE) `\n                   break;\n                   case 'QUERY' :\n                     op = `AGAINST (\"${matchKeys}\" IN QUERY EXPRESSION MODE) `\n                   break;\n                   \n                   default:\n                     op = `AGAINST (\"${matchKeys}\" IN NATURAL LANGUAGE MODE) `\n           \n                   }\n           \n                   conList[0] = multiCon ? `${oCon[0]} MATCH (${matchFields}) ${op}` :`MATCH (${matchFields}) ${op}`\n                 //  leftoperand = ` ${op}`\n                   match = true\n           \n           \n                   \n           \n                 }else{\n           \n           \n                 }\n           \n               }else{\n           \n           \n                 \n                   let oCon = conList.slice(0)\n           \n                   self.pao.pa_wiLog('THE O CON')\n                   self.pao.pa_wiLog(oCon)\n                   multiCon = oCon[0].trim().toUpperCase() === ('AND' || 'OR' || 'NOT') ? true : false\n                   let operator = multiCon ? conList[2] : conList[1]\n           \n                 switch(operator){\n           \n                   case 'EQUALS' :\n                     operand = '='\n                     break;\n                   case 'ISGREATEROREQUALS' :\n                     operand = '>='\n                     break;\n                   case 'ISLESSOREQUALS' :\n                     operand = '<='\n                     break;\n                   case 'ISLIKE' :\n                     operand = 'LIKE'\n                     break;\n                   case 'ISIN' :\n                   operand = 'IN'\n                   break;\n                   case 'ISREGEX' :\n                     operand = 'REGEXP'\n                     break;\n                   case 'ISNOT' :\n                   operand = 'NOT'\n                   break;\n                   case 'ISNOTNULL' :\n                   operand = 'IS NOT NULL'\n                   break;\n                   case 'ISNULL' :\n                   operand = 'IS NULL'\n                   break;\n                   default:\n                     operand = '='\n                 }\n           \n               leftoperand = multiCon ? conList[3] : conList[2]\n           \n               }\n           \n               match ? condition += `${conList[0]}` : multiCon ? condition += ` ${conList[0]} ${conList[1]} ${operand} '${leftoperand}' `\n               : condition += `${conList[0]} ${operand} '${leftoperand}' `*/\n    });\n    self.pao.pa_wiLog(\"THE search FROM CONDITION\");\n    self.pao.pa_wiLog(condition);\n    return condition.trim();\n  }\n};\nconst searchStatement = function (options) {\n  const self = this;\n  self.pao.pa_wiLog(\"THE search OPTIONSSTATEMENT\");\n  self.pao.pa_wiLog(options);\n  const contains = self.pao.pa_contains;\n  if (!options) return null;\n  if (contains(options, \"length\")) {\n    let sqlAttribs = {};\n    sqlAttribs.attribs = {\n      from: options.from,\n      tables: options.tables\n    };\n    self.pao.pa_wiLog(\"THE OPTIONS LENGTH\");\n    self.pao.pa_wiLog(options.length);\n    let limit = \" \";\n    let sort = options.sort ? self.sort(options.sort) : \" \";\n    options.take ? limit = self.limit(options.take, \"take\") : options.range ? limit = self.limit(options.range, \"range\") : \" \";\n    switch (options.length) {\n      case 3:\n        sqlAttribs.statement = `SELECT ${options.fields}\n                FROM ??\n                JOIN ??\n                  ON ${options.joinPoints[0]}\n                JOIN ??\n                  ON ${options.joinPoints[1]}\n                WHERE ${options.from.condition}\n                ${sort}\n                ${limit}\n                \n                `;\n        break;\n      case 4:\n        sqlAttribs.statement = `SELECT ${options.fields}\n                FROM ${options.from.table}\n                JOIN ${options.tables[0]}\n                  ON ${options.joinPoints[0]}\n                JOIN ${options.tables[1]}\n                  ON ${options.joinPoints[1]}\n                JOIN ${options.tables[2]}\n                  ON ${options.joinPoints[2]}\n                WHERE ${options.from.condition}\n                ${sort}\n                ${limit}\n                `;\n        break;\n      case 5:\n        sqlAttribs.statement = `SELECT ${options.fields}\n                FROM ${options.from.table}\n                JOIN ${options.tables[0]}\n                  ON ${options.joinPoints[0]}\n                JOIN ${options.tables[1]}\n                  ON ${options.joinPoints[1]}\n                JOIN ${options.tables[2]}\n                  ON ${options.joinPoints[2]} \n                JOIN ${options.tables[3]}\n                  ON ${options.joinPoints[3]}\n                WHERE ${options.from.condition}\n                ${sort}\n                ${limit}\n                `;\n        break;\n      default:\n        sqlAttribs.statement = `SELECT ${options.fields}\n                FROM  ??\n                JOIN  ${options.tables[0]}\n                  ON ${options.joinPoints[0]}\n                WHERE ${options.from.condition}\n                ${sort}\n                ${limit}\n              `;\n    }\n    return sqlAttribs;\n  } else {\n    let sqlAttribs = {};\n    sqlAttribs.attribs = {\n      from: options.from\n    };\n    let limit = \" \";\n    let sort = options.sort ? self.sort(options.sort) : \" \";\n    options.take ? limit = self.limit(options.take, \"take\") : options.range ? limit = self.limit(options.range, \"range\") : \" \";\n    if (contains(options.from, \"condition\")) {\n      sqlAttribs.statement = `SELECT ${options.fields}\n              FROM  ??\n              WHERE ${options.from.condition}\n              ${sort}\n              ${limit}\n              `;\n    } else {\n      sqlAttribs.statement = `SELECT ${options.fields}\n                              FROM  ??\n                              ${sort}\n                              ${limit}\n                              `;\n    }\n    return sqlAttribs;\n  }\n};\nconst searchOptions = function (i, multiSet = false) {\n  const self = this;\n  let pao = self.pao;\n  let contains = pao.pa_contains;\n  let setTables = \"\";\n  setTables = multiSet ? [...i.tables] : \"\";\n  self.pao.pa_wiLog(\"THE search BATCH ITEM\");\n  self.pao.pa_wiLog(i);\n  self.pao.pa_wiLog(i);\n  if (contains(i, [\"joins\", \"conditions\", \"joinPoints\"])) {\n    self.pao.pa_wiLog(\"THE SEARCH ITEM CONTAINS BOTH JOINS,CONDITIONS, AND JOINPOINTS\");\n    let options = {};\n    options.from = {\n      table: i.tables[0],\n      condition: self.searchConditionsFormat(i.conditions)\n    };\n    options.joinPoints = i.joinPoints ? self.searchConditionsFormat(i.joinPoints, \"ON\") : null;\n    options.length = i.tables.length;\n    options.tables = i.tables.splice(1, i.tables.length);\n    //  contains(i,['returnFields','opiks']) ? options.fields = self.searchFieldsFormat(i.opiks,i.returnFields) : ''\n    //  contains(i,'returnFields') ? i.returnFields.length === 1 && i.returnFields[0].trim() === 'all' ? options.fields='*' : options.fields= i.returnFields : ''\n    //  contains(i,'opiks') ?  options.fields = self.searchFieldsFormat(i.opiks) : ''\n    contains(i, [\"returnFields\", \"opiks\"]) ? options.fields = self.searchFieldsFormat(i.opiks, i.returnFields) : contains(i, \"opiks\") ? options.fields = self.searchFieldsFormat(i.opiks) : contains(i, \"returnFields\") ? i.returnFields.length === 1 && i.returnFields[0].trim() === \"all\" ? options.fields = \"*\" : options.fields = i.returnFields : \"\";\n    contains(i, \"type\") ? options.type = i.type : \"\";\n    contains(i, \"take\") ? options.take = i.take : \"\";\n    contains(i, \"range\") ? options.range = i.range : \"\";\n    contains(i, \"soundex\") ? options.soundex = i.soundex : \"\";\n    contains(i, \"sort\") ? options.sort = i.sort : \"\";\n    contains(i, \"set\") ? options.set = multiSet ? self.set(i.set, setTables) : self.set(i.set) : \"\";\n    //  contains(i,'takeFrom') ? options.takeFrom = i.takeFrom : ''\n    contains(i, \"takeFrom\") ? i.takeFrom.conditions ? (options.takeFrom = i.takeFrom, options.takeFrom.condition = self.searchConditionsFormat(i.takeFrom.conditions)) : options.takeFrom = i.takeFrom : \"\";\n    return options;\n  } else if (contains(i, [\"conditions\"])) {\n    let options = {};\n    options.from = {\n      table: i.tables[0],\n      condition: self.searchConditionsFormat(i.conditions)\n    };\n    // contains(i,['returnFields','opiks']) ? options.fields = self.searchFieldsFormat(i.opiks,i.returnFields) : ''\n    // contains(i,'returnFields') ? i.returnFields.length === 1 && i.returnFields[0].trim() === 'all' ? options.fields='*' : options.fields= i.returnFields : ''\n    // contains(i,'opiks') ?  options.fields = self.searchFieldsFormat(i.opiks) : ''\n    contains(i, [\"returnFields\", \"opiks\"]) ? options.fields = self.searchFieldsFormat(i.opiks, i.returnFields) : contains(i, \"opiks\") ? options.fields = self.searchFieldsFormat(i.opiks) : contains(i, \"returnFields\") ? i.returnFields.length === 1 && i.returnFields[0].trim() === \"all\" ? options.fields = \"*\" : options.fields = i.returnFields : \"\";\n    contains(i, \"type\") ? options.type = i.type : \"\";\n    contains(i, \"take\") ? options.take = i.take : \"\";\n    contains(i, \"range\") ? options.range = i.range : \"\";\n    contains(i, \"soundex\") ? options.soundex = i.soundex : \"\";\n    contains(i, \"sort\") ? options.sort = i.sort : \"\";\n    contains(i, \"set\") ? options.set = multiSet ? self.set(i.set, setTables) : self.set(i.set) : \"\";\n    contains(i, \"takeFrom\") ? i.takeFrom.conditions ? (options.takeFrom = i.takeFrom, options.takeFrom.condition = self.searchConditionsFormat(i.takeFrom.conditions)) : options.takeFrom = i.takeFrom : \"\";\n    return options;\n  } else if (contains(i, \"tables\") && i.tables instanceof Array) {\n    let options = {};\n    options.from = {\n      table: i.tables[0]\n    };\n    contains(i, [\"returnFields\", \"opiks\"]) ? options.fields = self.searchFieldsFormat(i.opiks, i.returnFields) : contains(i, \"opiks\") ? options.fields = self.searchFieldsFormat(i.opiks) : contains(i, \"returnFields\") ? i.returnFields.length === 1 && i.returnFields[0].trim() === \"all\" ? options.fields = \"*\" : options.fields = i.returnFields : \"\";\n    // contains(i,'opiks') ?  options.fields = self.searchFieldsFormat(i.opiks) : ''\n    contains(i, \"type\") ? options.type = i.type : \"\";\n    contains(i, \"take\") ? options.take = i.take : \"\";\n    contains(i, \"range\") ? options.range = i.range : \"\";\n    contains(i, \"soundex\") ? options.soundex = i.soundex : \"\";\n    contains(i, \"sort\") ? options.sort = i.sort : \"\";\n    contains(i, \"set\") ? options.set = multiSet ? self.set(i.set, setTables) : self.set(i.set) : \"\";\n    contains(i, \"takeFrom\") ? i.takeFrom.conditions ? (options.takeFrom = i.takeFrom, options.takeFrom.condition = self.searchConditionsFormat(i.takeFrom.conditions)) : options.takeFrom = i.takeFrom : \"\";\n    return options;\n  } else {\n    return null;\n  }\n};\nconst searchFieldsFormat = function (fields, rFields = null) {\n  const self = this;\n  self.pao.pa_wiLog(\"THE SELECT STATEMENT OPIKS OBJECT\");\n  self.pao.pa_wiLog(fields);\n  self.pao.pa_wiLog(rFields);\n  let fis = fields;\n  let keyword = \"\";\n  let otherFields = rFields ? rFields.join(\",\") : \"\";\n  let all = \"\";\n  let fieldstatement = \"\";\n  let multiFields = [];\n  let allFields = otherFields.indexOf(\"all\") >= 0;\n  let lastCondition = false;\n  self.pao.pa_wiLog(\"THE OTHER FIELDS\");\n  self.pao.pa_wiLog(otherFields);\n  self.pao.pa_wiLog(otherFields.indexOf(\"all\") >= 0);\n  for (let fi = 0; fi < fis.length; fi++) {\n    if (fis[fi].indexOf(\"fuxin\") >= 0 || fis[fi].indexOf(\"field\") >= 0) {\n      multiFields.push(true);\n    }\n    if (multiFields.length > 1) {\n      break;\n    }\n  }\n  fis.forEach((f, i) => {\n    let formated = self.fieldFormat(f);\n    if (formated instanceof Object) {\n      keyword = formated.value.toUpperCase();\n    } else {\n      self.pao.pa_wiLog(\"THE FORMATED\");\n      self.pao.pa_wiLog(formated);\n      self.pao.pa_wiLog(allFields);\n      self.pao.pa_wiLog(otherFields);\n      if (i === fis.length - 1) {\n        lastCondition = true;\n      }\n      fieldstatement += allFields ? multiFields && i !== fis.length - 1 ? `${formated},` : formated : lastCondition && rFields === null ? `${formated}` : `${formated},`;\n    }\n  });\n  allFields === true ? all = \"*,\" : \"\";\n  return allFields ? `${all} ${keyword} ${fieldstatement}` : `${all} ${keyword} ${fieldstatement} ${otherFields}`;\n};\nconst fieldFormat = function (field, from = null) {\n  const self = this;\n  self.pao.pa_wiLog(\"THE SELECT STATEMENT OPIKS OBJECT FIELD FORMAT\");\n  self.pao.pa_wiLog(field);\n  //  let splitFieldRegx = /\\.(?![^\\[]]*\\]])/\n  let nestedIntFuxin = \"\";\n  let last = field.lastIndexOf(\".as\") >= 0 ? field.lastIndexOf(\".as\") : field.length;\n  field.indexOf(\".options[fuxin\") >= 0 ? nestedIntFuxin = field.slice(field.indexOf(\".options[fuxin\"), last) : \"\";\n  self.pao.pa_wiLog(\"THE NESTEDINTFUXIN\");\n  self.pao.pa_wiLog(nestedIntFuxin);\n  self.pao.pa_wiLog(field);\n  nestedIntFuxin.trim() !== \"\" ? field = field.substr(0, field.indexOf(nestedIntFuxin)) : \"\";\n  // nestedIntFuxin.trim() !== '' ? field =  : ''\n  // let splicedArray = conList.splice(2)\n  // self.pao.pa_wiLog('THE SPLICED ARRAY')\n  // self.pao.pa_wiLog(splicedArray)\n  // self.pao.pa_wiLog(splicedArray.join(' '))\n  // conList[2] = splicedArray.join(' ');\n  // self.pao.pa_wiLog(conList)\n  // self.pao.pa_wiLog(conList[2].indexOf('['))\n  //  let fieldList = field.trim().split('.')\n  //  fieldList.length > 3 ? fieldList[3].indexOf('as[') < 0 ? fieldList[2] = fieldList.splice(2).join(' ') : '' : ''\n  let fieldList = field.trim().split(\".\");\n  nestedIntFuxin.trim() !== \"\" ? fieldList.push(nestedIntFuxin) : \"\";\n  self.pao.pa_wiLog(\"THE FIELD LIST\");\n  self.pao.pa_wiLog(fieldList);\n  let fieldstatement = null;\n  //fuxin.date_sub.options[fuxin.now,INTERVAL ${intExp} ${intUnit}]\n  let as = fieldList[0] === \"fuxin\" ? fieldList.length > 3 ? `AS ${self.options(`${fieldList[3]}`, \"as\")}` : \" \" : \" \";\n  self.pao.pa_wiLog(\"THE as\");\n  self.pao.pa_wiLog(as);\n  switch (fieldList[0]) {\n    case \"keyword\":\n      fieldstatement = from ? fieldList[1].toUpperCase() : {\n        statement: \"keyword\",\n        value: fieldList[1].toUpperCase()\n      };\n      break;\n    case \"fuxin\":\n      fieldstatement = ` ${fieldList[1].toUpperCase()}(${self.options(`${fieldList[2]}`, \"option\")}) ${as} `;\n      break;\n    case \"field\":\n      if (fieldList.length === 3) fieldstatement = `${fieldList[1]} AS ${self.options(fieldList[2], \"as\")}`;\n      break;\n    default:\n      fieldstatement = \"\";\n  }\n  return fieldstatement.trim();\n};\nconst options = function (option, type = \"\") {\n  const self = this;\n  self.pao.pa_wiLog(\"THE CURRENT OPTION\");\n  self.pao.pa_wiLog(option);\n  if (option !== \"undefined\") {\n    let stripedOption = option.slice(option.indexOf(\"[\") + 1, option.lastIndexOf(\"]\"));\n    self.pao.pa_wiLog(\"OPTIONS: STRIPEDOPTION\");\n    self.pao.pa_wiLog(stripedOption);\n    if (type === \"as\") {\n      return `${stripedOption}`;\n    } else if (type === \"option\") {\n      let args = stripedOption.split(\",\");\n      if (args instanceof Array && args.length > 1) {\n        if (args[0].indexOf(\"keyword\") >= 0) {\n          return self.fieldFormat(args[0], true);\n        } else if (args[0].indexOf(\"fuxin\") >= 0) {\n          if (args[1]) {\n            return `${self.fieldFormat(args[0])},${args[1].trim()}`;\n          } else {\n            return self.fieldFormat(args[0]);\n          }\n        } else {\n          return `${stripedOption}`;\n        }\n      } else {\n        return args.join(\",\");\n      }\n    }\n  } else {\n    self.pao.pa_wiLog(\"THE OPTION IS UNDEFINED\");\n    self.pao.pa_wiLog(option);\n    return \"\";\n  }\n};\nconst sort = function (sort) {\n  const self = this;\n  self.pao.pa_wiLog(\"THE SORT GOT A RESPONSE\");\n  self.pao.pa_wiLog(sort);\n  let sortArgs = sort.split(\".\");\n  let sortFields = sort.slice(sort.indexOf(\"[\") + 1, sort.lastIndexOf(\"]\"));\n  let sortStatement = \"\";\n  if (sortArgs[0].indexOf(\"order\") >= 0) {\n    if (sortArgs.length > 1) {\n      if (sortArgs[1].toUpperCase() === \"DESC\") {\n        sortStatement = `ORDER BY ${sortFields} DESC`;\n      } else {\n        sortStatement = `ORDER BY ${sortFields}`;\n      }\n    } else {\n      sortStatement = `ORDER BY ${sortFields}`;\n    }\n  } else if (sortArgs[0].indexOf(\"group\") >= 0) {\n    if (sortArgs.length > 1) {\n      if (sortArgs[1].toUpperCase() === \"DESC\") {\n        sortStatement = `GROUP BY ${sortFields} DESC`;\n      } else {\n        sortStatement = `GROUP BY ${sortFields} ASC`;\n      }\n    } else {\n      sortStatement = `GROUP BY ${sortFields} ASC`;\n    }\n  }\n  return sortStatement;\n};\nconst limit = function (limit, type = null) {\n  let limitStatement = \"\";\n  if (type === \"take\") {\n    limitStatement = `LIMIT ${limit} OFFSET 0`;\n  } else if (type === \"range\") {\n    let ranges = limit.split(\",\");\n    let offset = ranges[0];\n    let count = ranges[1];\n    limitStatement = `LIMIT ${count} OFFSET ${offset}`;\n  }\n  return limitStatement;\n};\nconst parseGroup = function (con, level = 1) {\n  const self = this;\n  const pao = self.pao;\n  let isObject = pao.pa_isObject;\n  //AND GROUP::2 START created_at FUXIN [ISGREATEROREQUALS fuxin.date_sub.options[fuxin.now,INTERVAL ${intExp} ${intUnit}]]\n  let fullCon = \"\";\n  let connector = \"\";\n  let res = self.conditionsConnector(con);\n  self.pao.pa_wiLog(\"THE RES VALUE\");\n  self.pao.pa_wiLog(res);\n  if (isObject(res)) {\n    self.pao.pa_wiLog(\"THE RES IS AN OBJECT\");\n    self.pao.pa_wiLog(res);\n    con = res.condixion;\n    connector = res.connector;\n  }\n  if (con.trim().indexOf(\"GROUP::\") === 0) {\n    self.pao.pa_wiLog(\"THE GROUP:: string is the first\");\n    //let groupRegx = /GROUP::/\n    let exStr = con.replace(\"GROUP::\", \"\").trim();\n    let groupLen = 0;\n    let startStr = \"\";\n    let conStr = \"\";\n    self.pao.pa_wiLog(\"THE extracted string\");\n    self.pao.pa_wiLog(exStr);\n    if (typeof parseInt(exStr[0]) === \"number\") {\n      self.pao.pa_wiLog(\"extStr type is a number\");\n      // eslint-disable-next-line no-unused-vars\n      groupLen = parseInt(exStr[0]);\n      startStr = exStr.slice(1).trim();\n      if (startStr.indexOf(\"START\") === 0 || startStr.indexOf(\"$\") === 0) {\n        conStr = startStr.replace(\"START\", \"\").trim();\n        self.pao.pa_wiLog(startStr);\n        let groupCons = \"\";\n        //  let groupL1Cons = ''\n        //  let groupL2Cons = ''\n        //  let groupL3Cons = ''\n        let grouped = [];\n        self.pao.pa_wiLog(\"PARSEGROUP EXECUTES THIS FAR\");\n        self.pao.pa_wiLog(conStr);\n        if (level === 1) {\n          groupCons = conStr.split(\";\");\n          self.pao.pa_wiLog(\"LEVEL 1 GROUPCONS\");\n          self.pao.pa_wiLog(groupCons);\n          grouped = groupCons.map(c => {\n            self.pao.pa_wiLog(\"THE C CONDITION\");\n            self.pao.pa_wiLog(c);\n            self.pao.pa_wiLog(c.indexOf(\"GROUP::\"));\n            //  self.conditionsConnector()\n            if (c.indexOf(\"GROUP::\") >= 0) {\n              return self.parseGroup(c, 2);\n            } else {\n              return self.parseFormatCondition(c);\n            }\n          });\n        } else if (level === 2) {\n          groupCons = conStr.split(\",\");\n          self.pao.pa_wiLog(\"LEVEL 2 GROUPCONS\");\n          self.pao.pa_wiLog(groupCons);\n          grouped = groupCons.map(c => {\n            // c = self.conditionsConnector(c)\n            if (c.indexOf(\"GROUP::\") >= 0) {\n              return self.parseGroup(c, 3);\n            } else {\n              return self.parseFormatCondition(c);\n            }\n          });\n        } else if (level === 3) {\n          groupCons = conStr.split(\"|\");\n          grouped = groupCons.map(c => {\n            return self.parseFormatCondition(c);\n          });\n        }\n        self.pao.pa_wiLog(\"GROUPED\");\n        self.pao.pa_wiLog(grouped);\n        self.pao.pa_wiLog(groupCons);\n        fullCon = `${connector} (${grouped.join(\" \")})`;\n        // eslint-disable-next-line no-empty\n      } else {}\n    }\n  }\n  self.pao.pa_wiLog(\"THE FULL GROUPED CONDITION TO BE RETURNED:\");\n  self.pao.pa_wiLog(fullCon);\n  return fullCon;\n};\nconst parseFormatCondition = function (con, type = null) {\n  const self = this;\n  if (type) {\n    let cons = con;\n    let condition = [];\n    cons.forEach(kon => {\n      // let conList = kon.trim().split(' ')\n      let conList = kon.trim().match(/(\\[[^\\]]+\\]|\\S+)/g);\n      let operand = \"=\";\n      condition.push(`${conList[0]} ${operand} ${conList[2]}`);\n    });\n    self.pao.pa_wiLog(\"THE search ON CONDITION\");\n    self.pao.pa_wiLog(condition);\n    return condition;\n  } else {\n    let condition = \"\";\n    self.pao.pa_wiLog(\"THE con ITEM\");\n    self.pao.pa_wiLog(con);\n    // let conList = con.trim().split(' ')\n    // let conList = con.trim().match(/(?:\"^\\s\\[]+|\"[^\"]*\")+/g)\n    let conList = con.trim().match(/(\\[[^\\]]+\\]|\\S+)/g);\n    self.pao.pa_wiLog(\"THE CONLIST\");\n    self.pao.pa_wiLog(conList);\n    let operand = \"\";\n    let leftoperand = \"\";\n    let multiCon = false;\n    let match = false;\n    let conFuxin = false;\n    let whiteSpace = \" \";\n    if (conList[0].trim() === \"MATCH\" || conList[1].trim() === \"MATCH\" || conList[1].trim() === \"FUXIN\" || conList[2].trim() === \"FUXIN\") {\n      if (conList.indexOf(\"AGAINST\") > 0 && conList.length >= 5) {\n        let oCon = conList.slice(0);\n        self.pao.pa_wiLog(\"THE O CON\");\n        self.pao.pa_wiLog(oCon);\n        multiCon = oCon[0].trim().toUpperCase() !== \"MATCH\" ? true : false;\n        let matchFields = \"\";\n        let matchKeys = \"\";\n        if (multiCon) {\n          matchFields = oCon[2].trim();\n          matchKeys = oCon[4].trim();\n        } else {\n          matchFields = oCon[1].trim();\n          matchKeys = oCon[3].trim();\n        }\n        matchFields[0] === \"[\" ? matchFields = matchFields.slice(1, matchFields.length - 1) : \"\";\n        matchKeys[0] === \"[\" ? matchKeys = matchKeys.slice(1, matchKeys.length - 1) : \"\";\n        self.pao.pa_wiLog(\"THE MATCH FIELDS\");\n        self.pao.pa_wiLog(matchFields);\n        let op = \"\";\n        operand = multiCon ? oCon[3].trim() : oCon[2].trim();\n        let mode = multiCon ? oCon[5] : oCon[4];\n        switch (mode) {\n          case \"BOOLEAN\":\n            op = `AGAINST (\"${matchKeys}\"\" IN BOOLEAN MODE) `;\n            break;\n          case \"QUERY\":\n            op = `AGAINST (\"${matchKeys}\" IN QUERY EXPRESSION MODE) `;\n            break;\n          default:\n            op = `AGAINST (\"${matchKeys}\" IN NATURAL LANGUAGE MODE) `;\n        }\n        conList[0] = multiCon ? `${oCon[0]} MATCH (${matchFields}) ${op}` : `MATCH (${matchFields}) ${op}`;\n        //  leftoperand = ` ${op}`\n        match = true;\n      } else {\n        //[ISGREATEROREQUALS fuxin.date_sub.options[fuxin.now,INTERVAL ${intExp} ${intUnit}]]\n        //created_at FUXIN [ISGREATEROREQUALS fuxin.date_sub.options[fuxin.now,INTERVAL ${intExp} ${intUnit}]]\n        let oCon = conList.slice(0);\n        conFuxin = true;\n        self.pao.pa_wiLog(\"THE O CON::FUXIN\");\n        self.pao.pa_wiLog(oCon);\n        multiCon = oCon[1].trim().toUpperCase() !== \"FUXIN\" ? true : false;\n        let fuxinIndex = multiCon ? 3 : 2;\n        let splicedFuxinArr = oCon.splice(fuxinIndex);\n        oCon.push(splicedFuxinArr.join(\" \"));\n        self.pao.pa_wiLog(fuxinIndex);\n        self.pao.pa_wiLog(oCon);\n        //  self.pao.pa_wiLog(splicedFuxinArr)\n        // if(oCon.indexOf('FUXIN') > 0){\n        //   self.pao.pa_wiLog('THE FUXIN OP IN SEARCHCONDITIONS')\n        //   self.pao.pa_wiLog(oCon)\n        //   let splicedArray = multiCon ? oCon.splice(3) : oCon.splice(2)\n        //   self.pao.pa_wiLog('THE SPLICED ARRAY')\n        //   self.pao.pa_wiLog(splicedArray)\n        //   self.pao.pa_wiLog(splicedArray.join(' '))\n        //   multiCon ? oCon[3] = splicedArray.join(' ') : oCon[2] = splicedArray.join(' ');\n        //   self.pao.pa_wiLog(oCon)\n        //   self.pao.pa_wiLog(oCon[2].indexOf('['))\n        //   // throw new Error()\n        if (oCon[fuxinIndex].indexOf(\"[\") >= 0) {\n          self.pao.pa_wiLog(\"OTHER CONTENT IS IN THE SQUARE BRACKETS\");\n          let stripedSqBkts = oCon[fuxinIndex].slice(1, oCon[fuxinIndex].length - 1);\n          stripedSqBkts = stripedSqBkts.trim();\n          // let splitRegex = /([.*?])/g\n          self.pao.pa_wiLog(\"AFTER THE STRIPED HAS BEEN TRIMMED\");\n          self.pao.pa_wiLog(stripedSqBkts);\n          let operator = stripedSqBkts.substr(0, stripedSqBkts.indexOf(\" \"));\n          let functionalStr = stripedSqBkts.substr(stripedSqBkts.indexOf(\" \") + 1);\n          self.pao.pa_wiLog(\"THE SPLITFUXINCONS\");\n          self.pao.pa_wiLog(operator);\n          self.pao.pa_wiLog(functionalStr);\n          let gotOperand = self.getOperand(operator);\n          let bakedFuxin = self.fieldFormat(functionalStr);\n          self.pao.pa_wiLog(gotOperand);\n          self.pao.pa_wiLog(bakedFuxin);\n          // throw new Error()\n          condition = multiCon ? `${oCon[0]} ${oCon[1]} ${gotOperand} ${bakedFuxin}` : `${oCon[0]} ${gotOperand} ${bakedFuxin}`;\n          self.pao.pa_wiLog(\"THE CONDITION IN FUXIN TEST\");\n          self.pao.pa_wiLog(condition);\n        }\n        // }\n      }\n    } else {\n      let oCon = conList.slice(0);\n      self.pao.pa_wiLog(\"THE O CON\");\n      self.pao.pa_wiLog(oCon);\n      let firstStrItem = oCon[0].trim().toUpperCase();\n      multiCon = firstStrItem === \"AND\" || firstStrItem === \"OR\" || firstStrItem === \"NOT\" ? true : false;\n      let operator = multiCon ? conList[2] : conList[1];\n      self.pao.pa_wiLog(\"THE MULTICON STATUS:::\");\n      self.pao.pa_wiLog(multiCon);\n      self.pao.pa_wiLog(oCon);\n      operand = self.getOperand(operator);\n      // switch(operator){\n      //   case 'EQUALS' :\n      //     operand = '='\n      //     break;\n      //   case 'ISGREATEROREQUALS' :\n      //     operand = '>='\n      //     break;\n      //   case 'ISLESSOREQUALS' :\n      //     operand = '<='\n      //     break;\n      //   case 'ISLIKE' :\n      //     operand = 'LIKE'\n      //     break;\n      //   case 'ISIN' :\n      //   operand = 'IN'\n      //   break;\n      //   case 'ISREGEX' :\n      //     operand = 'REGEXP'\n      //     break;\n      //   case 'ISNOT' :\n      //   operand = 'NOT'\n      //   break;\n      //   case 'ISNOTNULL' :\n      //   operand = 'IS NOT NULL'\n      //   break;\n      //   case 'ISNULL' :\n      //   operand = 'IS NULL'\n      //   break;\n      //   default:\n      //     operand = '='\n      // }\n      leftoperand = multiCon ? conList[3] : conList[2];\n      leftoperand[0] === \"[\" ? leftoperand = `'${leftoperand.slice(1, leftoperand.length - 1)}'` : leftoperand.indexOf(\"KEY::\") >= 0 ? leftoperand = `${leftoperand.replace(\"KEY::\", \"\").trim()}` : leftoperand = `'${leftoperand}'`;\n      self.pao.pa_wiLog(\"THE VALUE OF THE LEFFFFFT OPERAND\");\n      self.pao.pa_wiLog(leftoperand);\n      self.pao.pa_wiLog(leftoperand.indexOf(\"KEY::\"));\n    }\n    if (!conFuxin) {\n      match ? condition += `${conList[0]}` : multiCon ? condition += `${whiteSpace} ${conList[0]} ${conList[1]} ${operand} ${leftoperand}` : condition += `${conList[0]} ${operand} ${leftoperand}`;\n    }\n    self.pao.pa_wiLog(\"THE search FROM CONDITION\");\n    self.pao.pa_wiLog(condition);\n    return condition;\n  }\n};\nconst getOperand = function (operator) {\n  let operand = \"\";\n  switch (operator) {\n    case \"EQUALS\":\n      operand = \"=\";\n      break;\n    case \"ISGREATEROREQUALS\":\n      operand = \">=\";\n      break;\n    case \"ISLESSOREQUALS\":\n      operand = \"<=\";\n      break;\n    case \"ISLIKE\":\n      operand = \"LIKE\";\n      break;\n    case \"ISIN\":\n      operand = \"IN\";\n      break;\n    case \"ISREGEX\":\n      operand = \"REGEXP\";\n      break;\n    case \"ISNOT\":\n      operand = \"NOT\";\n      break;\n    case \"ISNOTNULL\":\n      operand = \"IS NOT NULL\";\n      break;\n    case \"ISNULL\":\n      operand = \"IS NULL\";\n      break;\n    default:\n      operand = \"=\";\n  }\n  return operand;\n};\nconst conditionsConnector = function (c) {\n  const self = this;\n  let connector = {};\n  self.pao.pa_wiLog(\"THE INDEX OF GROUP:: IN CONDITIONS CONNECTOR\");\n  self.pao.pa_wiLog(c.trim().indexOf(\"GROUP::\"));\n  self.pao.pa_wiLog(c);\n  if (c.trim().indexOf(\"GROUP::\") > 0) {\n    self.pao.pa_wiLog(\"THE INDEX OF GROUP IS AT ONE\");\n    if (c.trim().indexOf(\"AND\") === 0) {\n      connector.connector = ` AND`;\n      connector.condixion = c.replace(\"AND\", \"\").trim();\n    } else if (c.trim().indexOf(\"OR\") === 0) {\n      connector.connector = ` OR`;\n      connector.condixion = c.replace(\"OR\", \"\").trim();\n    } else if (c.trim().indexOf(\"NOT\") === 0) {\n      connector.connector = ` NOT`;\n      connector.condixion = c.replace(\"NOT\", \"\").trim();\n    }\n    return connector;\n  } else {\n    return c;\n  }\n};\nconst set = function (set, multiSets = false) {\n  const self = this;\n  const pao = self.pao;\n  const objectToArray = pao.pa_objectToArray;\n  self.pao.pa_wiLog(\"THE SET\");\n  self.pao.pa_wiLog(set);\n  self.pao.pa_wiLog(multiSets);\n  let setStrings = \"\";\n  set.forEach((s, i) => {\n    let setString = \"\";\n    let modSet = objectToArray(s, true);\n    self.pao.pa_wiLog(\"THE CONVERTED SET OBJECT\");\n    self.pao.pa_wiLog(modSet);\n    modSet.forEach((col, pos) => {\n      multiSets ? setString += pos === modSet.length - 1 ? `${multiSets[i]}.${col.key} = \"${col.value}\"` : `${multiSets[i]}.${col.key} = \"${col.value}\", ` : setString += pos === modSet.length - 1 ? `${col.key} = \"${col.value}\"` : `${col.key} = \"${col.value}\", `;\n    });\n    setStrings += i === set.length - 1 ? `${setString}` : `${setString}, `;\n    // let key = ''\n    // let value = ''\n    // key = Object.keys(s)[0]\n    // value = s[Object.keys(s)[0]]\n    // self.pao.pa_wiLog('THE LENGTH OF S')\n    // self.pao.pa_wiLog(set.length)\n    // self.pao.pa_wiLog(i)\n    // setString += i === set.length - 1 ? `${key} = \"${value}\"` : `${key} = \"${value}\", `\n  });\n  self.pao.pa_wiLog(\"THE SETSTRINGS\");\n  self.pao.pa_wiLog(setStrings);\n  return setStrings;\n};\n\n//# sourceURL=webpack://anzii/./lib/esm/mysql/methods.js?");

/***/ }),

/***/ "./lib/esm/mysql/mysql.js":
/*!********************************!*\
  !*** ./lib/esm/mysql/mysql.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _methods_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./methods.js */ \"./lib/esm/mysql/methods.js\");\n\nclass Mysql {\n  constructor(pao) {\n    this.pao = pao;\n    // // methods\n    this.init = _methods_js__WEBPACK_IMPORTED_MODULE_0__.init;\n    this.handleMysqlDataRequest = _methods_js__WEBPACK_IMPORTED_MODULE_0__.handleMysqlDataRequest;\n    this.insertOne = _methods_js__WEBPACK_IMPORTED_MODULE_0__.insertOne;\n    this.insertMany = _methods_js__WEBPACK_IMPORTED_MODULE_0__.insertMany;\n    this.find = _methods_js__WEBPACK_IMPORTED_MODULE_0__.find;\n    this.findOne = _methods_js__WEBPACK_IMPORTED_MODULE_0__.findOne;\n    this.findIterateItemPromise = _methods_js__WEBPACK_IMPORTED_MODULE_0__.findIterateItemPromise;\n    this.remove = _methods_js__WEBPACK_IMPORTED_MODULE_0__.remove;\n    this.updateOne = _methods_js__WEBPACK_IMPORTED_MODULE_0__.updateOne;\n    this.set = _methods_js__WEBPACK_IMPORTED_MODULE_0__.set;\n    this.queryOptions = _methods_js__WEBPACK_IMPORTED_MODULE_0__.queryOptions;\n    this.queryTemplate = _methods_js__WEBPACK_IMPORTED_MODULE_0__.queryTemplate;\n    this.TRANSACTION = _methods_js__WEBPACK_IMPORTED_MODULE_0__.TRANSACTION;\n    this.PROCEDURE = _methods_js__WEBPACK_IMPORTED_MODULE_0__.PROCEDURE;\n    this.JOIN = _methods_js__WEBPACK_IMPORTED_MODULE_0__.JOIN;\n    this.SEARCH = _methods_js__WEBPACK_IMPORTED_MODULE_0__.SEARCH;\n    this.procedure = _methods_js__WEBPACK_IMPORTED_MODULE_0__.procedure;\n    this.transaction = _methods_js__WEBPACK_IMPORTED_MODULE_0__.transaction;\n    this.join = _methods_js__WEBPACK_IMPORTED_MODULE_0__.join;\n    this.joinExek = _methods_js__WEBPACK_IMPORTED_MODULE_0__.joinExek;\n    this.joinStatement = _methods_js__WEBPACK_IMPORTED_MODULE_0__.joinStatement;\n    this.joinConditionsFormat = _methods_js__WEBPACK_IMPORTED_MODULE_0__.joinConditionsFormat;\n    this.search = _methods_js__WEBPACK_IMPORTED_MODULE_0__.search;\n    this.searchExek = _methods_js__WEBPACK_IMPORTED_MODULE_0__.searchExek;\n    this.searchStatement = _methods_js__WEBPACK_IMPORTED_MODULE_0__.searchStatement;\n    this.searchConditionsFormat = _methods_js__WEBPACK_IMPORTED_MODULE_0__.searchConditionsFormat;\n    this.searchOptions = _methods_js__WEBPACK_IMPORTED_MODULE_0__.searchOptions;\n    this.combineFields = _methods_js__WEBPACK_IMPORTED_MODULE_0__.combineFields;\n    this.insert = _methods_js__WEBPACK_IMPORTED_MODULE_0__.insert;\n    this.procedureUpdate = _methods_js__WEBPACK_IMPORTED_MODULE_0__.procedureUpdate;\n    this.procedureDelete = _methods_js__WEBPACK_IMPORTED_MODULE_0__.procedureDelete;\n    this.procedureSelect = _methods_js__WEBPACK_IMPORTED_MODULE_0__.procedureSelect;\n    this.rollback = _methods_js__WEBPACK_IMPORTED_MODULE_0__.rollback;\n    //  this.deleteOne = methods.deleteOne\n    this.searchFieldsFormat = _methods_js__WEBPACK_IMPORTED_MODULE_0__.searchFieldsFormat;\n    this.fieldFormat = _methods_js__WEBPACK_IMPORTED_MODULE_0__.fieldFormat;\n    this.options = _methods_js__WEBPACK_IMPORTED_MODULE_0__.options;\n    this.sort = _methods_js__WEBPACK_IMPORTED_MODULE_0__.sort;\n    this.limit = _methods_js__WEBPACK_IMPORTED_MODULE_0__.limit;\n    this.parseGroup = _methods_js__WEBPACK_IMPORTED_MODULE_0__.parseGroup;\n    this.parseFormatCondition = _methods_js__WEBPACK_IMPORTED_MODULE_0__.parseFormatCondition;\n    this.getOperand = _methods_js__WEBPACK_IMPORTED_MODULE_0__.getOperand;\n    this.conditionsConnector = _methods_js__WEBPACK_IMPORTED_MODULE_0__.conditionsConnector;\n    this.updateandtake = _methods_js__WEBPACK_IMPORTED_MODULE_0__.updateandtake;\n    this.insertandtake = _methods_js__WEBPACK_IMPORTED_MODULE_0__.insertandtake;\n    this.deleteandtake = _methods_js__WEBPACK_IMPORTED_MODULE_0__.deleteandtake;\n    this.updateJoinTemplate = _methods_js__WEBPACK_IMPORTED_MODULE_0__.updateJoinTemplate;\n    this.multiTableUpdate = _methods_js__WEBPACK_IMPORTED_MODULE_0__.multiTableUpdate;\n    this.take = _methods_js__WEBPACK_IMPORTED_MODULE_0__.take;\n    this.takeSql = _methods_js__WEBPACK_IMPORTED_MODULE_0__.takeSql;\n    this.removeJoin = _methods_js__WEBPACK_IMPORTED_MODULE_0__.removeJoin;\n  }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Mysql);\n\n//# sourceURL=webpack://anzii/./lib/esm/mysql/mysql.js?");

/***/ }),

/***/ "./lib/esm/parsers/index.js":
/*!**********************************!*\
  !*** ./lib/esm/parsers/index.js ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _parsers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parsers.js */ \"./lib/esm/parsers/parsers.js\");\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_parsers_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n//# sourceURL=webpack://anzii/./lib/esm/parsers/index.js?");

/***/ }),

/***/ "./lib/esm/parsers/methods.js":
/*!************************************!*\
  !*** ./lib/esm/parsers/methods.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   handleShareMiddleware: () => (/* binding */ handleShareMiddleware),\n/* harmony export */   init: () => (/* binding */ init)\n/* harmony export */ });\nconst init = function () {\n  this.adLog(\"Parsers has been initialised\");\n  this.listens({\n    \"share-middleware\": this.handleShareMiddleware.bind(this)\n  });\n};\nconst handleShareMiddleware = function () {\n  const self = this;\n  self.pao.pa_wiLog(\"HANLDE SHARE MIDDLEWARE EVENT HAS OCCURED\");\n  self.emit({\n    type: \"add-ext-middleware\",\n    data: {\n      type: \"all\",\n      level: \"top\",\n      middleware: {\n        funk: [{\n          body: self.dependiks.bodyParser,\n          call: \"json\"\n        }]\n      }\n    }\n  });\n};\n\n//# sourceURL=webpack://anzii/./lib/esm/parsers/methods.js?");

/***/ }),

/***/ "./lib/esm/parsers/parsers.js":
/*!************************************!*\
  !*** ./lib/esm/parsers/parsers.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("var body_parser__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var body_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! body-parser */ \"body-parser\");\n/* harmony import */ var jsonfile__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jsonfile */ \"jsonfile\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var _methods_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./methods.js */ \"./lib/esm/parsers/methods.js\");\n\n\n\n\nclass Parsers {\n  constructor(pao) {\n    this.pao = pao;\n    this.path = path__WEBPACK_IMPORTED_MODULE_2__;\n    this.dependiks = {\n      jsonfile: jsonfile__WEBPACK_IMPORTED_MODULE_1__,\n      bodyParser: /*#__PURE__*/ (body_parser__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (body_parser__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(body_parser__WEBPACK_IMPORTED_MODULE_0__, 2)))\n    };\n    this.init = _methods_js__WEBPACK_IMPORTED_MODULE_3__.init;\n    this.handleShareMiddleware = _methods_js__WEBPACK_IMPORTED_MODULE_3__.handleShareMiddleware;\n  }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Parsers);\n\n//# sourceURL=webpack://anzii/./lib/esm/parsers/parsers.js?");

/***/ }),

/***/ "./lib/esm/request/index.js":
/*!**********************************!*\
  !*** ./lib/esm/request/index.js ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _request_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./request.js */ \"./lib/esm/request/request.js\");\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_request_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n//# sourceURL=webpack://anzii/./lib/esm/request/index.js?");

/***/ }),

/***/ "./lib/esm/request/methods.js":
/*!************************************!*\
  !*** ./lib/esm/request/methods.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   failureHandle: () => (/* binding */ failureHandle),\n/* harmony export */   handleBadRequestError: () => (/* binding */ handleBadRequestError),\n/* harmony export */   handleByHandlerError: () => (/* binding */ handleByHandlerError),\n/* harmony export */   handleConfigRequest: () => (/* binding */ handleConfigRequest),\n/* harmony export */   handleHandlerError: () => (/* binding */ handleHandlerError),\n/* harmony export */   handleHandlerNotFound: () => (/* binding */ handleHandlerNotFound),\n/* harmony export */   handlePathError: () => (/* binding */ handlePathError),\n/* harmony export */   handleRequestGlobalError: () => (/* binding */ handleRequestGlobalError),\n/* harmony export */   handleRequestGlobalResponse: () => (/* binding */ handleRequestGlobalResponse),\n/* harmony export */   handleRequestHandOver: () => (/* binding */ handleRequestHandOver),\n/* harmony export */   handleRouterAliasList: () => (/* binding */ handleRouterAliasList),\n/* harmony export */   init: () => (/* binding */ init),\n/* harmony export */   isView: () => (/* binding */ isView),\n/* harmony export */   parseRequest: () => (/* binding */ parseRequest),\n/* harmony export */   successfullHandle: () => (/* binding */ successfullHandle),\n/* harmony export */   taskerHandler: () => (/* binding */ taskerHandler),\n/* harmony export */   writeResponse: () => (/* binding */ writeResponse)\n/* harmony export */ });\nconst init = function () {\n  this.adLog(\"Request has been initialised\");\n  this.listens({\n    \"config-request\": this.handleConfigRequest.bind(this),\n    \"request-handover\": this.handleRequestHandOver.bind(this),\n    \"request-global-request-response\": this.handleRequestGlobalResponse.bind(this),\n    // 'request-view-response': this.handleRequestViewResponse.bind(this),\n    \"request-global-request-error\": this.handleRequestGlobalError.bind(this),\n    \"request-handler-error\": this.handleHandlerError.bind(this),\n    \"router-alias-list\": this.handleRouterAliasList.bind(this)\n  });\n};\nconst handleConfigRequest = function (data) {\n  const self = this;\n  self.infoSync(\"handleRequest Data;;;\");\n  self.infoSync(data);\n  data.forEach(route => {\n    route.view ? self.views.push(route.path) : \"\";\n  });\n};\nconst handleRequestHandOver = function (data) {\n  const self = this;\n  self.infoSync(\"Handling Handed Request\");\n  self.infoSync(data.req.originalUrl);\n  self.request.res = data.res;\n  let aliasList = self.routesAliasList;\n  let aliatikHandlers = self.aliatikHandlers;\n  let parsed = self.parseRequest(data.req);\n  self.pao.pa_wiLog(\"THE ALIATIKS\");\n  self.pao.pa_wiLog(parsed);\n  self.pao.pa_wiLog(aliasList);\n  self.pao.pa_wiLog(aliatikHandlers);\n  data.req.uploads ? parsed.user ? parsed.user.uploads = data.req.uploads : parsed.user = {\n    uploads: data.req.uploads\n  } : \"\";\n  // self.pao.pa_wiLog('parsed')\n  // self.pao.pa_wiLog(parsed.url.trim().split('/'))\n  let handler = parsed.handler;\n  aliasList.indexOf(handler) >= 0 ? handler = aliatikHandlers[aliasList.indexOf(handler)] : \"\";\n  self.handler = handler;\n  if (handler && handler.trim() !== \"\") {\n    self.pao.pa_wiLog(\"THERES A VALID HANDLE\");\n    self.pao.pa_wiLog(self.handler);\n    let uza = parsed.user || null;\n    self.requestData = {\n      parsed: parsed,\n      handler: handler,\n      request: {\n        req: data.req,\n        res: data.res,\n        next: data.next\n      }\n    };\n    uza ? self.requestData.user = uza : \"\";\n    self.pao.pa_wiLog(self.views);\n    self.pao.pa_wiLog(!self.views || self.views.length === 0);\n    self.pao.pa_wiLog(self.isView(data.req.originalUrl, uza));\n    if (!self.views || self.views.length === 0) return self.emit({\n      type: \"request-global-request\",\n      data: handler\n    });\n    if (self.isView(data.req.originalUrl, uza)) return self.emit({\n      type: `do-view-task`,\n      data: {\n        payload: self.requestData,\n        callback: self.taskerHandler.bind(self)\n      }\n    });\n    self.pao.pa_wiLog(\"none view should be rendered\");\n    return self.emit({\n      type: \"request-global-request\",\n      data: handler\n    });\n  } else {\n    console.log(\"THERE IS NOT HANDLER\", self.views);\n    self.pao.pa_wiLog(\"THEre is no handler\");\n    self.pao.pa_wiLog(self.handler);\n    if (!self.views || self.views.length === 0) return self.handlePathError();\n    let uza = parsed.user || null;\n    self.requestData = {\n      parsed: parsed,\n      handler: handler,\n      request: {\n        req: data.req,\n        res: data.res,\n        next: data.next\n      }\n    };\n    uza ? self.requestData.user = uza : \"\";\n    if (self.isView(\"/home\")) return self.emit({\n      type: `do-view-task`,\n      data: {\n        payload: self.requestData,\n        callback: self.taskerHandler.bind(self)\n      }\n    });\n    return self.handlePathError();\n  }\n};\nconst parseRequest = function (req) {\n  const self = this;\n  self.pao.pa_wiLog(\"The req\");\n  self.pao.pa_wiLog(req.body);\n  self.pao.pa_wiLog(req.query);\n  self.pao.pa_wiLog(req.params);\n  // self.pao.pa_wiLog('THE REQUEST BODY')\n  // self.pao.pa_wiLog(req.body)\n  let requiredData = {\n    url: req.originalUrl\n  };\n  let url = requiredData.url.indexOf(\"/\") === 0 ? requiredData.url.slice(1, requiredData.url.length) : requiredData.url;\n  let isPath = url.indexOf(\"/\") > 0 ? true : false;\n  if (req.query && Object.keys(req.query).length > 0) {\n    self.pao.pa_wiLog(\"THE QUERY\");\n    self.pao.pa_wiLog(req.query);\n    requiredData.user = req.query;\n    let urlFragments = url.split(\"?\");\n    if (isPath) {\n      let pathFrags = urlFragments[0].split(\"/\");\n      self.pao.pa_wiLog(\"THE PATH FRAGS\");\n      self.pao.pa_wiLog(pathFrags);\n      requiredData.handler = pathFrags[0];\n    } else {\n      self.pao.pa_wiLog(\"THE REMAINING CONTENT AFTER SPLIT OF ?\");\n      self.pao.pa_wiLog(urlFragments);\n      requiredData.handler = urlFragments[0];\n    }\n  } else if (req.params && Object.keys(req.params).length > 0) {\n    self.pao.pa_wiLog(\"THE PARAMS\");\n    self.pao.pa_wiLog(req.params);\n    requiredData.user = req.params;\n    if (isPath) {\n      let pathFrags = url.split(\"/\");\n      self.pao.pa_wiLog(\"THE PATH FRAGS\");\n      self.pao.pa_wiLog(pathFrags);\n      requiredData.handler = pathFrags[0];\n    } else {\n      requiredData.handler = url;\n    }\n  } else if (req.body && Object.keys(req.body).length > 0) {\n    self.pao.pa_wiLog(\"THE REQUEST BODY\");\n    self.pao.pa_wiLog(req.body);\n    requiredData.user = req.body;\n    if (isPath) {\n      let pathFrags = url.split(\"/\");\n      self.pao.pa_wiLog(\"THE PATH FRAGS\");\n      self.pao.pa_wiLog(pathFrags);\n      requiredData.handler = pathFrags[0];\n    } else {\n      requiredData.handler = url;\n    }\n  } else {\n    requiredData.user = {};\n    if (isPath) {\n      let pathFrags = url.split(\"/\");\n      self.pao.pa_wiLog(\"THE PATH FRAGS\");\n      self.pao.pa_wiLog(pathFrags);\n      requiredData.handler = pathFrags[0];\n      delete requiredData.user;\n    } else {\n      requiredData.handler = url;\n      delete requiredData.user;\n    }\n  }\n  return requiredData;\n};\n// eslint-disable-next-line no-unused-vars\nconst handleRequestGlobalError = function () {\n  const self = this;\n  self.writeResponse({\n    error: true,\n    type: \"serverError\",\n    code: 502,\n    message: \"The server error\"\n  });\n};\n// eslint-disable-next-line no-unused-vars\nconst handlePathError = function () {\n  const self = this;\n  self.writeResponse({\n    error: true,\n    type: \"ServerError\",\n    code: 502,\n    message: \"The requested task[handler] could not be completed\"\n  });\n};\nconst handleRouterAliasList = function (data) {\n  const self = this;\n  self.pao.pa_wiLog(\"Router ALIATIKHANDLERS WITH DATA:\");\n  self.pao.pa_wiLog(data);\n  // self.writeResponse({error: true,type: 'ServerError',code: 502,message: 'The requested task[handler] could not be completed'})\n  self.routesAliasList = data.aliasList;\n  self.aliatikHandlers = data.handlers;\n};\nconst handleRequestGlobalResponse = function (data) {\n  const self = this;\n  if (!data) {\n    self.handleByHandlerError();\n  } else {\n    self.emit({\n      type: `handle-${self.requestData.handler}-task`,\n      data: {\n        payload: self.requestData,\n        callback: self.taskerHandler.bind(self)\n      }\n    });\n  }\n};\nconst isView = function (path, user = null) {\n  const self = this;\n  let views = self.views;\n  self.pao.pa_wiLog(\"THE VIEW PATH\");\n  self.pao.pa_wiLog(path);\n  self.pao.pa_wiLog(user);\n  self.pao.pa_wiLog(views);\n  // self.pao.pa_wiLog('.extention check status')\n  //  self.pao.pa_wiLog(path.indexOf('.'))\n  // if(path.indexOf('.') >= 0) return false\n  if (!user && path.trim() === \"/home\") {\n    self.pao.pa_wiLog(\"THE PARSED USsER\");\n    self.pao.pa_wiLog(self.requestData);\n    self.pao.pa_wiLog(path);\n    self.pao.pa_wiLog(views.indexOf(path) >= 0);\n    self.requestData.parsed.derivedUrl = \"/home\";\n    if (views.indexOf(path) >= 0) return true;\n    return false;\n  } else {\n    if (views.indexOf(path) >= 0) return true;\n    if (path.indexOf(\"?\") > 0) {\n      for (let qv = 0; qv <= views.length; qv++) {\n        if (path.indexOf(views[qv]) >= 0 && views[qv] !== \"/\") {\n          self.requestData.parsed.derivedUrl = views[qv];\n          return true;\n        } else if (qv === views.length - 1) {\n          return false;\n        }\n      }\n    }\n    let parasList = Object.keys(user);\n    let parasString = \"\";\n    self.pao.pa_wiLog(\"THE PARALIST\");\n    self.pao.pa_wiLog(parasList);\n    parasList.forEach((para, i) => {\n      i === 0 ? parasString = `:${para}` : parasString += `/:${para}`;\n    });\n    self.pao.pa_wiLog(\"thE PARARSTRING\");\n    self.pao.pa_wiLog(parasString);\n    for (let v = 0; v < views.length; v++) {\n      if (views[v].indexOf(parasString) > 0) {\n        let viewPath = views[v].substr(0, views[v].indexOf(parasString));\n        let comparePath = viewPath + parasString;\n        self.pao.pa_wiLog(\"EXTRACTED VIEW PATH\");\n        self.pao.pa_wiLog(viewPath);\n        self.pao.pa_wiLog(comparePath);\n        self.pao.pa_wiLog(path);\n        self.pao.pa_wiLog(path.indexOf(viewPath));\n        if (path.indexOf(viewPath) >= 0) {\n          self.pao.pa_wiLog(\"Theviewpath matched\");\n          self.requestData.parsed.derivedUrl = comparePath;\n          return true;\n        } else {\n          return false;\n        }\n      }\n    }\n  }\n  return false;\n};\nconst handleBadRequestError = function () {\n  const self = this;\n  self.writeResponse({\n    error: true,\n    type: \"BadRequest\",\n    code: 400,\n    message: \"Bad Request\"\n  });\n};\nconst handleHandlerNotFound = function () {\n  const self = this;\n  self.writeResponse({\n    error: true,\n    type: \"NotFound\",\n    code: 404,\n    message: \"The requested task could not be completed\"\n  });\n};\nconst handleByHandlerError = function () {\n  const self = this;\n  self.writeResponse({\n    error: true,\n    type: \"notFound\",\n    code: 404,\n    message: \"The requested task could not be completed\"\n  });\n};\nconst handleHandlerError = function () {\n  const self = this;\n  self.handleHandlerError();\n};\nconst writeResponse = function (data, method = \"regular\") {\n  const self = this;\n  const pao = self.pao;\n  // self.pao.pa_wiLog('THE DATA IN WRITERESPONSE')\n  // self.pao.pa_wiLog(data)\n  if (method === \"regular\") {\n    pao.pa_isString() ? data = pao.pa_jsToJson({\n      text: data\n    }) : data = pao.pa_jsToJson(data);\n  }\n  self.emit({\n    type: \"write-server-request-response\",\n    data: {\n      data: data,\n      res: self.request.res,\n      method: method\n    }\n  });\n};\nconst taskerHandler = function (fail = null, success = null, method = null) {\n  const self = this;\n  self.pao.pa_wiLog(\"THE TASKER HANDLER\");\n  self.pao.pa_wiLog(fail);\n  self.pao.pa_wiLog(method);\n  if (fail) {\n    self.failureHandle({\n      error: true,\n      message: fail\n    });\n  } else if (success) {\n    method ? self.successfullHandle(success, method) : self.successfullHandle(success);\n  }\n};\nconst successfullHandle = function (data, method) {\n  const self = this;\n  self.writeResponse(data, method);\n};\nconst failureHandle = function (data) {\n  const self = this;\n  self.writeResponse(data);\n};\n\n//# sourceURL=webpack://anzii/./lib/esm/request/methods.js?");

/***/ }),

/***/ "./lib/esm/request/request.js":
/*!************************************!*\
  !*** ./lib/esm/request/request.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _methods_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./methods.js */ \"./lib/esm/request/methods.js\");\n\nclass Request {\n  constructor(pao) {\n    this.pao = pao;\n    this.request = {};\n    this.routesAliasList = [];\n    this.aliatikHandlers = [];\n    this.requestData = null;\n    this.views = [];\n    this.init = _methods_js__WEBPACK_IMPORTED_MODULE_0__.init;\n    this.handleConfigRequest = _methods_js__WEBPACK_IMPORTED_MODULE_0__.handleConfigRequest;\n    this.handleRequestHandOver = _methods_js__WEBPACK_IMPORTED_MODULE_0__.handleRequestHandOver;\n    this.parseRequest = _methods_js__WEBPACK_IMPORTED_MODULE_0__.parseRequest;\n    this.handleRequestGlobalError = _methods_js__WEBPACK_IMPORTED_MODULE_0__.handleRequestGlobalError;\n    this.handleRequestGlobalResponse = _methods_js__WEBPACK_IMPORTED_MODULE_0__.handleRequestGlobalResponse;\n    this.isView = _methods_js__WEBPACK_IMPORTED_MODULE_0__.isView;\n    this.handleBadRequestError = _methods_js__WEBPACK_IMPORTED_MODULE_0__.handleBadRequestError;\n    this.handleHandlerNotFound = _methods_js__WEBPACK_IMPORTED_MODULE_0__.handleHandlerNotFound;\n    this.handleByHandlerError = _methods_js__WEBPACK_IMPORTED_MODULE_0__.handleByHandlerError;\n    this.handleHandlerError = _methods_js__WEBPACK_IMPORTED_MODULE_0__.handleHandlerError;\n    this.handlePathError = _methods_js__WEBPACK_IMPORTED_MODULE_0__.handlePathError;\n    this.handleRouterAliasList = _methods_js__WEBPACK_IMPORTED_MODULE_0__.handleRouterAliasList;\n    //  this.handleViewRender = methods.handleViewRender\n    //  this.renderView = methods.renderView\n    this.writeResponse = _methods_js__WEBPACK_IMPORTED_MODULE_0__.writeResponse;\n    this.taskerHandler = _methods_js__WEBPACK_IMPORTED_MODULE_0__.taskerHandler;\n    this.successfullHandle = _methods_js__WEBPACK_IMPORTED_MODULE_0__.successfullHandle;\n    this.failureHandle = _methods_js__WEBPACK_IMPORTED_MODULE_0__.failureHandle;\n  }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Request);\n\n//# sourceURL=webpack://anzii/./lib/esm/request/request.js?");

/***/ }),

/***/ "./lib/esm/router/index.js":
/*!*********************************!*\
  !*** ./lib/esm/router/index.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _router_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./router.js */ \"./lib/esm/router/router.js\");\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_router_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n//# sourceURL=webpack://anzii/./lib/esm/router/index.js?");

/***/ }),

/***/ "./lib/esm/router/methods.js":
/*!***********************************!*\
  !*** ./lib/esm/router/methods.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   appendRouter: () => (/* binding */ appendRouter),\n/* harmony export */   attachRoutes: () => (/* binding */ attachRoutes),\n/* harmony export */   filterCallback: () => (/* binding */ filterCallback),\n/* harmony export */   handOver: () => (/* binding */ handOver),\n/* harmony export */   handleAttachRoutes: () => (/* binding */ handleAttachRoutes),\n/* harmony export */   handleConfigRouter: () => (/* binding */ handleConfigRouter),\n/* harmony export */   handleRouterMiddleware: () => (/* binding */ handleRouterMiddleware),\n/* harmony export */   init: () => (/* binding */ init),\n/* harmony export */   middlewareType: () => (/* binding */ middlewareType),\n/* harmony export */   outOfRouterContext: () => (/* binding */ outOfRouterContext),\n/* harmony export */   renderRoute: () => (/* binding */ renderRoute)\n/* harmony export */ });\nconst init = function () {\n  this.adLog(\"Router has been initialised\");\n  this.listens({\n    \"config-router\": this.handleConfigRouter.bind(this),\n    \"router-middleware\": this.handleRouterMiddleware.bind(this),\n    \"attach-routes\": this.handleAttachRoutes.bind(this)\n  });\n};\nconst handleConfigRouter = function (data) {\n  const self = this;\n  self.pao.pa_wiLog(\"THE HANDLE CONFIG ROUTER MODULE\");\n  self.pao.pa_wiLog(data);\n  self.routes = data;\n};\nconst handleRouterMiddleware = function (data) {\n  const self = this;\n  self.pao.pa_wiLog(\"THE ROUTER MIDDLEWARE\");\n  self.pao.pa_wiLog(data);\n  self.routerMiddleware = data.middleware;\n};\nconst handleAttachRoutes = function (data) {\n  this.attachRoutes(data);\n};\nconst attachRoutes = function (data) {\n  const self = this;\n  console.log(\"ATTACHING ROUTES\", data);\n  if (data.app) {\n    let aliasList = [];\n    let aliatikHandlers = [];\n    data.app.use(self.cors());\n    data.app.use(\"/\", data.router);\n    if (!self.routes) {\n      self.warn(\"NO_CONFIGURED_ROUTES, ANZII WILL RESOLVE TO DEFAULT ROUTES\");\n      // self.warn('Anzii is rendering default routes::')\n      const defaultRoutes = [{\n        path: \"/greeting/:name/:surname\",\n        alias: \"hello\",\n        method: \"GET\",\n        type: \"public\"\n      }\n      // {\n      // path: '/test',\n      // method: 'POST',\n      // \ttype: 'public'\n      // },\n      // {\n      // \tpath: '/test',\n      // \tmethod: 'GET',\n      // \ttype: 'public'\n      // },\n      // {\n      // \tpath: '/',\n      // \tmethod: 'GET',\n      // \ttype: 'public'\n      // }\n      ];\n      defaultRoutes.forEach(r => {\n        if (r.alias) aliasList.push(r.path.split(\"/\")[1]), aliatikHandlers.push(r.alias);\n        r[\"router\"] = data.router;\n        self.renderRoute(r);\n      });\n      data.router.use(self.outOfRouterContext.bind(this));\n      aliasList.length > 0 ? self.emit({\n        type: \"router-alias-list\",\n        data: {\n          aliasList: aliasList,\n          handlers: aliatikHandlers\n        }\n        // eslint-disable-next-line no-mixed-spaces-and-tabs\n      }) : \"\";\n      return;\n    }\n    self.routes.forEach(r => {\n      if (r.alias) aliasList.push(r.path.split(\"/\")[1]), aliatikHandlers.push(r.alias);\n      r[\"router\"] = data.router;\n      self.renderRoute(r);\n    });\n    // data.router.use(\"*.js\", (req, res, next) => {\n    // \tres.set(\"Content-Type\", \"text/javascript\");\n    // \tconsole.log(\"SETTING JS\");\n    // \treturn res.status(200);\n    // });\n    // data.router.use(\n    // \t/\\.(gif|jpe?g|tiff?|png|webp|bmp|ico)$/i,\n    // \t(req, res, next) => {\n    // \t\tvar extname = path.extname(req.url);\n    // \t\tlet ext = \"\";\n\n    // \t\tswitch (extname) {\n    // \t\t\tcase \".png\":\n    // \t\t\t\text = \"image/png\";\n    // \t\t\t\tbreak;\n    // \t\t\tcase \".svg\":\n    // \t\t\t\text = \"image/svg+xml\";\n    // \t\t\t\tbreak;\n    // \t\t\tcase \".gif\":\n    // \t\t\t\text = \"image/gif\";\n    // \t\t\t\tbreak;\n    // \t\t\tcase \".jpeg\":\n    // \t\t\t\text = \"image/jpeg\";\n    // \t\t\t\tbreak;\n    // \t\t\tcase \".jpg\":\n    // \t\t\t\text = \"image/jpg\";\n    // \t\t\t\tbreak;\n    // \t\t\tdefault:\n    // \t\t\t\tconsole.log(\"UNKNOWN EXTENSION\");\n    // \t\t}\n    // \t\tconsole.log(\"SETTING IMAGES\");\n    // \t\tres.set(\"Content-Type\", `${ext}`);\n\n    // \t\treturn res.status(200);\n    // \t},\n    // );\n    // data.router.use(\"*.css\", (req, res, next) => {\n    // \tconsole.log(\"SETTING CSS\");\n    // \tres.set(\"Content-Type\", \"text/css\");\n    // \treturn res.status(200);\n    // });\n\n    data.router.use(self.outOfRouterContext.bind(this));\n    // data.app.get(\"/*\", self.outOfRouterContext.bind(this));\n    aliasList.length > 0 ? self.emit({\n      type: \"router-alias-list\",\n      data: {\n        aliasList: aliasList,\n        handlers: aliatikHandlers\n      }\n      // eslint-disable-next-line no-mixed-spaces-and-tabs\n    }) : \"\";\n  }\n};\nconst renderRoute = function (r) {\n  const self = this;\n  const pao = this.pao;\n  console.log(\"ATTACHING ROUTES: RENDER ROUTE\", self.routerMiddleware, r.type);\n  let routy = {\n    router: r.router,\n    method: r.method,\n    path: r.path,\n    handOver: self.handOver\n  };\n  // self.pao.pa_wiLog('THE ROUTE MIDDLEWARE')\n  // self.pao.pa_wiLog(self.routerMiddleware.public)\n  if (r.middlewares) {\n    if (self.routerMiddleware && self.routerMiddleware[r.type]) {\n      self.middlewareType(r.type, r.middlewares);\n      self.middlewareType(r.type, pao.pa_objectToArray(self.routerMiddleware[r.type]));\n      self.appendRouter({\n        middleware: self[`filtered${r.type}Middlewares`],\n        ...routy\n      });\n      self[`filtered${r.type}Middlewares`] = [];\n    } else {\n      self.middlewareType(r.type, r.middlewares);\n      self.appendRouter({\n        middleware: self[`filtered${r.type}Middlewares`],\n        ...routy\n      });\n      self[`filtered${r.type}Middlewares`] = [];\n    }\n  } else if (self.routerMiddleware && self.routerMiddleware[r.type]) {\n    self.middlewareType(r.type, pao.pa_objectToArray(self.routerMiddleware[r.type]));\n    self.appendRouter({\n      middleware: self[`filtered${r.type}Middlewares`],\n      ...routy\n    });\n    self[`filtered${r.type}Middlewares`] = [];\n  } else {\n    self.appendRouter(routy);\n    self[`filteredpublicMiddlewares`] = [];\n    self[`filteredprivateMiddlewares`] = [];\n  }\n};\nconst appendRouter = function (r) {\n  // self.pao.pa_wiLog('THE APPENDROUTER')\n  // self.infoSync('THE CURRENT ROUTER')\n  // self.infoSync(r)\n  if (r.middleware) {\n    // self.info('THE CURRENT ROUTER with middleware')\n    // self.infoSync(r.path)\n    // self.infoSync(r.middleware)\n    // self.infoSync(r.handOver)\n    console.log(\"THE ROUTER BEING CONFIGURED\", r);\n    r.router[r.method.toLowerCase()](r.path, r.middleware, r.handOver.bind(this));\n  } else {\n    // self.info('THE CURRENT ROUTER with middleware')\n    // self.infoSync(r.path)\n    // self.infoSync(r.middleware)\n    // self.infoSync(r.handOver)\n    r.router[r.method.toLowerCase()](r.path, r.handOver.bind(this));\n  }\n};\nconst middlewareType = function (type, middlewares) {\n  const self = this;\n  // self.pao.pa_wiLog('THE MIDDLEWARETYP MIDDLEWARES')\n  // self.pao.pa_wiLog(middlewares)\n  // self.infoSync('The Router middlewares')\n  // self.infoSync(middlewares)\n  middlewares.forEach(m => {\n    if (m.type === \"function\") {\n      self[`filtered${type}Middlewares`].push(m.value);\n    } else if (m.type === \"module\") {\n      self.emit({\n        type: `add-${m.value}-middleware`,\n        data: {\n          type: type,\n          filterCallback: self.filterCallback.bind(self)\n        }\n      });\n    }\n  });\n};\nconst outOfRouterContext = async function (req, res) {\n  const self = this;\n  let data = null;\n  let reqresID = self.pao.pa_generateUniqueID();\n  req.R_ID = reqresID;\n  res.R_ID = reqresID;\n  self.infoSync(\"Handling out of context route\");\n  self.infoSync(req.originalUrl);\n  self.adLog(\"THE OUTOFROUTERCONTEXT REQUESTS\");\n  // let folderPatH = `${self.pao.pa_getWorkingFolder()}${self.path.sep}build${\n  // \tself.path.sep\n  // }index.html`;\n\n  // data = {\n  // \terror: false,\n  // \taccepts: \"html\",\n  // \ttype: \"StaticServe\",\n  // \tcode: 200,\n  // \tsendFile: true,\n  // \tfileSource: folderPatH,\n  // };\n  // if (self) {\n  // \treturn res.sendFile(folderPatH);\n  // \t// return self.emit({\n  // \t// \ttype: \"write-server-request-response\",\n  // \t// \tdata: { data: data, res: res },\n  // \t// });\n  // }\n\n  // self.logSync(req.is)\n  // self.logSync(req.get)\n  // self.logSync(req.is('text'))\n  self.adLog(req.accepts([\"html\", \"json\"]));\n  console.log(\"THE ACCEPTED WITH TYPE\", req.get(\"Content-Type\"));\n  // self.logSync(req.accepts())\n  if (req.accepts([\"html\", \"json\"]) === \"json\") {\n    data = {\n      error: false,\n      accepts: \"html\",\n      type: \"StaticServe\",\n      code: 200,\n      sendFile: true,\n      fileSource: folderPath\n    };\n  } else if (req.accepts([\"html\", \"json\"]) === \"html\") {\n    // console.log(\"REQUEST ACCEPTS IN HTML\", req.accepts([\"html\", \"json\"]));\n    // let folderPath = `${self.pao.pa_getWorkingFolder()}${self.path.sep}views${\n    // \tself.path.sep\n    // }index.html`;\n    // self.pao.pa_wiLog(`folder path: ${folderPath}`);\n    // self.pao.pa_wiLog(`working folder: ${self.pao.pa_getWorkingFolder()}`);\n    // self.pao.pa_wiLog(\n    // \t`IS EXISTING FOLDER VIEWS: ${self.pao.pa_isExistingDir(\n    // \t\tfolderPath.trim(),\n    // \t)}`,\n    // );\n    // if (self.pao.pa_isExistingDir(folderPath.trim())) {\n    // \tdata = {\n    // \t\terror: false,\n    // \t\taccepts: \"html\",\n    // \t\ttype: \"StaticServe\",\n    // \t\tcode: 200,\n    // \t\tsendFile: true,\n    // \t\tfileSource: folderPath,\n    // \t};\n    // } else {\n    // \tdata = {\n    // \t\terror: true,\n    // \t\taccepts: \"html\",\n    // \t\ttype: \"NotFound\",\n    // \t\tcode: 404,\n    // \t\tmessage: \"Resource was not found: OutOfContext\",\n    // \t};\n    // }\n\n    data = {\n      error: true,\n      accepts: \"html\",\n      type: \"NotFound\",\n      code: 404,\n      message: \"Resource was not found: OutOfContext\"\n    };\n  } else {\n    data = {\n      error: true,\n      accepts: \"txt\",\n      type: \"NotFound\",\n      code: 404,\n      message: \"Resource was not found: OutOfContext\"\n    };\n  }\n  return self.emit({\n    type: \"write-server-request-response\",\n    data: {\n      data: data,\n      res: res\n    }\n  });\n};\nasync function handOver(req, res, next) {\n  const self = this;\n  console.log(\"HANDOVER IS IN ACTION\");\n  await self.pao.pa_wiLog(\"THE CAUGHT REQUEST INSIDE ROUTER::END POINT HIT\");\n  self.infoSync(next);\n  let reqresID = self.pao.pa_generateUniqueID();\n  req.R_ID = reqresID;\n  res.R_ID = reqresID;\n  self.infoSync(`HANDLING REQUEST OF ID: ${req.R_ID.split(\"-\")[0]} WITH METHOD: ${req.method} AND URL OF: ${req.originalUrl}`);\n  await self.pao.pa_wiLog(req.originalUrl);\n  await self.pao.pa_wiLog(req.params);\n  await self.pao.pa_wiLog(req.body);\n  return self.emit({\n    type: \"request-handover\",\n    data: {\n      req: req,\n      res: res,\n      next: next\n    }\n  });\n  // return res.json({todo:{list:{items:['I ate food','I wrote code','I read a book','I watched a movie']}}})\n}\nconst filterCallback = function (filterType, moduleMiddleware) {\n  const self = this;\n  if (filterType === \"public\") {\n    self.filteredpublicMiddlewares.push(moduleMiddleware);\n  } else {\n    self.filteredprivateMiddlewares.push(moduleMiddleware);\n  }\n};\n\n//# sourceURL=webpack://anzii/./lib/esm/router/methods.js?");

/***/ }),

/***/ "./lib/esm/router/router.js":
/*!**********************************!*\
  !*** ./lib/esm/router/router.js ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var cors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cors */ \"cors\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var _methods_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./methods.js */ \"./lib/esm/router/methods.js\");\n\n\n\nclass Router {\n  constructor(pao) {\n    this.pao = pao;\n    this.routes = null;\n    this.routerMiddleware = null;\n    this.filteredpublicMiddlewares = [];\n    this.filteredprivateMiddlewares = [];\n    this.path = path__WEBPACK_IMPORTED_MODULE_1__;\n    this.cors = cors__WEBPACK_IMPORTED_MODULE_0__;\n    this.init = _methods_js__WEBPACK_IMPORTED_MODULE_2__.init;\n    this.handleConfigRouter = _methods_js__WEBPACK_IMPORTED_MODULE_2__.handleConfigRouter;\n    this.handleAttachRoutes = _methods_js__WEBPACK_IMPORTED_MODULE_2__.handleAttachRoutes;\n    this.handleRouterMiddleware = _methods_js__WEBPACK_IMPORTED_MODULE_2__.handleRouterMiddleware;\n    this.attachRoutes = _methods_js__WEBPACK_IMPORTED_MODULE_2__.attachRoutes;\n    this.renderRoute = _methods_js__WEBPACK_IMPORTED_MODULE_2__.renderRoute;\n    this.appendRouter = _methods_js__WEBPACK_IMPORTED_MODULE_2__.appendRouter;\n    this.middlewareType = _methods_js__WEBPACK_IMPORTED_MODULE_2__.middlewareType;\n    this.outOfRouterContext = _methods_js__WEBPACK_IMPORTED_MODULE_2__.outOfRouterContext;\n    this.handOver = _methods_js__WEBPACK_IMPORTED_MODULE_2__.handOver;\n    this.filterCallback = _methods_js__WEBPACK_IMPORTED_MODULE_2__.filterCallback;\n  }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Router);\n\n//# sourceURL=webpack://anzii/./lib/esm/router/router.js?");

/***/ }),

/***/ "./lib/esm/server/index.js":
/*!*********************************!*\
  !*** ./lib/esm/server/index.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _server_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./server.js */ \"./lib/esm/server/server.js\");\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_server_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n//# sourceURL=webpack://anzii/./lib/esm/server/index.js?");

/***/ }),

/***/ "./lib/esm/server/methods.js":
/*!***********************************!*\
  !*** ./lib/esm/server/methods.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getHtml: () => (/* binding */ getHtml),\n/* harmony export */   getHtmlSkeleton: () => (/* binding */ getHtmlSkeleton),\n/* harmony export */   handleConfigServer: () => (/* binding */ handleConfigServer),\n/* harmony export */   handleDomainResources: () => (/* binding */ handleDomainResources),\n/* harmony export */   handleWriteServerRequestResponse: () => (/* binding */ handleWriteServerRequestResponse),\n/* harmony export */   init: () => (/* binding */ init),\n/* harmony export */   renderHtml: () => (/* binding */ renderHtml),\n/* harmony export */   runServer: () => (/* binding */ runServer),\n/* harmony export */   startPreRoutes: () => (/* binding */ startPreRoutes),\n/* harmony export */   startRouting: () => (/* binding */ startRouting),\n/* harmony export */   startServer: () => (/* binding */ startServer),\n/* harmony export */   streamResponse: () => (/* binding */ streamResponse)\n/* harmony export */ });\n/* eslint-disable no-mixed-spaces-and-tabs */\n/* eslint-disable no-unused-vars */\nconst init = function () {\n  this.adLog(\"Server has been initialised\");\n  this.adLog(\"SERVER IS STARTING UP\");\n  //   self.pao.pa_wiLog(this.pao)\n  //   self.pao.pa_wiLog(this)\n  this.listens({\n    \"config-server\": this.handleConfigServer.bind(this),\n    \"config-domain-resources\": this.handleDomainResources.bind(this),\n    \"write-server-request-response\": this.handleWriteServerRequestResponse.bind(this)\n  });\n};\nconst handleConfigServer = function (data) {\n  const self = this;\n  // self.emit({type:'share-middleware',data:''})\n  self.emit({\n    type: \"attach-middleware\",\n    data: {\n      app: self.http,\n      xpress: self.xpress\n    }\n  });\n  self.emit({\n    type: \"attach-routes\",\n    data: {\n      app: self.http,\n      router: self.router\n    }\n  });\n  self.emit({\n    type: \"distribute-system-resources\",\n    data: \"\"\n  });\n  self.startServer();\n};\nconst handleDomainResources = function (data = null) {\n  const self = this;\n  self.pao.pa_wiLog(\"THE server is emitting system defaults event\");\n  //Custom to be removed\n  self.emit({\n    type: \"set-domain-defaults\",\n    data: {\n      app: self.http,\n      xpress: self.xpress\n    }\n  });\n};\nconst startServer = function (data) {\n  const self = this;\n  // this.startPreRoutes()\n  // this.startRouting()\n  this.runServer();\n};\nconst startPreRoutes = function () {\n  const self = this;\n  self.http.use(self.dependiks.bodyParser.json());\n  // self.http.use(function(req, res, next) {\n  // \t// self.pao.pa_wiLog(req.body)\n  // \t// self.pao.pa_wiLog('Your mobile has reached this code Surprise')\n  // \tres.header(\"Access-Control-Allow-Origin\", \"*\");\n  // \tres.header(\"Access-Control-Allow-Headers\", \"Origin, X-Requested-With, Content-Type, Accept\");\n  // \treturn next();\n  // });\n  self.http.use(\"*.js\", function (req, res, next) {\n    // self.pao.pa_wiLog(req.body)\n    // self.pao.pa_wiLog('Your mobile has reached this code Surprise')\n    res.set(\"content-type\", \"text/javascript\");\n    return next();\n  });\n  self.http.use(self.xpress.static(\"public\"));\n};\nconst startRouting = function () {\n  const self = this;\n  //   self.http.get('/smarfo/menu',function(req,res){\n  // \tself.pao.pa_wiLog('Request for menu has just been received')\n  // \tlet categories = require('./jsondb/foodcategories.json');\n  // \treturn res.send(categories.menu);\n  // })\n  self.http.get(\"/todo\", self.renderHtml.bind(self));\n  self.http.get(\"/ibr\", self.renderHtml.bind(self));\n  self.http.get(\"/home\", self.renderHtml.bind(self));\n  self.http.use(\"/\", self.renderHtml.bind(self));\n};\nconst runServer = function () {\n  const self = this;\n  self.emit({\n    type: \"attach-workers-to-server\",\n    data: {\n      app: self.http\n    }\n  });\n  // self.http.listen(process.env.PORT || 3000,()=>{\n  //   self.log(\"The Server is listening\",'info')\n  // })\n};\nconst renderHtml = function (req, res) {\n  const self = this;\n  self.pao.pa_wiLog(\"A request has been made to one of the routes\");\n  self.pao.pa_wiLog(\"The html\");\n  self.pao.pa_wiLog(\"The request URL\");\n  self.pao.pa_wiLog(req.url);\n  self.request = {\n    req: req,\n    res: res\n  };\n  self.emit({\n    type: \"address-changed\",\n    data: {\n      url: req.url\n    }\n  });\n  //    self.pao.pa_wiLog(this)\n};\nconst handleWriteServerRequestResponse = async function (data) {\n  const self = this;\n  self.pao.pa_wiLog(\"THE DATA TO BE SENT TO CLIENT\");\n  self.pao.pa_wiLog(data.method);\n  self.pao.pa_wiLog(data.method === \"renderView\");\n  if (data.method === \"stream\") {\n    return self.streamResponse(data);\n  } else if (data.method === \"renderView\") {\n    self.pao.pa_wiLog(\"THE RENDERVIEW\");\n    self.pao.pa_wiLog(data);\n    let view = data.data.data;\n    self.pao.pa_wiLog(\"MAKING A VIEW request response\");\n    data.res.set(\"Connection\", \"close\");\n    // self.pao.pa_wiLog(data)\n    // self.pao.pa_wiLog(data.method)\n    // self.pao.pa_wiLog(data.data)\n    // self.pao.pa_wiLog(view)\n    // self.pao.pa_wiLog(data.data.type === 'template')\n    if (view.type.trim() === \"template\") {\n      self.pao.pa_wiLog(\"Rendering template view\");\n      self.pao.pa_wiLog(data.data.view);\n      self.pao.pa_wiLog(\"Rendering inside try\");\n      self.getHtml(data.res, view).then(async html => {\n        html.success ? (data.res.status(200).send(html.html),\n        // eslint-disable-next-line no-mixed-spaces-and-tabs\n        // eslint-disable-next-line no-mixed-spaces-and-tabs\n        self.infoSync(`SERVER HAS SUCCESSFULLY SENT RESPONSE TO CLIENT WITH RESPONSE ID::${data.res.R_ID.split(\"-\")[0]}`\n        // eslint-disable-next-line no-mixed-spaces-and-tabs\n        )) : (data.res.status(200).send(html.html), self.infoSync(`SERVER HAS SENT A FAILED RESPONSE BACK TO CLIENT WITH RESPONSE ID::${data.res.R_ID.split(\"-\")[0]}`));\n      }).catch(e => {\n        data.res.status(200).send(e.html);\n      });\n      return;\n    } else if (view.type === \"modular\") {\n      self.pao.pa_wiLog(\"rENDEING MODULAR VIEW\");\n      // self.infoSync(view.view)\n      data.res.status(200).send(view.view);\n      return self.infoSync(`SERVER HAS SUCCESSFULLY SENT RESPONSE TO CLIENT WITH RESPONSE ID::${data.res.R_ID.split(\"-\")[0]}`);\n    }\n    // self.streamResponse(data)\n  } else {\n    data.R_ID ? self.infoSync(`SERVER IS ABOUT TO SEND RESPONSE BACK TO CLIENT WITH RESPONSE ID::${data.res.R_ID.split(\"-\")[0]}`) : self.infoSync(`SERVER IS ABOUT TO SEND RESPONSE BACK TO CLIENT WITH RESPONSE`);\n    await self.adLog(data.data);\n    await data.res.set(\"Connection\", \"close\");\n    if (data.data.accepts) {\n      switch (data.data.accepts) {\n        case \"json\":\n          data.res.status(200).send(data.data);\n          break;\n        case \"html\":\n          self.getHtml(data.res, {\n            view: \"main/404\",\n            title: \"Page could not be found\"\n          }).then(html => {\n            return data.res.status(200).send(html.html);\n          }).catch(e => {\n            return data.res.status(200).send(e.html);\n          });\n          break;\n        default:\n          data.res.type(\"txt\").status(200).send(\"Text not found\");\n      }\n    } else {\n      data.res.status(200).send(data.data);\n    }\n    // await data.res.end()\n    // // self.pao.pa_wiLog(data.data)\n    return await self.log(\"SERVER HAS SENT A RESPONSE BACK TO CLIENT\");\n  }\n};\nconst streamResponse = function (data) {\n  const self = this;\n  const pao = self.pao;\n  // const jsonToJs = pao.pa_jsonToJs\n  // let data = jsonToJs(dt)\n  // self.pao.pa_wiLog('THE STREAM IS RUNNING')\n  // self.pao.pa_wiLog(data)\n  const type = self.mimeTypes[data.data.ext];\n  let rStream = data.data.rStream;\n  const withAttachment = data.data.withAttachment || null;\n  if (withAttachment) data.res[\"withAttachment\"] = {\n    ...withAttachment\n  };\n  // self.infoSync('Server is processing stream')\n  // self.infoSync(rStream)\n  // self.infoSync(data)\n  rStream.on(\"open\", async function () {\n    // self.pao.pa_wiLog('INSIDE ON AND PIPING')\n    // self.pao.pa_wiLog(type)\n    self.infoSync(\"THE STREAM IS OPENED\");\n    data.res.set(\"Content-Type\", type);\n    data.res.set(\"Connection\", \"close\");\n    return rStream.pipe(data.res);\n    // return await self.log('SERVER HAS SENT A STREAM RESPONSE BACK TO THE CLIENT ENDING REQUEST SOON')\n  });\n  rStream.on(\"end\", async function () {\n    data.res.end();\n    // return await self.log('Stream request has been successfully served WITH END')\n    return self.infoSync(`STREAM REQUEST HAS BEEN SUCCESSFULLY HANDLED WITH RESPONSE ID::${data.res.R_ID.split(\"-\")[0]}`);\n  });\n  rStream.on(\"error\", async function (e) {\n    self.pao.pa_wiLog(\"THE ERROR READSTREAM\");\n    self.pao.pa_wiLog(e);\n    data.res.set(\"Content-Type\", \"application/json\");\n    data.res.set(\"Connection\", \"close\");\n    return data.res.status(404).send({\n      error: true,\n      message: \"Not found\"\n    });\n    // data.res.end();\n    // return  await self.log('SERVER HAS SENT A STREAM RESPONSE BACK TO THE CLIENT WITH ERROR')\n  });\n};\nconst getHtml = function (res, view) {\n  const self = this;\n  const pao = self.pao;\n  self.pao.pa_wiLog(\"THE SET VIEW\");\n  self.pao.pa_wiLog(view);\n  return new Promise((resolve, reject) => {\n    let viewda = null;\n    view.viewData ? viewda = view.viewData : viewda = {\n      title: view.title\n    };\n    res.render(view.view, viewda, (err, html) => {\n      if (err) {\n        self.pao.pa_wiLog(\"THE ERROR BELOW OCCURED TRYING TO RENDER VIEW\");\n        self.pao.pa_wiLog(err);\n        res.render(\"main/500\", {\n          title: \"Server error\"\n        }, (err, html) => {\n          if (err) return resolve({\n            html: \"<hl>The page could not be found</h1>\",\n            success: false\n          });\n          return resolve({\n            html: html,\n            success: true\n          });\n        });\n        //   data.res.status(404).send({error: true, message: 'The requested view was not found'})\n        //   return self.pao.pa_wiLog('SERVER HAS SENT A FAILED RESPONSE BACK TO THE CLIENT::REGULAR')\n      } else {\n        return resolve({\n          html: html,\n          success: true\n        });\n        // return self.pao.pa_wiLog('SERVER HAS SENT A SUCCESSFULL RESPONSE BACK TO THE CLIENT::REGULAR')\n      }\n    });\n  });\n};\nconst getHtmlSkeleton = function (html, head = null, scripts = []) {\n  const self = this;\n  const {\n    serialize\n  } = self;\n  return `\n\t\t<!doctype html>\n\t\t<html>\n\n    <head>\n\t\t  <title>${head?.title}</title>\n   \n    </head>\n\t\t<body>\n\t\t\t<div id=\"root\">${html}</div>\n\t\t\t\n\n\t\t</body>\n\t\t</html>\n    `;\n};\n\n//# sourceURL=webpack://anzii/./lib/esm/server/methods.js?");

/***/ }),

/***/ "./lib/esm/server/server.js":
/*!**********************************!*\
  !*** ./lib/esm/server/server.js ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("var body_parser__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var body_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! body-parser */ \"body-parser\");\n/* harmony import */ var express__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! express */ \"express\");\n/* harmony import */ var jsonfile__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jsonfile */ \"jsonfile\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var _methods_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./methods.js */ \"./lib/esm/server/methods.js\");\n\n\n\n\n\n// const app = express()\n// import notifier from './notifier'\nclass Server {\n  constructor(pao) {\n    this.pao = pao;\n    this.xpress = express__WEBPACK_IMPORTED_MODULE_1__;\n    this.http = this.xpress();\n    this.router = this.xpress.Router();\n    this.path = path__WEBPACK_IMPORTED_MODULE_3__;\n    this.html = [];\n    this.request = null;\n    this.componentCount = 0;\n    this.componentId = [];\n    this.ssrComponentLen = 0;\n    this.componentRefLen = 0;\n    this.workers = [];\n    this.fixedCompS = {\n      before: [],\n      after: []\n    };\n    this.compData = [];\n    this.dependiks = {\n      jsonfile: jsonfile__WEBPACK_IMPORTED_MODULE_2__,\n      bodyParser: /*#__PURE__*/ (body_parser__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (body_parser__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(body_parser__WEBPACK_IMPORTED_MODULE_0__, 2)))\n    };\n    this.mimeTypes = {\n      html: \"text/html\",\n      txt: \"text/plain\",\n      css: \"text/css\",\n      gif: \"image/gif\",\n      jpg: \"image/jpeg\",\n      png: \"image/png\",\n      svg: \"image/svg+xml\",\n      js: \"application/javascript\"\n    };\n    // methods\n    this.init = _methods_js__WEBPACK_IMPORTED_MODULE_4__.init;\n    this.handleConfigServer = _methods_js__WEBPACK_IMPORTED_MODULE_4__.handleConfigServer;\n    this.handleDomainResources = _methods_js__WEBPACK_IMPORTED_MODULE_4__.handleDomainResources;\n    this.handleWriteServerRequestResponse = _methods_js__WEBPACK_IMPORTED_MODULE_4__.handleWriteServerRequestResponse;\n    this.startServer = _methods_js__WEBPACK_IMPORTED_MODULE_4__.startServer;\n    this.startPreRoutes = _methods_js__WEBPACK_IMPORTED_MODULE_4__.startPreRoutes;\n    this.startRouting = _methods_js__WEBPACK_IMPORTED_MODULE_4__.startRouting;\n    this.streamResponse = _methods_js__WEBPACK_IMPORTED_MODULE_4__.streamResponse;\n    this.runServer = _methods_js__WEBPACK_IMPORTED_MODULE_4__.runServer;\n    this.renderHtml = _methods_js__WEBPACK_IMPORTED_MODULE_4__.renderHtml;\n    this.streamResponse = _methods_js__WEBPACK_IMPORTED_MODULE_4__.streamResponse;\n    this.getHtml = _methods_js__WEBPACK_IMPORTED_MODULE_4__.getHtml;\n    this.getHtmlSkeleton = _methods_js__WEBPACK_IMPORTED_MODULE_4__.getHtmlSkeleton;\n  }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Server);\n\n//# sourceURL=webpack://anzii/./lib/esm/server/server.js?");

/***/ }),

/***/ "./lib/esm/system/index.js":
/*!*********************************!*\
  !*** ./lib/esm/system/index.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _system_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./system.js */ \"./lib/esm/system/system.js\");\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_system_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n//# sourceURL=webpack://anzii/./lib/esm/system/index.js?");

/***/ }),

/***/ "./lib/esm/system/methods.js":
/*!***********************************!*\
  !*** ./lib/esm/system/methods.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getServerPort: () => (/* binding */ getServerPort),\n/* harmony export */   handleConfigureSystem: () => (/* binding */ handleConfigureSystem),\n/* harmony export */   handleDistributeSystemResources: () => (/* binding */ handleDistributeSystemResources),\n/* harmony export */   handleRegisterShutDownCandidate: () => (/* binding */ handleRegisterShutDownCandidate),\n/* harmony export */   handleServerAttachWorkers: () => (/* binding */ handleServerAttachWorkers),\n/* harmony export */   handleShutDowns: () => (/* binding */ handleShutDowns),\n/* harmony export */   init: () => (/* binding */ init),\n/* harmony export */   masterWorker: () => (/* binding */ masterWorker),\n/* harmony export */   openBrowserApp: () => (/* binding */ openBrowserApp),\n/* harmony export */   shutDown: () => (/* binding */ shutDown)\n/* harmony export */ });\n/* eslint-disable no-unused-vars */\nconst init = function () {\n  this.adLog(\"System has been initialised\");\n  this.listens({\n    \"config-system\": this.handleConfigureSystem.bind(this),\n    \"register-shutdown-candidate\": this.handleRegisterShutDownCandidate.bind(this),\n    \"distribute-system-resources\": this.handleDistributeSystemResources.bind(this),\n    \"attach-workers-to-server\": this.handleServerAttachWorkers.bind(this)\n  });\n  // self.pao.pa_wiLog(this.env)\n};\nconst handleConfigureSystem = function (data) {\n  const self = this;\n  self.pao.pa_wiLog(`System ENVIROMENT IS: ${self.env}`, process.env);\n  self.pao.pa_wiLog(self.env);\n  // self.pao.pa_wiLog(cwd)\n  // self.pao.pa_wiLog(path.sep)\n  // self.pao.pa_wiLog(path.sep+'includes')\n  // self.pao.pa_wiLog(cwd.substr(0, cwd.indexOf(path.sep+'includes')) >= 0)\n  self.pao.pa_wiLog(self.systemBase?.DOCUMENT_ROOT);\n  self.handleShutDowns();\n  self.clusterCustomConfig = data;\n  self.adLog(\"The system is about to emit system resources to premier modules\");\n  self.emit({\n    type: \"take-premier-system-base\",\n    data: {\n      systemBase: self.systemBase\n    }\n  });\n  // self.masterWorker(data)\n};\nconst handleDistributeSystemResources = async function (data) {\n  const self = this;\n  const pao = self.pao;\n  const getFiles = pao.pa_getFiles;\n  const getDirs = pao.pa_getDirectories;\n  const getFile = pao.pa_getFile;\n  const makeDirs = pao.pa_makeDirs;\n  const getExtension = pao.pa_getExtension;\n  const path = self.path;\n  let dirPath = `${self.systemBase.DOCUMENT_ROOT}`;\n  let filePath = `${self.systemBase.DOCUMENT_ROOT}${path.sep}sev.js`;\n  let createPath = `${self.systemBase.DOCUMENT_ROOT}${path.sep}`;\n  // const path = self.path\n  // const cwd = process.cwd()\n  // self.pao.pa_wiLog(cwd)\n  // self.pao.pa_wiLog(path.sep)\n  // self.pao.pa_wiLog(path.sep+'includes')\n  // self.pao.pa_wiLog(cwd.substr(0, cwd.indexOf(path.sep+'includes')) >= 0)\n  // self.pao.pa_wiLog('HandleDistributeSystemResources ')\n  // // let files = await getFiles(dirPath,{recursive: false},'sev.js')\n  // let dirs = await getDirs(dirPath)\n  // let file = await getFile(filePath)\n  let status = await makeDirs(createPath);\n  let ext = getExtension(\"sev.js\");\n  // self.pao.pa_wiLog('GET FILES CALLBACK GETS A CALL')\n  // self.pao.pa_wiLog(files)\n  // self.pao.pa_wiLog(dirs)\n  // self.pao.pa_wiLog(file)\n  self.pao.pa_wiLog(ext);\n  self.pao.pa_wiLog(status);\n  self.emit({\n    type: \"take-system-base\",\n    data: {\n      systemBase: self.systemBase\n    }\n  });\n  // self.masterWorker(data)\n};\nconst shutDown = function (type, code) {\n  const self = this;\n  console.log(`SHUTDOWN TYPE: ${type},code: ${code}`);\n  console.log(code);\n  self.systemIsShuttingDown = true;\n  if (self.shutDownServices.length > 0) {\n    self.shutDownServices.forEach((sd, i) => {\n      if (typeof sd !== \"function\") {\n        console.log(`Service: ${self.shutDownOrder[i]} must be a function,shutdown attempt failed`, \"warn\");\n      } else {\n        console.log(`Service: ${self.shutDownOrder[i]} is shutting down`, \"info\");\n      }\n    });\n  }\n  console.log(`System is shutting down through: ${type},with code: ${code.stack}`);\n  type === \"uncaughtException\" ? self.context.kill(1) : self.context[type]();\n};\nconst masterWorker = function (app) {\n  const self = this;\n  console.log(\"ENV PORT\", self?.context?.env?.PORT);\n  const serverTimeout = self.serverTimeout;\n  const portToUse = self?.context?.env?.PORT ? self?.context?.env?.PORT : 3000;\n  const shouldOpenBrowser = self?.context?.env?.ANZII_OPEN_BROWSER ? true : false;\n  const shouldStopServer = self?.context?.env?.ANZII_STOP_SERVER ? true : false;\n  self.getServerPort(portToUse).then(availablePort => {\n    self.pao.pa_wiLog(`THE AVAILABLE PORT, ${availablePort}`);\n    self.pao.pa_wiLog(`THE STATUS OF isMaster: ${self.cluster.isMaster}`);\n    self.pao.pa_wiLog(`THE cluster, ${self.cluster}`);\n    self.pao.pa_wiLog(`THE CLUSTERS, ${self.clusterCustomConfig}`);\n    if (self.cluster.isMaster) {\n      self.pao.pa_wiLog(`Master ${self.context.pid} is running`);\n      if (self.clusterCustomConfig && self.clusterCustomConfig.spawn) {\n        let slaves = self.clusterCustomConfig.workers ? self.clusterCustomConfig.workers : \"auto\";\n        if (slaves === \"auto\") {\n          slaves = self.os.cpus().length;\n          for (let s = 0; slaves < slaves; s++) {\n            self.cluster.fork();\n          }\n        } else {\n          if (typeof slaves === \"number\") {\n            for (let s = 0; s < slaves; s++) {\n              self.pao.pa_wiLog(`Forking slave number: ${s}`);\n              self.cluster.fork();\n            }\n          }\n        }\n        self.cluster.on(\"fork\", worker => {\n          self.pao.pa_wiLog(\"cluster forking new worker\", worker.id);\n        });\n        let mainWorkerId = null;\n        self.cluster.on(\"listening\", (worker, address) => {\n          self.pao.pa_wiLog(\"cluster listening new worker\", worker.id);\n          if (null === mainWorkerId) {\n            self.pao.pa_wiLog(\"Making worker \" + worker.id + \" to main worker\");\n            mainWorkerId = worker.id;\n            worker.send({\n              singleProcessTasks: \"startSingleProcessTasks\"\n            });\n          }\n        });\n        self.cluster.on(\"exit\", (worker, code, signal) => {\n          self.pao.pa_wiLog(`worker ${worker.process.pid} died`);\n          self.pao.pa_wiLog(\"FORKING ANOTHER WORK\");\n          self.pao.pa_wiLog(\"Worker %d died :(\", worker.id);\n          if (!shouldStopServer) {\n            if (worker.id === mainWorkerId) {\n              self.pao.pa_wiLog(\"Main Worker is dead...\");\n              mainWorkerId = null;\n            }\n            self.pao.pa_wiLog(\"I am here\");\n            self.pao.pa_wiLog(worker);\n            self.pao.pa_wiLog(code);\n            self.pao.pa_wiLog(signal);\n            self.cluster.fork();\n            // self.cluster.fork()\n          } else {\n            console.log(\"Server has been shutdown\");\n          }\n        });\n      } else {\n        self.adLog(\"System is running on a single thread/core\");\n        const serv = app.listen(availablePort, () => {\n          self.infoSync(`The Server is listening via a worker on port:${availablePort}`);\n          self.adLog(\"THIS WORKER RUNNING IP:\");\n          if (shouldOpenBrowser) self.openBrowserApp(availablePort);\n\n          //self.openBrowserApp();\n        });\n        serv.timeout = serverTimeout;\n        setTimeout(function () {\n          if (shouldStopServer) {\n            console.log(\"Closing server\");\n            process.exit(0);\n            //serv.close();\n          }\n        }, 3000);\n\n        //   process.on('message', function(message) {\n        // \tself.pao.pa_wiLog('Worker ' + process.pid + ' received message from master.', message);\n        // \tif(message.singleProcessTasks == \"startSingleProcessTasks\") {\n        // \t\tself.emit({type:'start-single-process-tasks',data:''})\n        // \t}\n        // });\n      }\n    } else {\n      // self.pao.pa_wiLog('IT IS NOT THE MASTER PROCESS')\n      self.pao.pa_wiLog(`Worker ${process.pid} started`);\n      let serv = app.listen(availablePort, () => {\n        let PORT = availablePort;\n        self.infoSync(`The Application is running on PID:: ${process.pid} and listening on port: ${PORT}`);\n        // self.adLog(\"The Application is listening via workers\");\n        // self.pao.pa_wiLog(\"THIS WORKER RUNNING IP:\");\n\n        if (shouldOpenBrowser) self.openBrowserApp(availablePort);\n      });\n      process.on(\"message\", function (message) {\n        self.pao.pa_wiLog(\"Worker \" + process.pid + \" received message from master.\", message);\n        if (message.singleProcessTasks == \"startSingleProcessTasks\") {\n          self.emit({\n            type: \"start-single-process-tasks\",\n            data: \"\"\n          });\n        }\n      });\n      serv.timeout = serverTimeout;\n      self.infoSync(\"THE TIMEOUT VALUE\");\n      self.infoSync(serv.timeout);\n      setTimeout(function () {\n        if (shouldStopServer) {\n          console.log(\"CLOSING SERVER\");\n          process.exit(0);\n          //serv.close();\n        }\n      }, 3000);\n    }\n  }).catch(err => {\n    console.log(\"Server could not be started due to a port isssue\", err);\n  });\n};\n// export const folkSlaveWorkers = function(mainWorker){\n// }\nconst handleShutDowns = function () {\n  const self = this;\n  self.pao.pa_wiLog(\"Shutdowns are being handled\");\n  self.context.on(\"INT\", function (code) {\n    if (!self.systemIsShuttingDown) {\n      self.shutDown(\"kill\", code);\n    } else {\n      self.infoSync(\"System is already ShuttingDown:: INT EXIT\");\n    }\n  });\n  self.context.on(\"SIGTEM\", function (code) {\n    if (!self.systemIsShuttingDown) {\n      self.shutDown(\"exit\", code);\n    } else {\n      self.infoSync(\"System is already ShuttingDown:: SIGTEM EXIT\");\n    }\n  });\n  self.context.on(\"uncaughtException\", function (code) {\n    if (!self.systemIsShuttingDown) {\n      self.shutDown(\"uncaughtException\", code);\n    } else {\n      self.infoSync(\"System is already ShuttingDown:: UNHANDLEDEXCEPTION EXIT\");\n    }\n  });\n  self.context.on(\"unhandledRejection\", function (code) {\n    self.infoSync(code.stack);\n    if (!self.systemIsShuttingDown) {\n      self.shutDown(\"uncaughtException\", code);\n    } else {\n      self.infoSync(\"System is already ShuttingDown:: Unhandled Rejection\");\n    }\n  });\n};\nconst handleServerAttachWorkers = function (data) {\n  const self = this;\n  self.masterWorker(data.app);\n};\nconst handleRegisterShutDownCandidate = function (data) {\n  const self = this;\n  const pao = self.pao;\n  if (data.hasOwnProperty(\"candidate\") && pao.pa_isFunction(data.candidate) && data.hasOwnProperty(\"name\") && pao.pa_isString(data.name)) {\n    if (!(self.shutDownServices.indexOf(data.name) > -1)) {\n      self.shutDownServices.push(data.candidate);\n      self.shutDownOrder.push(data.name);\n    }\n  } else {\n    self.pao.pa_wiLog(\"Candidate could not be registered for shutdown\", \"warn\");\n  }\n};\nconst openBrowserApp = async function (portToOpenTo) {\n  const self = this;\n  const open = self.open;\n  await open(`http://localhost:${portToOpenTo}`);\n  // console.log(\"THE BROWSER OPENED\");\n  // const openBrowser = () => import('open').then(({default: open}) => open(\"http://localhost:3000\"));\n  // openBrowser()\n};\nconst getServerPort = function (port = 3000) {\n  const self = this;\n  self.infoSync(`User preffered port: ${port}`);\n  return new Promise((resolve, reject) => {\n    self.detectPort(port).then(gotPort => {\n      if (gotPort === port) {\n        resolve(gotPort);\n      } else {\n        self.portFinder.getPortPromise().then(openPort => {\n          self.infoSync(`Specified port: ${port} is in use, anzii will resort to port:${openPort}`);\n          resolve(openPort);\n        }).catch(err => {\n          reject(err);\n        });\n      }\n    }).catch(err => {\n      console.log(\"Therw was an error trying to get a port\", err);\n      reject(err);\n    });\n  });\n};\n\n//# sourceURL=webpack://anzii/./lib/esm/system/methods.js?");

/***/ }),

/***/ "./lib/esm/system/system.js":
/*!**********************************!*\
  !*** ./lib/esm/system/system.js ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var cluster__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cluster */ \"cluster\");\n/* harmony import */ var detect_port__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! detect-port */ \"detect-port\");\n/* harmony import */ var open__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! open */ \"open\");\n/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! os */ \"os\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var portfinder__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! portfinder */ \"portfinder\");\n/* harmony import */ var _methods_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./methods.js */ \"./lib/esm/system/methods.js\");\n\n\n\n\n\n\n\nclass System {\n  constructor(pao) {\n    this.pao = pao;\n    this.context = process;\n    this.env = this.context.env;\n    this.cluster = cluster__WEBPACK_IMPORTED_MODULE_0__;\n    this.os = os__WEBPACK_IMPORTED_MODULE_3__;\n    this.path = path__WEBPACK_IMPORTED_MODULE_4__;\n    this.shutDownServices = [];\n    this.numOfDBSD = 3;\n    this.allowedDBSTR = 10000;\n    this.serverTimeout = 3000;\n    this.systemIsShuttingDown = false;\n    this.shutDownOrder = [];\n    this.systemBase = {\n      DOCUMENT_ROOT: process.cwd()\n    };\n    this.open = open__WEBPACK_IMPORTED_MODULE_2__;\n    this.detectPort = detect_port__WEBPACK_IMPORTED_MODULE_1__;\n    this.portFinder = portfinder__WEBPACK_IMPORTED_MODULE_5__;\n    this.init = _methods_js__WEBPACK_IMPORTED_MODULE_6__.init;\n    this.handleConfigureSystem = _methods_js__WEBPACK_IMPORTED_MODULE_6__.handleConfigureSystem;\n    this.handleRegisterShutDownCandidate = _methods_js__WEBPACK_IMPORTED_MODULE_6__.handleRegisterShutDownCandidate;\n    this.handleServerAttachWorkers = _methods_js__WEBPACK_IMPORTED_MODULE_6__.handleServerAttachWorkers;\n    this.handleDistributeSystemResources = _methods_js__WEBPACK_IMPORTED_MODULE_6__.handleDistributeSystemResources;\n    this.masterWorker = _methods_js__WEBPACK_IMPORTED_MODULE_6__.masterWorker;\n    // this.folkSlaveWorkers = methods.folkSlaveWorkers\n    this.handleShutDowns = _methods_js__WEBPACK_IMPORTED_MODULE_6__.handleShutDowns;\n    this.shutDown = _methods_js__WEBPACK_IMPORTED_MODULE_6__.shutDown;\n    this.openBrowserApp = _methods_js__WEBPACK_IMPORTED_MODULE_6__.openBrowserApp;\n    this.getServerPort = _methods_js__WEBPACK_IMPORTED_MODULE_6__.getServerPort;\n  }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (System);\n\n//# sourceURL=webpack://anzii/./lib/esm/system/system.js?");

/***/ }),

/***/ "./lib/esm/view/index.js":
/*!*******************************!*\
  !*** ./lib/esm/view/index.js ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _view_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./view.js */ \"./lib/esm/view/view.js\");\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_view_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n//# sourceURL=webpack://anzii/./lib/esm/view/index.js?");

/***/ }),

/***/ "./lib/esm/view/methods.js":
/*!*********************************!*\
  !*** ./lib/esm/view/methods.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checkViewType: () => (/* binding */ checkViewType),\n/* harmony export */   handleConfigView: () => (/* binding */ handleConfigView),\n/* harmony export */   handleViewTask: () => (/* binding */ handleViewTask),\n/* harmony export */   init: () => (/* binding */ init),\n/* harmony export */   isModularView: () => (/* binding */ isModularView),\n/* harmony export */   isTemplateView: () => (/* binding */ isTemplateView),\n/* harmony export */   viewHandler: () => (/* binding */ viewHandler)\n/* harmony export */ });\n/* eslint-disable no-mixed-spaces-and-tabs */\n/* eslint-disable no-unused-vars */\nconst init = function () {\n  this.adLog(\"View has been initialised\");\n  this.listens({\n    \"config-view\": this.handleConfigView.bind(this),\n    \"do-view-task\": this.handleViewTask.bind(this)\n  });\n};\nconst handleConfigView = function (data) {\n  const self = this;\n  let routes = [];\n  let handlers = null;\n  self.pao.pa_wiLog(\"views data from config\");\n  self.pao.pa_wiLog(data);\n  data instanceof Array ? routes = data : (routes = data.routes, handlers = data.handlers);\n  routes.forEach(route => {\n    if (route.view) {\n      if (route.viewty) {\n        let handlerView = \"\";\n        route.viewso.indexOf(\"/\") >= 0 ? handlerView = route.viewso.split(\"/\")[1] : handlerView = route.viewso;\n        self.pao.pa_wiLog(\"THE VIEW HANDLER\");\n        self.pao.pa_wiLog(route.viewso.indexOf(\"/\"));\n        // self.pao.pa_wiLog(route.viewso.indexOf('/'))\n        // self.pao.pa_wiLog(handlers[handlerView])\n        self.pao.pa_wiLog(handlerView);\n        if (route.viewty === \"template\") {\n          if (!self.views) {\n            handlers && handlers[handlerView] && typeof handlers[handlerView] === \"function\" ? self.views = {\n              templates: [{\n                match: route.path,\n                tempPath: route.viewso,\n                title: route.title || \"Html page\",\n                handler: handlers[handlerView].bind(self)\n              }]\n            } : self.views = {\n              templates: [{\n                match: route.path,\n                tempPath: route.viewso,\n                title: route.title || \"Html page\"\n              }]\n            };\n          } else {\n            if (self.views.templates) {\n              handlers && handlers[handlerView] && typeof handlers[handlerView] === \"function\" ? self.views.templates.push({\n                match: route.path,\n                tempPath: route.viewso,\n                title: route.title || \"Html page\",\n                handler: handlers[handlerView].bind(self)\n              }) : self.views.templates.push({\n                match: route.path,\n                tempPath: route.viewso,\n                title: route.title || \"Html page\"\n              });\n            } else {\n              handlers && handlers[handlerView] && typeof handlers[handlerView] === \"function\" ? self.views[\"templates\"] = [{\n                match: route.path,\n                tempPath: route.viewso,\n                title: route.title || \"Html page\",\n                handler: handlers[handlerView].bind(self)\n              }] : self.views[\"templates\"] = [{\n                match: route.path,\n                tempPath: route.viewso,\n                title: route.title || \"Html page\"\n              }];\n            }\n          }\n        } else {\n          if (!self.views) {\n            self.views = {\n              modular: [{\n                match: route.path,\n                vHandler: route.viewso,\n                title: route.title\n              }]\n            };\n          } else {\n            if (self.views.modular) {\n              self.views.modular.push({\n                match: route.path,\n                vHandler: route.viewso,\n                title: route.title\n              });\n            } else {\n              self.views[\"modular\"] = [{\n                match: route.path,\n                vHandler: route.viewso,\n                title: route.title\n              }];\n            }\n          }\n        }\n      } else {\n        if (!self.views) {\n          self.views = {\n            modular: [{\n              match: route.path,\n              vHandler: route.viewso,\n              title: route.title\n            }]\n          };\n        } else {\n          if (self.views.modular) {\n            self.views.modular.push({\n              match: route.path,\n              vHandler: route.viewso,\n              title: route.title\n            });\n          } else {\n            self.views[\"modular\"] = [{\n              match: route.path,\n              vHandler: route.viewso,\n              title: route.title\n            }];\n          }\n        }\n      }\n    }\n  });\n};\nconst handleViewTask = async function (data) {\n  const self = this;\n  const {\n    payload\n  } = data;\n  const {\n    parsed\n  } = payload;\n  const {\n    user\n  } = payload;\n  const view = parsed.derivedUrl || parsed.url;\n  self.pao.pa_wiLog(\"THE VIEW DATA\");\n  self.pao.pa_wiLog(data);\n  self.infoSync(\"HANDLING VIEW TASK\");\n  self.callback = data.callback;\n  let checkViewStatus = self.checkViewType(view);\n  if (checkViewStatus) {\n    if (checkViewStatus.type === \"template\") {\n      self.pao.pa_wiLog(\"about to render template view\");\n      if (self.validView.handler) {\n        let viewData = await self.validView.handler(user);\n        viewData.title = self.validView.title;\n        return self.callback(null, {\n          data: {\n            type: \"template\",\n            view: self.validView.tempPath,\n            viewData: viewData\n          }\n        }, \"renderView\");\n      } else {\n        return self.callback(null, {\n          data: {\n            type: \"template\",\n            view: self.validView.tempPath,\n            title: self.validView.title\n          }\n        }, \"renderView\");\n      }\n    } else if (checkViewStatus.type === \"modular\") {\n      return self.emit({\n        type: `handle-${self.validView.vHandler}-view`,\n        data: {\n          view: self.validView,\n          payload: payload,\n          callback: self.viewHandler.bind(self)\n        }\n      });\n    }\n  } else {\n    return self.callback(null, {\n      method: \"renderView\",\n      data: false\n    });\n  }\n  // if(view(data.req.originalUrl)) return self.emit({type: `handle-${self.requestData.handler}-view`,data: {payload:self.requestData,callback: self.taskerHandler.bind(self),\n  // } })\n};\nconst checkViewType = function (view) {\n  const self = this;\n  let views = self.views;\n  self.pao.pa_wiLog(\"CHECKVIEWTYPE\");\n  self.pao.pa_wiLog(views);\n  if (!views) return null;\n  if (views.templates) if (self.isTemplateView(views.templates, view)) return {\n    type: \"template\"\n  };\n  if (views.modular) if (self.isModularView(views.modular, view)) return {\n    type: \"modular\"\n  };\n  return null;\n  // if(view(data.req.originalUrl)) return self.emit({type: `handle-${self.requestData.handler}-view`,data: {payload:self.requestData,callback: self.taskerHandler.bind(self),\n  // } })\n};\nconst isTemplateView = function (views, view) {\n  const self = this;\n  let isValidView = views.filter((vu, i) => vu.match === view);\n  self.pao.pa_wiLog(\"ISVALID AS FILTERED\");\n  self.pao.pa_wiLog(isValidView);\n  if (isValidView && isValidView.length === 1) {\n    self.validView = isValidView[0];\n    return true;\n  } else {\n    return false;\n  }\n};\nconst isModularView = function (views, view) {\n  const self = this;\n  self.pao.pa_wiLog(\"THE VIEWS IN MODULAR\");\n  self.pao.pa_wiLog(views);\n  self.pao.pa_wiLog(view);\n  let isValidView = views.filter((vu, i) => vu.match === view);\n  self.wiLog();\n  if (isValidView && isValidView.length === 1) {\n    self.validView = isValidView[0];\n    return true;\n  } else {\n    return false;\n  }\n};\nconst viewHandler = function (err = null, data = null) {\n  const self = this;\n  let pao = self.pao;\n  if (err) {\n    return self.callback({\n      message: `There was an error handling ${self.validView.vHandler} view`\n    }, \"renderView\");\n  } else {\n    return self.callback(null, {\n      data: {\n        type: \"modular\",\n        view: data\n      }\n    }, \"renderView\");\n  }\n};\n\n//# sourceURL=webpack://anzii/./lib/esm/view/methods.js?");

/***/ }),

/***/ "./lib/esm/view/view.js":
/*!******************************!*\
  !*** ./lib/esm/view/view.js ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _methods_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./methods.js */ \"./lib/esm/view/methods.js\");\n\nclass View {\n  constructor(pao) {\n    this.pao = pao;\n    this.views = null;\n    this.init = _methods_js__WEBPACK_IMPORTED_MODULE_0__.init;\n    this.handleConfigView = _methods_js__WEBPACK_IMPORTED_MODULE_0__.handleConfigView;\n    this.handleViewTask = _methods_js__WEBPACK_IMPORTED_MODULE_0__.handleViewTask;\n    this.checkViewType = _methods_js__WEBPACK_IMPORTED_MODULE_0__.checkViewType;\n    this.isTemplateView = _methods_js__WEBPACK_IMPORTED_MODULE_0__.isTemplateView;\n    this.isModularView = _methods_js__WEBPACK_IMPORTED_MODULE_0__.isModularView;\n    this.viewHandler = _methods_js__WEBPACK_IMPORTED_MODULE_0__.viewHandler;\n  }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (View);\n\n//# sourceURL=webpack://anzii/./lib/esm/view/view.js?");

/***/ }),

/***/ "./lib/pillar/pillar.js":
/*!******************************!*\
  !*** ./lib/pillar/pillar.js ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EMAIL: () => (/* binding */ EMAIL),\n/* harmony export */   PASSWORD: () => (/* binding */ PASSWORD),\n/* harmony export */   PROMPT: () => (/* binding */ PROMPT),\n/* harmony export */   add_values_to: () => (/* binding */ add_values_to),\n/* harmony export */   array_to_object: () => (/* binding */ array_to_object),\n/* harmony export */   clone: () => (/* binding */ clone),\n/* harmony export */   compare_values: () => (/* binding */ compare_values),\n/* harmony export */   contains: () => (/* binding */ contains),\n/* harmony export */   find_in: () => (/* binding */ find_in),\n/* harmony export */   for_of: () => (/* binding */ for_of),\n/* harmony export */   get_deeply: () => (/* binding */ get_deeply),\n/* harmony export */   is_array: () => (/* binding */ is_array),\n/* harmony export */   is_date: () => (/* binding */ is_date),\n/* harmony export */   is_equal_ab: () => (/* binding */ is_equal_ab),\n/* harmony export */   is_function: () => (/* binding */ is_function),\n/* harmony export */   is_not_falsey: () => (/* binding */ is_not_falsey),\n/* harmony export */   is_object: () => (/* binding */ is_object),\n/* harmony export */   is_same_value: () => (/* binding */ is_same_value),\n/* harmony export */   is_string: () => (/* binding */ is_string),\n/* harmony export */   is_valid_email: () => (/* binding */ is_valid_email),\n/* harmony export */   is_valid_password: () => (/* binding */ is_valid_password),\n/* harmony export */   is_value: () => (/* binding */ is_value),\n/* harmony export */   js_to_json: () => (/* binding */ js_to_json),\n/* harmony export */   json_to_js: () => (/* binding */ json_to_js),\n/* harmony export */   object_to_array: () => (/* binding */ object_to_array),\n/* harmony export */   p_ane: () => (/* binding */ p_ane),\n/* harmony export */   p_arrayPushAll: () => (/* binding */ p_arrayPushAll),\n/* harmony export */   p_arrayToHash: () => (/* binding */ p_arrayToHash),\n/* harmony export */   p_arrayToObj: () => (/* binding */ p_arrayToObj),\n/* harmony export */   p_camelCase: () => (/* binding */ p_camelCase),\n/* harmony export */   p_capitalizeFirstLetter: () => (/* binding */ p_capitalizeFirstLetter),\n/* harmony export */   p_capitalizeLastLetter: () => (/* binding */ p_capitalizeLastLetter),\n/* harmony export */   p_clone: () => (/* binding */ p_clone),\n/* harmony export */   p_copyArray: () => (/* binding */ p_copyArray),\n/* harmony export */   p_createFolderContent: () => (/* binding */ p_createFolderContent),\n/* harmony export */   p_dedupeArray: () => (/* binding */ p_dedupeArray),\n/* harmony export */   p_deepMerge: () => (/* binding */ p_deepMerge),\n/* harmony export */   p_forEach: () => (/* binding */ p_forEach),\n/* harmony export */   p_generateUniqueID: () => (/* binding */ p_generateUniqueID),\n/* harmony export */   p_getDirectories: () => (/* binding */ p_getDirectories),\n/* harmony export */   p_getExtension: () => (/* binding */ p_getExtension),\n/* harmony export */   p_getFile: () => (/* binding */ p_getFile),\n/* harmony export */   p_getFileExtensionFilter: () => (/* binding */ p_getFileExtensionFilter),\n/* harmony export */   p_getFiles: () => (/* binding */ p_getFiles),\n/* harmony export */   p_getMainFileName: () => (/* binding */ p_getMainFileName),\n/* harmony export */   p_getRootDir: () => (/* binding */ p_getRootDir),\n/* harmony export */   p_getTasks: () => (/* binding */ p_getTasks),\n/* harmony export */   p_getWorkingFolder: () => (/* binding */ p_getWorkingFolder),\n/* harmony export */   p_hashToArray: () => (/* binding */ p_hashToArray),\n/* harmony export */   p_inherits: () => (/* binding */ p_inherits),\n/* harmony export */   p_initArray: () => (/* binding */ p_initArray),\n/* harmony export */   p_invertHash: () => (/* binding */ p_invertHash),\n/* harmony export */   p_isBoolean: () => (/* binding */ p_isBoolean),\n/* harmony export */   p_isExistingDir: () => (/* binding */ p_isExistingDir),\n/* harmony export */   p_isFunction: () => (/* binding */ p_isFunction),\n/* harmony export */   p_isNullOrUndefined: () => (/* binding */ p_isNullOrUndefined),\n/* harmony export */   p_isObject: () => (/* binding */ p_isObject),\n/* harmony export */   p_isString: () => (/* binding */ p_isString),\n/* harmony export */   p_loadFile: () => (/* binding */ p_loadFile),\n/* harmony export */   p_loadFileSync: () => (/* binding */ p_loadFileSync),\n/* harmony export */   p_makeFolderSync: () => (/* binding */ p_makeFolderSync),\n/* harmony export */   p_merge: () => (/* binding */ p_merge),\n/* harmony export */   p_mkdirs: () => (/* binding */ p_mkdirs),\n/* harmony export */   p_mkdirsSync: () => (/* binding */ p_mkdirsSync),\n/* harmony export */   p_o_freeze: () => (/* binding */ p_o_freeze),\n/* harmony export */   p_objArrayToHash: () => (/* binding */ p_objArrayToHash),\n/* harmony export */   p_readFileSync: () => (/* binding */ p_readFileSync),\n/* harmony export */   p_saveToFile: () => (/* binding */ p_saveToFile),\n/* harmony export */   p_unikify: () => (/* binding */ p_unikify),\n/* harmony export */   p_union: () => (/* binding */ p_union),\n/* harmony export */   p_wiLog: () => (/* binding */ p_wiLog),\n/* harmony export */   p_wrapTask: () => (/* binding */ p_wrapTask),\n/* harmony export */   p_wrapTimedTask: () => (/* binding */ p_wrapTimedTask),\n/* harmony export */   set_deeply: () => (/* binding */ set_deeply),\n/* harmony export */   string_to_array: () => (/* binding */ string_to_array),\n/* harmony export */   throwErrors: () => (/* binding */ throwErrors),\n/* harmony export */   trim_spaces: () => (/* binding */ trim_spaces),\n/* harmony export */   unlike_props: () => (/* binding */ unlike_props)\n/* harmony export */ });\n/* harmony import */ var async__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! async */ \"async\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var node_module__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node:module */ \"node:module\");\n/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! os */ \"os\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! url */ \"url\");\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! util */ \"util\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! uuid */ \"uuid\");\n\n\n\n\n\n\n\n\nconst require = (0,node_module__WEBPACK_IMPORTED_MODULE_2__.createRequire)(\"file:///Users/surprisemashele/Documents/Development/frameworks/anzii/packages/anzii/lib/pillar/pillar.js\");\nconst __filename = (0,url__WEBPACK_IMPORTED_MODULE_5__.fileURLToPath)(\"file:///Users/surprisemashele/Documents/Development/frameworks/anzii/packages/anzii/lib/pillar/pillar.js\");\nconst EMAIL = \"\";\nconst PASSWORD = \"\";\nconst PROMPT = process.argv || [];\n\n/** Get the current work directory */\nconst p_getWorkingFolder = function () {\n  return process.cwd();\n};\nconst p_o_freeze = function (o) {\n  if (!(o instanceof Object)) return null;\n  return Object.freeze(o);\n};\nconst p_clone = function (o) {\n  if (!(o instanceof Object)) return null;\n  return JSON.parse(JSON.stringify(o));\n};\nconst p_deepMerge = function (from = null, to = null) {\n  if (!(from instanceof Object) || !(to instanceof Object)) return null;\n  return {\n    ...from,\n    ...to\n  };\n};\nconst p_ane = function (obj) {\n  if (util__WEBPACK_IMPORTED_MODULE_6__.types.isNativeError(obj)) {\n    throw obj;\n  }\n};\n// export const p_initArray = moduleExports.p_initArray;\n// export const p_escapeRegExp = function (str) {\n//   return RegExpUtils.escape(str);\n// };\nconst p_merge = function (from, to) {\n  p_forEach(from, function (val, propName) {\n    to[propName] = val;\n  });\n  return to;\n};\nconst p_union = function (a, b) {\n  var union = {};\n  p_merge(a, union);\n  p_merge(b, union);\n  return union;\n};\nconst p_getTasks = function (iterable, getTaskFunction) {\n  var tasks = [];\n  for (var i = 0; i < iterable.length; i++) {\n    tasks.push(getTaskFunction(iterable, i));\n  }\n  return tasks;\n};\nconst p_wrapTask = function (context, func, argArray) {\n  if (!Array.isArray(argArray)) {\n    argArray = [];\n  }\n  return function (callback) {\n    argArray.push(callback);\n    func.apply(context, argArray);\n  };\n};\nconst p_wrapTimedTask = function (context, func, name, argArray) {\n  if (p_isString(argArray)) {\n    name = argArray;\n    argArray = [];\n  }\n  var task = p_wrapTask(context, func, argArray);\n  return function (callback) {\n    var start = Date.now();\n    task(function (err, result) {\n      callback(err, {\n        result: result,\n        time: Date.now() - start,\n        start: start,\n        name: name\n      });\n    });\n  };\n};\nconst p_forEach = function (iterable = null, handler = null) {\n  if (!iterable || !handler) return false;\n  if (!(iterable instanceof Object) || !(handler instanceof Object)) return false;\n  var internalHandler;\n  var internalIterable;\n  if (Array.isArray(iterable)) {\n    internalHandler = handler;\n    internalIterable = iterable;\n  } else if (p_isObject(iterable)) {\n    internalIterable = Object.getOwnPropertyNames(iterable);\n    internalHandler = function (propName, i) {\n      handler(iterable[propName], propName, iterable, i);\n    };\n  } else {\n    return false;\n  }\n  //execute native foreach on interable\n  internalIterable.forEach(internalHandler);\n  return true;\n};\n// export const p_arrayToHash = moduleExports.p_arrayToHash;\nconst p_unikify = function (array) {\n  var a = array.concat();\n  for (var i = 0; i < a.length; ++i) {\n    for (var j = i + 1; j < a.length; ++j) {\n      if (a[i] === a[j]) a.splice(j--, 1);\n    }\n  }\n  return a;\n};\n// export const p_arrayToObj = moduleExports.p_arrayToObj;\nconst p_objArrayToHash = function (array, hashProp) {\n  if (!Array.isArray(array)) {\n    return null;\n  }\n  var hash = {};\n  for (var i = 0; i < array.length; i++) {\n    hash[array[i][hashProp]] = array[i];\n  }\n  return hash;\n};\nconst p_hashToArray = function (obj, hashKeyProp) {\n  if (!p_isObject(obj)) {\n    return null;\n  }\n  var doHashKeyTransform = p_isString(hashKeyProp);\n  return Object.keys(obj).reduce(function (prev, prop) {\n    prev.push(obj[prop]);\n    if (doHashKeyTransform) {\n      obj[prop][hashKeyProp] = prop;\n    }\n    return prev;\n  }, []);\n};\nconst p_capitalizeFirstLetter = function (text) {\n  console.log(\"The text Uppercasing;;;\", text);\n  return `${text.slice(0, 1).toUpperCase()}${text.slice(1)}`;\n};\nconst p_capitalizeLastLetter = function (text) {\n  console.log(\"The text Lowercasing;;;\", text);\n  return `${text.slice(0, text.length - 1)}${text.slice(text.length - 1).toLowerCase()}`;\n};\nconst p_camelCase = function (text, sep = \"-\") {\n  console.log(\"The camelCasing;;;\", text);\n  if (!sep) return text;\n  if (text.indexOf(sep) < 0) return text;\n  return `${text.split(sep).map((t, i) => {\n    if (i === 0) return t;\n    return p_capitalizeFirstLetter(t);\n  }).join(\"\")}`;\n};\nconst p_invertHash = function (obj) {\n  if (!p_isObject(obj)) {\n    return null;\n  }\n  var new_obj = {};\n  for (var prop in obj) {\n    if (obj.hasOwnProperty(prop)) {\n      new_obj[obj[prop]] = prop;\n    }\n  }\n  return new_obj;\n};\nconst p_copyArray = function (array) {\n  if (!Array.isArray(array)) {\n    return null;\n  }\n  var clone = [];\n  for (var i = 0; i < array.length; i++) {\n    clone.push(array[i]);\n  }\n  return clone;\n};\nconst p_dedupeArray = function (array) {\n  var hash = p_arrayToHash(array);\n  return Object.keys(hash);\n};\nconst p_arrayPushAll = function (from, to) {\n  if (!Array.isArray(from) || !Array.isArray(to)) {\n    return false;\n  }\n  for (var i = 0; i < from.length; i++) {\n    to.push(from[i]);\n  }\n};\nconst p_generateUniqueID = function () {\n  return uuid__WEBPACK_IMPORTED_MODULE_7__.v4();\n};\nconst p_getMainFileName = function () {\n  // let filename = __non_webpack_require__.main.filename\n  // let dir = path.resolve(path.dirname(filename))\n  // let dirIndex = filename.indexOf(dir)\n  // let nameIndex = 0\n  // filename = filename.slice(dirIndex,filename.length)\n  // name = filename.slice(dirIndex+1,filename.indexOf('.'))\n  // ext = filename.slice(nameIndex,filename.length)\n  return null;\n};\nconst p_getRootDir = function () {\n  // let filename = __filename;\n  let dir = path__WEBPACK_IMPORTED_MODULE_4__.dirname(__filename);\n  return dir;\n};\n\n// eslint-disable-next-line no-unused-vars\nconst p_mkdirs = function (absoluteDirPath, isFileName, cb) {\n  const that = this;\n  return new Promise((resolve, reject) => {\n    if (that.p_isFunction(isFileName)) {\n      cb = isFileName;\n      isFileName = false;\n    }\n    if (!that.p_isString(absoluteDirPath)) {\n      return reject(new Error(\"absoluteDirPath must be a valid file path\"));\n    }\n    var pieces = absoluteDirPath.split(path__WEBPACK_IMPORTED_MODULE_4__.sep);\n    var curr = \"\";\n    var isWindows = os__WEBPACK_IMPORTED_MODULE_3__.type().toLowerCase().indexOf(\"windows\") !== -1;\n    var tasks = that.p_getTasks(pieces, function (pieces, i) {\n      return function (callback) {\n        //we need to skip the first one bc it will probably be empty and we\n        //want to skip the last one because it will probably be the file\n        ////// name not a directory.\n        var p = pieces[i];\n        if (p.length === 0 || isFileName && i >= pieces.length - 1) {\n          return callback();\n        }\n        curr += (isWindows && i === 0 ? \"\" : path__WEBPACK_IMPORTED_MODULE_4__.sep) + p;\n        fs__WEBPACK_IMPORTED_MODULE_1__.exists(curr, function (exists) {\n          if (exists) {\n            return callback();\n          }\n          fs__WEBPACK_IMPORTED_MODULE_1__.mkdir(curr, callback);\n        });\n      };\n    });\n    async__WEBPACK_IMPORTED_MODULE_0__.series(tasks, function (err /*, results*/) {\n      if (err) return reject(err);\n      resolve(true);\n    });\n  });\n  // const that = this\n  // if (that.p_isFunction(isFileName)) {\n  //     cb = isFileName;\n  //     isFileName = false;\n  // }\n  // if (!that.p_isString(absoluteDirPath)) {\n  //     return cb(new Error('absoluteDirPath must be a valid file path'));\n  // }\n  // var pieces = absoluteDirPath.split(path.sep);\n  // var curr      = '';\n  // var isWindows = os.type().toLowerCase().indexOf('windows') !== -1;\n  // var tasks     = that.p_getTasks(pieces, function(pieces, i) {\n  //     return function(callback) {\n  //         //we need to skip the first one bc it will probably be empty and we\n  //         //want to skip the last one because it will probably be the file\n  //         //name not a directory.\n  //         var p = pieces[i];\n  //         if (p.length === 0 || (isFileName && i >= pieces.length - 1)) {\n  //             return callback();\n  //         }\n  //         curr += (isWindows && i === 0 ? '' : path.sep) + p;\n  //         fs.exists(curr, function(exists) {\n  //             if (exists) {\n  //                 return callback();\n  //             }\n  //             fs.mkdir(curr, callback);\n  //         });\n  //     }\n  // });\n  // async.series(tasks, function(err/*, results*/){\n  //     cb(err);\n  // });\n};\n/**\n * Synchronously makes the specified directory structure.\n * @static\n * @method mkdirsSync\n * @param {String} absoluteDirPath The absolute path of the directory structure\n * to be created\n * @param {Boolean} isFileName When true the value after the last file\n * separator is treated as a file.  This means that a directory with that value\n * will not be created.\n */\nconst p_mkdirsSync = function (absoluteDirPath, isFileName) {\n  const that = this;\n  if (!that.p_isString(absoluteDirPath)) {\n    throw new Error(\"absoluteDirPath must be a valid file path\");\n  }\n  var pieces = absoluteDirPath.split(path__WEBPACK_IMPORTED_MODULE_4__.sep);\n  var curr = \"\";\n  var isWindows = os__WEBPACK_IMPORTED_MODULE_3__.type().toLowerCase().indexOf(\"windows\") !== -1;\n  pieces.forEach(function (p, i) {\n    //we need to skip the first one bc it will probably be empty and we\n    //want to skip the last one because it will probably be the file\n    //name not a directory.\n    if (p.length === 0 || isFileName && i >= pieces.length - 1) {\n      return;\n    }\n    curr += (isWindows && i === 0 ? \"\" : path__WEBPACK_IMPORTED_MODULE_4__.sep) + p;\n    if (!fs__WEBPACK_IMPORTED_MODULE_1__.existsSync(curr)) {\n      fs__WEBPACK_IMPORTED_MODULE_1__.mkdirSync(curr);\n    }\n  });\n};\n// export const p_isObject = moduleExports.p_isObject;\n// export const p_isString = moduleExports.p_isString;\n// export const p_isFunction = moduleExports.p_isFunction;\nconst p_isNullOrUndefined = function (value) {\n  return value === null || typeof value === \"undefined\";\n};\nconst p_isBoolean = function (value) {\n  return value === true || value === false;\n};\n// export const p_getDirectories = moduleExports.p_getDirectories;\n// export const p_getFiles = moduleExports.p_getFiles;\n// export const p_getFile = moduleExports.p_getFile;\nfunction\n// p_isDirectory(item){\n// },\np_isExistingDir(filePath) {\n  console.log(\"THE EXISTANCE PATH\", filePath);\n  const checkResults = fs__WEBPACK_IMPORTED_MODULE_1__.existsSync(filePath);\n  console.log(\"existence results\", checkResults);\n  return checkResults;\n}\nconst p_makeFolderSync = function (absolutePath) {\n  return fs__WEBPACK_IMPORTED_MODULE_1__.mkdirSync(absolutePath);\n};\n// export const p_createFolderContent = moduleExports.p_createFolderContent;\n// export const p_loadFile = moduleExports.p_loadFile;\nconst p_saveToFile = function (fileToSaveTo, contents) {\n  // const contents = fs.readFileSync(origFilePath, 'utf8');\n  const writePath = `${fileToSaveTo}`;\n  console.log(\"saveToFile\", writePath);\n  fs__WEBPACK_IMPORTED_MODULE_1__.writeFileSync(writePath, contents, \"utf8\");\n};\nfunction p_wiLog(message) {\n  if (!process.env.ANZII_SHOW_WILD_LOGS) return;\n  if (process.env.ANZII_SHOW_WILD_LOGS.trim().toLowerCase() === \"false\") return;\n  console.log(message);\n}\n// export const p_getMainFileName = moduleExports.p_getMainFileName;\n// export const p_getRootDir = moduleExports.p_getRootDir;\n// export const p_mkdirs = moduleExports.p_mkdirs;\n// export const p_mkdirsSync = moduleExports.p_mkdirsSync;\n// export const p_getExtension = moduleExports.p_getExtension;\nconst p_getFileExtensionFilter = function (extension) {\n  var ext = \".\" + extension;\n  return function (fullPath) {\n    return fullPath.lastIndexOf(ext) === fullPath.length - ext.length;\n  };\n};\nconst p_inherits = function (Type1, Type2) {\n  if (p_isNullOrUndefined(Type1) || p_isNullOrUndefined(Type2)) {\n    throw new Error(\"The type parameters must be objects or prototypes\");\n  }\n  util__WEBPACK_IMPORTED_MODULE_6__.inherits(Type1, Type2);\n  p_merge(Type2, Type1);\n};\nconst js_to_json = function (jsObject) {\n  var jsonString = JSON.stringify(jsObject);\n  return jsonString;\n};\nconst json_to_js = function (jsonString) {\n  var jsObject = JSON.parse(jsonString);\n  return jsObject;\n};\n// export const clone = moduleExports.clone;\n// export const object_to_array = moduleExports.object_to_array;\n// export const array_to_object = moduleExports.array_to_object;\n// export const string_to_array = moduleExports.string_to_array;\n// export const set_deeply = moduleExports.set_deeply;\nconst get_deeply = function () {};\nconst is_function = function (x) {\n  return Object.prototype.toString.call(x) === \"[object Function]\";\n};\nconst is_array = function (x) {\n  return Object.prototype.toString.call(x) === \"[object Array]\";\n};\nconst is_date = function (x) {\n  return Object.prototype.toString.call(x) === \"[object Date]\";\n};\nconst is_object = function (x) {\n  return Object.prototype.toString.call(x) === \"[object Object]\";\n};\nconst is_string = function (x) {\n  return Object.prototype.toString.call(x) === \"[object String]\";\n};\n// export const is_value = moduleExports.is_value;\n// export const is_not_falsey = moduleExports.is_not_falsey;\nconst trim_spaces = function (x) {\n  if (x instanceof String) {\n    return x.trim();\n  } else {\n    return x;\n  }\n};\n// export const compare_values = moduleExports.compare_values;\n// export const is_equal_ab = moduleExports.is_equal_ab;\nconst is_valid_email = function () {\n  return true;\n};\nconst is_valid_password = function () {\n  return true;\n};\n// export const is_same_value = moduleExports.is_same_value;\nconst unlike_props = function (a, b) {\n  let akeys = Object.keys(a);\n  let bkeys = Object.keys(b);\n  if (a.length > b.length) {\n    let unlike = null;\n    for (let k of akeys) {\n      if (a[k] !== b[k]) {\n        if (unlike) {\n          unlike.a.push(k);\n        } else {\n          unlike = {\n            a: [k]\n          };\n        }\n      }\n    }\n    return unlike;\n  } else {\n    let unlike = null;\n    for (let k of bkeys) {\n      if (b[k] !== a[k]) {\n        if (unlike) {\n          unlike.b.push(k);\n        } else {\n          unlike = {\n            b: [k]\n          };\n        }\n      }\n    }\n    return unlike;\n  }\n};\nconst throwErrors = function (errorMessage) {\n  throw new Error(errorMessage);\n};\n// export const contains = moduleExports.contains;\n// export const for_of = moduleExports.for_of;\n// export const add_values_to = moduleExports.add_values_to;\n// export const find_in = moduleExports.find_in;\n\n/**\n * Initializes an array with the specified number of values.  The value at each\n * index can be static or a function may be provided.  In the event that a\n * function is provided the function will be called for each item to be placed\n * into the array.  The return value of the function will be placed into the\n * array.\n * @static\n * @method initArray\n * @param {Integer} cnt The length of the array to create\n * @param {Function|String|Number} val The value to initialize each index of\n * the array\n * @return {Array} The initialized array\n */\nconst p_initArray = function (cnt, val) {\n  var v = [];\n  var isFunc = this.p_isFunction(val);\n  for (var i = 0; i < cnt; i++) {\n    v.push(isFunc ? val(i) : val);\n  }\n  return v;\n};\n\n/**\n * Hashes an array\n * @static\n * @method arrayToHash\n * @param {Array} array      The array to hash\n * @param {*} [defaultVal =true] Default value if the hashing fails\n * @return {Object} Hash\n */\nconst p_arrayToHash = function (array, defaultVal) {\n  if (!Array.isArray(array)) {\n    return null;\n  }\n  //set the default value\n  if (p_isNullOrUndefined(defaultVal)) {\n    defaultVal = true;\n  }\n  var hash = {};\n  for (var i = 0; i < array.length; i++) {\n    if (this.p_isFunction(defaultVal)) {\n      hash[defaultVal(array, i)] = array[i];\n    } else {\n      hash[array[i]] = defaultVal;\n    }\n  }\n  return hash;\n};\n/**\n * Converts an array to an object.\n * @static\n * @method arrayToObj\n * @param {Array} array The array of items to transform from an array to an\n * object\n * @param {String|Function} keyFieldOrTransform When this field is a string it\n * is expected that the array contains objects and that the objects contain a\n * property that the string represents.  The value of that field will be used\n * as the property name in the new object.  When this parameter is a function\n * it is passed two parameters = the array being operated on and the index of\n * the current item.  It is expected that the function will return a value\n * representing the key in the new object.\n * @param {String|Function} [valFieldOrTransform] When this value is a string\n * it is expected that the array contains objects and that the objects contain\n * a property that the string represents.  The value of that field will be used\n * as the property value in the new object.  When this parameter is a function\n * it is passed two parameters = the array being operated on and the index of\n * the current item.  It is expected that the function return a value\n * representing the value of the derived property for that item.\n * @return {Object} The converted array.\n */\nconst p_arrayToObj = function (array, keyFieldOrTransform, valFieldOrTransform) {\n  if (!Array.isArray(array)) {\n    return null;\n  }\n  var keyIsString = p_isString(keyFieldOrTransform);\n  var keyIsFunc = this.p_isFunction(keyFieldOrTransform);\n  if (!keyIsString && !keyIsFunc) {\n    return null;\n  }\n  var valIsString = p_isString(valFieldOrTransform);\n  var valIsFunc = this.p_isFunction(valFieldOrTransform);\n  if (!valIsString && !valIsFunc) {\n    valFieldOrTransform = null;\n  }\n  var obj = {};\n  for (var i = 0; i < array.length; i++) {\n    var item = array[i];\n    var key = keyIsString ? item[keyFieldOrTransform] : keyFieldOrTransform(array, i);\n    if (valIsString) {\n      obj[key] = item[valFieldOrTransform];\n    } else if (valIsFunc) {\n      obj[key] = valFieldOrTransform(array, i);\n    } else {\n      obj[key] = item;\n    }\n  }\n  return obj;\n};\n\n/**\n * Tests if a value is an object\n * @static\n * @method isObject\n * @param {*} value\n * @return {Boolean}\n */\nconst p_isObject = function (value) {\n  return !p_isNullOrUndefined(value) && typeof value === \"object\";\n};\n/**\n * Tests if a value is an string\n * @static\n * @method isString\n * @param {*} value\n * @return {Boolean}\n */\nconst p_isString = function (value) {\n  const that = this;\n  return !that.p_isNullOrUndefined(value) && typeof value === \"string\";\n};\n/**\n * Tests if a value is a function\n * @static\n * @method isFunction\n * @param {*} value\n * @return {Boolean}\n */\nconst p_isFunction = function (value) {\n  return !this.p_isNullOrUndefined(value) && typeof value === \"function\";\n};\n/**\n * Retrieves the subdirectories of a path\n * @static\n * @method getDirectories\n * @param {String}   dirPath The starting path\n * @param {Function} cb      Callback function\n */\nconst p_getDirectories = function (dirPath) {\n  const that = this;\n  return new Promise((resolve, reject) => {\n    var dirs = [];\n    fs__WEBPACK_IMPORTED_MODULE_1__.readdir(dirPath, function (err, files) {\n      if (util__WEBPACK_IMPORTED_MODULE_6__.types.isNativeError(err)) {\n        return reject(err);\n      }\n      var tasks = that.p_getTasks(files, function (files, index) {\n        return function (callback) {\n          var fullPath = path__WEBPACK_IMPORTED_MODULE_4__.join(dirPath, files[index]);\n          fs__WEBPACK_IMPORTED_MODULE_1__.stat(fullPath, function (err, stat) {\n            if (util__WEBPACK_IMPORTED_MODULE_6__.types.isNativeError(err)) {\n              return reject(err);\n            }\n            if (that.p_isNullOrUndefined(stat)) {\n              this.p_wiLog(\"WARN: Util: unstatable file encountered: %s\", fullPath);\n            } else if (stat.isDirectory()) {\n              dirs.push(fullPath);\n            }\n            callback(err);\n          });\n        };\n      });\n      async__WEBPACK_IMPORTED_MODULE_0__.parallel(tasks, function /*, results*/\n      () {\n        resolve(dirs);\n      });\n    });\n  });\n};\n/**\n * Retrieves file and/or directorie absolute paths under a given directory path.\n * @static\n * @method getFiles\n * @param {String} dirPath The path to the directory to be examined\n * @param {Object} [options] Options that customize the results\n * @param {Boolean} [options.recursive=false] A flag that indicates if\n * directories should be recursively searched.\n * @param {Function} [options.filter] A function that returns a boolean\n * indicating if the file should be included in the result set.  The function\n * should take two parameters.  The first is a string value representing the\n * absolute path of the file.  The second is the stat object for the file.\n * @param {Function} cb A callback that takes two parameters. The first is an\n * Error, if occurred. The second is an array of strings representing the\n * absolute paths for files that met the criteria specified by the filter\n * function.\n */\nconst p_getFiles = function (dirPath, options, fileName) {\n  let that = this;\n  // console.log('gETTING FILES')\n  // console.log(dirPath)\n  // console.log(options)\n  return new Promise((resolve, reject) => {\n    // if (this.p_isFunction(options)) {\n    //     cb      = options;\n    //     options = {\n    //         recursive: false,\n    //         filter: function(/*fullPath, stat*/) { return true; }\n    //     }\n    // }\n    // if(!options){\n    //     options = {\n    //         recursive: false,\n    //         filter: function(/*fullPath, stat*/) { return true; }\n    //     }\n    // }\n    that.p_wiLog(\"The directory path\");\n    that.p_wiLog(dirPath);\n    that.p_wiLog(fileName);\n    // console.log(fileName)\n    //read files from dir\n    fs__WEBPACK_IMPORTED_MODULE_1__.readdir(dirPath, function (err, q) {\n      if (util__WEBPACK_IMPORTED_MODULE_6__.types.isNativeError(err)) {\n        return reject(err);\n      }\n      that.p_wiLog(\"The readdir results q\");\n      that.p_wiLog(q);\n      // console.log(q)\n      let filePaths = [];\n      //seed the queue with the absolute paths not just the file names\n      for (var i = 0; i < q.length; i++) {\n        // that.p_wiLog(q[i])\n        // q[i] = path.join(dirPath, q[i]);\n        filePaths.push(path__WEBPACK_IMPORTED_MODULE_4__.join(dirPath, q[i]));\n      }\n      //process the q\n      // console.log(q)\n      // console.log(filePaths)\n      if (filePaths.indexOf(path__WEBPACK_IMPORTED_MODULE_4__.join(dirPath, fileName)) !== -1) {\n        that.p_wiLog(\"THE IS A NEED FOR A SPECIFIC FILE\");\n        // let filePathCont = filePaths[filePaths.indexOf(filePath)]\n        // let file = filePathCont.substr(filePath.indexOf(fileName),filePathCont.length - 1)\n        // that.p_wiLog(filePathCont)\n        // that.p_wiLog(file)\n        let file = filePaths[filePaths.indexOf(path__WEBPACK_IMPORTED_MODULE_4__.join(dirPath, fileName))];\n        // console.log('THE FILE')\n        // console.log(file)\n        return resolve(file);\n      } else {\n        return resolve(null);\n      }\n      // for(let p =0; p < filePaths.length; p++){\n      //     if(filePaths.indexOf(filePath) !== -1){\n      //         that.p_wiLog('THE IS A NEED FOR A SPECIFIC FILE')\n      //         let filePathCont = filePaths[filePaths.indexOf(filePath)]\n      //         let file = filePathCont.substr(filePath.indexOf(fileName),filePathCont.length - 1)\n      //         that.p_wiLog(filePathCont)\n      //         that.p_wiLog(file)\n      //         resolve(file)\n      //     }else{\n      //         resolve(filePaths);\n      //     }\n      // }\n      //  var filePaths = [];\n      // async.whilst(\n      //     function() {\n      //         console.log('THE Q LENGTH')\n      //         console.log(q.length)\n      //         console.log(q.length)\n      //         return q.length > 0; }\n      //     function(callback) {\n      //         console.log('The second with ca')\n      //         console.log(callback)\n      //         var fullPath = q.shift();\n      //         fs.stat(fullPath, function(err, stat) {\n      //             if (util.types.isNativeError(err)) {\n      //                 console.log('THERE ERROR')\n      //                 return callback(err);\n      //             }\n      //             //apply filter\n      //             var meetsCriteria = true;\n      //             if (that.p_isFunction(options.filter)) {\n      //                 meetsCriteria = options.filter(fullPath, stat);\n      //             }\n      //             //examine result and add it when criteria is met\n      //             if (meetsCriteria) {\n      //                 filePaths.push(fullPath);\n      //             }\n      //             //when recursive queue up directory's for processing\n      //             if (!options.recursive || !stat.isDirectory()) {\n      //                 return callback(null);\n      //             }\n      //             //read the directory contents and append it to the queue\n      //             fs.readdir(fullPath, function(err, childFiles) {\n      //                 if (util.types.isNativeError(err)) {\n      //                     return callback(err);\n      //                 }\n      //                 childFiles.forEach(function(item) {\n      //                     q.push(path.join(fullPath, item));\n      //                 });\n      //                 callback(null);\n      //             });\n      //         });\n      //     }\n      //     function(err) {\n      //         console.log('THE FILES ARRAY')\n      //         console.log(err)\n      //         that.p_wiLog('THE FILES ARRay')\n      //         let filePath = dirPath+path.sep+fileName\n      //         that.p_wiLog(filePath)\n      //         if(filePaths.indexOf(filePath) !== -1){\n      //             that.p_wiLog('THE IS A NEED FOR A SPECIFIC FILE')\n      //             let filePathCont = filePaths[filePaths.indexOf(filePath)]\n      //             let file = filePathCont.substr(filePath.indexOf(fileName),filePathCont.length - 1)\n      //             that.p_wiLog(filePathCont)\n      //             that.p_wiLog(file)\n      //             resolve(file)\n      //         }else{\n      //             resolve(filePaths);\n      //         }\n      //     }\n      // );\n    });\n  });\n};\nconst p_getFile = function (filePath) {\n  return new Promise(resolve => {\n    this.p_wiLog(\"The directory path\");\n    this.p_wiLog(filePath);\n    //read files from dir\n    var s = fs__WEBPACK_IMPORTED_MODULE_1__.createReadStream(filePath);\n    if (s) {\n      resolve(s);\n    }\n  });\n};\nconst p_createFolderContent = function (sourcePath, savePath, ignore = null) {\n  // console.log(\"CREATE FOLDER CONTENT SOURCE\", sourcePath)\n  const self = this;\n  const CURR_DIR = self.p_getWorkingFolder();\n  const filesToCreate = fs__WEBPACK_IMPORTED_MODULE_1__.readdirSync(sourcePath);\n  // console.log(\"CREATE FOLDER CONTENT CURR_DI\",CURR_DIR)\n  // console.log(\"CREATE FOLDER CONTENT FILES TO CREATE\", filesToCreate)\n  // console.log(\"CREATE FOLDER CONTENT FILES TO IGNORE\", ignore)\n  filesToCreate.forEach(file => {\n    const origFilePath = `${sourcePath}/${file}`;\n    // console.log(\"CREATE FOLDER CONTENT Original File pATH\", origFilePath)\n    // Get file statitics\n    const stats = fs__WEBPACK_IMPORTED_MODULE_1__.statSync(origFilePath);\n    let skip = false;\n    if (stats.isFile()) {\n      // let fileBaseName = path.basename(origFilePath)\n      // console.log(\"CREATE FOLDER CONTENT writepath pATH\", fileBaseName)\n      // console.log(\"CREATE FOLDER CONTENT file\", file)\n      if (ignore && this.contains(ignore, file)) skip = true;\n      if (!skip) {\n        const contents = fs__WEBPACK_IMPORTED_MODULE_1__.readFileSync(origFilePath, \"utf8\");\n        const writePath = `${CURR_DIR}/${savePath}/${file}`;\n        // console.log(\"CREATE FOLDER CONTENT writepath pATH\", origFilePath)\n        fs__WEBPACK_IMPORTED_MODULE_1__.writeFileSync(writePath, contents, \"utf8\");\n      }\n    } else if (stats.isDirectory()) {\n      // console.log(\"THE FOLDER\", file)\n      if (ignore && this.contains(ignore, file)) skip = true;\n      if (!skip) {\n        fs__WEBPACK_IMPORTED_MODULE_1__.mkdirSync(`${CURR_DIR}/${savePath}/${file}`);\n        // recursive call\n        self.p_createFolderContent(`${sourcePath}/${file}`, `${savePath}/${file}`);\n      }\n    }\n  });\n};\nconst p_loadFile = function (filepath) {\n  return new Promise((resolve, reject) => {\n    this.p_wiLog(`THE FILEPATH load,${filepath}`);\n    if (!p_isExistingDir(filepath)) return reject({\n      code: \"FILE_PATH_ERROR\",\n      message: \"File path does not exist\",\n      filePath: filepath\n    });\n    const ext = path__WEBPACK_IMPORTED_MODULE_4__.extname(filepath);\n    this.p_wiLog(`FILE EXTENSION, ${ext}`);\n    if (ext === \".json\") {\n      try {\n        const readJson = p_readFileSync(filepath);\n        this.p_wiLog(`THE READ JSON, ${readJson}`);\n        return resolve(readJson);\n      } catch (err) {\n        console.log(\"failed to findJSON\", err.code);\n        return reject(err);\n      }\n      // import(`${filepath}`, {\n      //     with: { type: 'json' }\n      //   }).then((foundJson)=>{\n      //     console.log(\"JSON WAS FOUND\")\n      //     return resolve(foundJson)\n      //   }).catch((err)=>{\n      //     try{\n      //         const readJson = p_readFileSync(filepath)\n      //         console.log(\"THE READ JSON\",readJson)\n      //         return resolve(readJson)\n      //     }\n      //     catch(err){\n      //         console.log(\"failed to findJSON\",err.code)\n      //         return reject(err)\n      //     }\n\n      //   });\n    }\n    __webpack_require__(\"./lib/pillar lazy recursive\")(filepath).then(moduleFound => {\n      console.log(\"THE FOUND MODULE\", moduleFound);\n      let foundFileContent = moduleFound?.default || moduleFound;\n      resolve(foundFileContent);\n    }).catch(importERR => {\n      console.log(\"IMPORT ERROR\", importERR);\n      try {\n        const readFile = p_loadFileSync(filepath);\n        this.p_wiLog(`THE READ FILE, ${JSON.stringify(readFile)}`);\n        return resolve({\n          default: readFile\n        });\n      } catch (err) {\n        this.p_wiLog(`MODULE FETCH ERROR, ${err.code}`);\n        return reject(err);\n      }\n      // console.log(\"MODULE FETCH ERROR\", err);\n      // reject(err);\n    });\n  });\n\n  // console.log('THE FILEPATH')\n  // console.log(filepath)\n  // console.log(__non_webpack_require__.main)\n  // eslint-disable-next-line no-undef\n};\nconst p_loadFileSync = function (filepath) {\n  //if(!p_isExistingDir(filepath) || filepath !== \"@babel/register\" || filepath !== \"babel-register\") return ({code:\"FILE_PATH_ERROR\",message:\"File path does not exist\",filePath:filepath})\n  console.log(\"REQUIRE'S\");\n  const foundFile = require(filepath);\n  console.log(\"THE FILE FOUND FROM REQUIRE\", foundFile);\n  return foundFile;\n};\nconst p_readFileSync = function (filepath) {\n  if (!p_isExistingDir(filepath)) return null;\n  return fs__WEBPACK_IMPORTED_MODULE_1__.readFileSync(filepath, {\n    encoding: \"utf8\"\n  });\n};\n\n/**\n * Retrieves the extension off of the end of a string that represents a URI to\n * a resource\n * @static\n * @method getExtension\n * @param {String} filePath URI to the resource\n * @param {Object} [options]\n * @param {Boolean} [options.lower=false] When TRUE the extension will be returned as lower case\n * @param {String} [options.sep] The file path separator used in the path.  Defaults to the OS default.\n * @return {String} The value after the last '.' character\n */\nconst p_getExtension = function (filePath, options) {\n  const that = this;\n  if (!that.p_isString(filePath) || filePath.length <= 0) {\n    return null;\n  }\n  if (!that.p_isObject(options)) {\n    options = {};\n  }\n  //do to the end of the path\n  var pathPartIndex = filePath.lastIndexOf(options.sep || path__WEBPACK_IMPORTED_MODULE_4__.sep) || 0;\n  if (pathPartIndex > -1) {\n    filePath = filePath.substr(pathPartIndex);\n  }\n  var ext = null;\n  var index = filePath.lastIndexOf(\".\");\n  if (index >= 0) {\n    ext = filePath.substring(index + 1);\n    //apply options\n    if (options.lower) {\n      ext = ext.toLowerCase();\n    }\n  }\n  return ext;\n};\nconst clone = function (o) {\n  if (o instanceof Array) {\n    let newA = [];\n    o.forEach(e => {\n      if (e instanceof Array) {\n        newA.push(this.clone(e));\n      } else if (e instanceof Object) {\n        newA.push(this.clone(e));\n      } else {\n        newA.push(e);\n      }\n    });\n    return newA;\n  } else if (o instanceof Object && typeof o !== \"function\") {\n    let n = {};\n    for (let p in o) {\n      if (o[p] instanceof Array) {\n        n[p] = this.clone(o[p]);\n      } else if (o[p] instanceof Object && typeof o[p] !== \"function\") {\n        n[p] = this.clone(o[p]);\n      } else {\n        if (p === \"callback\") {\n          this.p_wiLog(\"The current property is callback\");\n        }\n        n[p] = o[p];\n      }\n    }\n    return n;\n  }\n};\n/*********************************** OBJECT AND ARRAY CASTING ************************************************************/\nconst object_to_array = function (castObj, keys = false) {\n  // this.p_wiLog('THE CAST OBJECT')\n  // this.p_wiLog(castObj)\n  if (castObj instanceof Object) {\n    if (!(castObj instanceof Array)) {\n      var arr = [];\n      var count = 0;\n      if (keys) {\n        for (let key in castObj) {\n          arr[count] = {\n            key: key,\n            value: castObj[key]\n          };\n          ++count;\n        }\n      } else {\n        for (let key in castObj) {\n          arr[count] = castObj[key];\n          ++count;\n        }\n      }\n      //    this.p_wiLog('THE RETURN OF CONVERTED OBJECT')\n      //    this.p_wiLog(arr)\n      return arr;\n    } else {\n      return castObj;\n    }\n  } else {\n    this.throwErrors(\"Argument 1 of object_to_array() must be an object\");\n  }\n};\nconst array_to_object = function (castArr) {\n  if (castArr instanceof Array) {\n    var obj = {};\n    for (var i = 0; i < castArr.length; i++) {\n      var property = \"property_\" + (i + 1);\n      obj[property] = castArr[i];\n    }\n    return obj;\n  } else {\n    this.throwErrors(\"Argument 1 of array_to_object() must be an array\");\n  }\n};\nconst string_to_array = function (string, sep) {\n  // this.p_wiLog('STRING TO ARRAY')\n  // this.p_wiLog(string)\n  // this.p_wiLog(sep)\n  if (this.is_string(string)) {\n    // this.p_wiLog('THE STRING IS AN INSTANCE OF STRING')\n    return string.split(sep);\n  }\n};\nconst set_deeply = function (path, deep, value = null, type = null) {\n  //  this.p_wiLog('TYPEOF AC')\n  //  this.p_wiLog(ac)\n  // if(!(ac)){\n  // \tthis.p_wiLog('AC IS NULL')\n  // \tvar a = deep\n  // }\n  // this.p_wiLog('THE VALUE OF A')\n  // this.p_wiLog(a)\n  if (path.length === 1) {\n    this.p_wiLog(\"ABOUT TO SET DEEPLY NESTED PROP\");\n    this.p_wiLog(\"THE DEEP\");\n    this.p_wiLog(deep);\n    if (!value) {\n      this.p_wiLog(\"THIS DEEP ARRAY\");\n      this.p_wiLog(this.js_to_json(deep));\n      this.p_wiLog(\"THE DEEP I,i\");\n      deep.splice(path[0], 1);\n      this.p_wiLog(deep);\n    } else {\n      deep[path[0]] = value;\n    }\n    this.p_wiLog(path);\n    this.p_wiLog(path[0]);\n    this.p_wiLog(deep[path]);\n    return true;\n  }\n  if (!deep[path[0]]) {\n    this.p_wiLog(\"THE PROPERTY BELOW DOES NOT EXIST\");\n    this.p_wiLog(path);\n    this.p_wiLog(path[0]);\n    //  this.p_wiLog(deep[path[0]])\n    return false;\n  }\n  return this.set_deeply(path.slice(1), deep[path[0]], value, type);\n};\nconst is_value = function (x) {\n  return !this.isObject(x) && !this.isArray(x);\n};\nconst is_not_falsey = function (x) {\n  if (this.trim_spaces(x)) {\n    return true;\n  } else {\n    return false;\n  }\n};\nconst compare_values = function (value1, value2) {\n  if (value1 === value2) {\n    return;\n  }\n  if (this.is_date(value1) && this.is_date(value2) && value1.getTime() === value2.getTime()) {\n    return;\n  }\n  if (value1 !== value2) {\n    value1 = value2;\n    return;\n  }\n};\nconst is_equal_ab = function (a, b, flag = \"values\") {\n  if (!(this.is_object(a) && this.is_object(b))) {\n    return false;\n  }\n  if (Object.keys(a).length !== Object.keys(b).length) {\n    return false;\n  }\n  if (flag.trim() === \"keys\") {\n    var bKeys = Object.keys(b).sort();\n    var aKeys = Object.keys(a).sort();\n    return JSON.stringify(aKeys) === JSON.stringify(bKeys);\n    // var akeys = Object.keys(a)\n    // for (let k of akeys) {\n    // \tif (a[k] !== b[k]) {\n    // \treturn false;\n    // \t}\n    // }\n    // return true\n  } else {\n    if (!(this.js_to_json(a) === this.js_to_json(b))) {\n      return false;\n    } else {\n      return true;\n    }\n  }\n};\nconst is_same_value = function (x, y) {\n  if (this.isBrowserSupported(\"Object\", \"is\")) {\n    return Object.is(x, y);\n  } else {\n    return this.polyFills().objectIs(x, y);\n  }\n};\nconst contains = function (o, v) {\n  if (this.is_array(o)) {\n    return o.indexOf(v) > -1 ? true : false;\n  } else if (this.is_object(o)) {\n    if (this.is_array(v)) {\n      this.p_wiLog(\"THE SPECIFED VALUE TO CHECK IS AN ARRAY\");\n      this.p_wiLog(v);\n      let outcome = \"\";\n      for (let i = 0; i < v.length; i++) {\n        if (!o.hasOwnProperty(v[i])) {\n          outcome = false;\n          break;\n        } else if (i === v.length - 1) {\n          outcome = true;\n        }\n      }\n      this.p_wiLog(\"THE OUTCOME\");\n      this.p_wiLog(outcome);\n      return outcome;\n    } else {\n      return o.hasOwnProperty(v) ? true : false;\n    }\n  } else {\n    this.throwErrors(\"Contains() requires either an array pure js object\");\n  }\n};\nconst for_of = function (x, action, y = null) {\n  x = this.clone(x);\n  if (this.is_array(x)) {\n    x.forEach(action);\n  } else if (this.is_object(x)) {\n    if (!y) {\n      // this.p_wiLog('THE FOROF Y IS NULL')\n      // this.p_wiLog(x)\n      // this.p_wiLog('THE Y IS DEFINED')\n      let newX = {};\n      for (let p in x) {\n        let prop = action(p, x[p]);\n        newX[prop.p] = prop.v;\n      }\n      // this.p_wiLog('THE NEWX')\n      // this.p_wiLog(newX)\n      return newX;\n    } else {\n      for (let p in x) {\n        action(p, x[p]);\n      }\n    }\n  } else {\n    this.throwErrors(\"Object of for_of() must be an Array or pure object\");\n  }\n};\nconst add_values_to = function (x, keys, values, action = () => {}) {\n  if (this.is_array(x)) {\n    x.forEach(action);\n  } else if (this.is_object(x)) {\n    keys.forEach(k => {\n      let vItemKeys = Object.keys(values[k]);\n      if (x[k]) {\n        vItemKeys.forEach(v => {\n          x[k][v] = values[v];\n        });\n      } else {\n        x[k] = {};\n        vItemKeys.forEach(v => {\n          x[k][v] = values[v];\n        });\n      }\n    });\n    return x;\n  } else {\n    this.throwErrors(\"Object of for_of() must be an Array or pure object\");\n  }\n};\nconst find_in = function (x, id, f) {\n  if (this.is_array(x)) {\n    if (this.is_value(x[0])) {\n      return x.indexOf(f) > -1 ? x[f] : false;\n    } else if (this.is_object(x[0])) {\n      for (let i = 0; i < x.length; i++) {\n        if (contains(x[i], id) && x[i][id] === f) {\n          return x[i];\n        }\n      }\n    }\n  }\n};\n\n//# sourceURL=webpack://anzii/./lib/pillar/pillar.js?");

/***/ }),

/***/ "./lib/start.js":
/*!**********************!*\
  !*** ./lib/start.js ***!
  \**********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   anzii: () => (/* binding */ anzii)\n/* harmony export */ });\n/* harmony import */ var _anzii_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./anzii.js */ \"./lib/anzii.js\");\n\nconst Anzii = _anzii_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\nconst anzii = function (modules = null) {\n  //  console.log('THE VALUE OF ACTIVATE')\n  //  console.log(Anzii)\n  // console.log(Components)\n  // console.log('The typeof Components')\n  // console.log(Components instanceof Array)\n  // console.log('The server Module')\n  // console.log(Server)\n  // Components.unshift({Server})\n  // let html = true\n  //    console.log('ANZII OBJECT')\n  //    console.log(Anzii)\n  //    console.log(Anzii.Activate)\n  modules ? Anzii.Activate([modules]) : Anzii.Activate();\n};\n\n//# sourceURL=webpack://anzii/./lib/start.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/create fake namespace object */
/******/ 	(() => {
/******/ 		var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);
/******/ 		var leafPrototypes;
/******/ 		// create a fake namespace object
/******/ 		// mode & 1: value is a module id, require it
/******/ 		// mode & 2: merge all properties of value into the ns
/******/ 		// mode & 4: return value when already ns object
/******/ 		// mode & 16: return value when it's Promise-like
/******/ 		// mode & 8|1: behave like require
/******/ 		__webpack_require__.t = function(value, mode) {
/******/ 			if(mode & 1) value = this(value);
/******/ 			if(mode & 8) return value;
/******/ 			if(typeof value === 'object' && value) {
/******/ 				if((mode & 4) && value.__esModule) return value;
/******/ 				if((mode & 16) && typeof value.then === 'function') return value;
/******/ 			}
/******/ 			var ns = Object.create(null);
/******/ 			__webpack_require__.r(ns);
/******/ 			var def = {};
/******/ 			leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
/******/ 			for(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {
/******/ 				Object.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));
/******/ 			}
/******/ 			def['default'] = () => (value);
/******/ 			__webpack_require__.d(ns, def);
/******/ 			return ns;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./lib/start.js");
/******/ 	module.exports = __webpack_exports__;
/******/ 	
/******/ })()
;